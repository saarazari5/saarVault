![[Pasted image 20220629142540.png]]

נפתור את כל שלושת האפשרויות : 

$O(n)$ 
נעשה סריקת $BFS$ על כל קומה בעץ אם לקודקוד יש שני ילדים, ממשיכים, אחרת 
אם יש ילד אחד מוסיפים $2^{h-i-1}$ כאשר $i$ מייצג את הקומה החסרה , וממשיכים לילד הימני. 
אם חסרים שני ילדים אז נוסיף $2^{h-i}-1$ קודקודים ויוצאים מהריקורסיה עבור תת העץ הזה. 
__הוכחת נכונות__ 
אנחנו יודעים כמה קודקודים יש בעץ בינארי מלא $2^{h}-1$ (כשאני אומר גובה אני מתכוון לא למספר הקשתות הגדול ביותר אלא למספר הקומות כאשר השורש מתחיל מקומה 1) ולכן אם לא הגענו לגובה $h$ ונתקלנו בקודקודים חסרים, אנחנו יודעים כמה צריך להשלים.  סך הכל אנחנו עוברים על כל קודקוד בעץ ולכן $O(n)$

$O(min(n,(d+1)\cdot h))$  
בישביל לפתור את זה עלינו להכיר את תכונות העץ הכמעט מלא ולדעת שהעץ יהיה כמו עץ מלא עד הרמה התחתונה ואחת שמעליה כלומר אפשר לדלג על כל הבדיקות שעשינו באלגוריתם הקודם עד להגעה לגובה המקסימלי של העץ
כעת רצים על הקודוקדים בגובה זה , על מנת שהעץ יהיה שלם עמור להיות $2^{h-1}$ קודקודים בשלב הזה, לכן נוכל להתחיל לספור את העלים משמאל לימין כשנסיים , נחסר $2^{h-1}-x$ ואלו יהיו העלים החסרים . במקרה הזה יכול להיות שאנחנו נסרוק עץ שהוא מלא כבר ובגלל שאנחנו יודעים שמספר העלים בעץ מלא הוא $\frac{n+1}{2}$ אז או שנהיה חסומים ב $O(n)$ או שבמקרה השני יש פחות עלים מכמות האיטרציות שעשינו כדי לרדת למטה .

$O(h^{2})$
נלך צעד אחד שמאלה, ונרד עד הסוף ימינה - 
* אם מצאנו שקיים עלה ברמה הנדרשת - עולים בחזרה לשורש שממנו באנו, הולכים לתת העץ הימני ומבצעים את אותו התהליך (אין צורך ללכת לשמאל, כל מי ששם יהיה שלם לפי הגדרה)
ברגע שהגענו לעלה שאינו ברמה הנדרשת באופן הזה אנחנו יודעים שהוא הראשון משמאל שיקיים את זה ולכן נוכל לעצור .

* אם הגענו לעלה לא ברמה הנדרשת, אנחנו יודעים שכל מי שמימין גם לא ברמה הנדרשת, ולכן צריך ללכת שמאלה לחפש את הקודקוד הראשון שהוא כן עלה ברמה הנדרשת, לכן עולים לשורש של העץ ממנו באנו, והולכים לתת העץ השמאלי שלו ומבצעים את אותו התהליך.ברגע שהגענו לעלה שהוא כן ברמה הנדרשת באופן הזה אנחנו יודעים שהוא הראשון משמאל שיקיים את זה ולכן נוכל לעצור .

על מנת לבצע את המנייה ,  בשני המקרים נתחיל לספור את כמות העלים שדרכנו עליהם עד שמצאנו את העלה המבוקש כאשר אנחנו יודעים שהעלה הראשון שאנחנו מתחילים בו הוא תמיד העלה האמצעי. 


![[Pasted image 20220629153333.png]]

__יש המון פתרונות לבעיה הזאת כולל כזאת שלא דורשת סיבכויות מקום בכלל__ 
אני אסביר את הפתרון הגנרי
נבנה מחסנית עזר שתכיל את סדרת ההמינימום שאי פעם נכנסו למחסנית כדי שנדע מי המינמום הקודם למקרה שנעשה pop למינימום העכשווי

כמו כן כדי לשלוף את איבר המינימום בזמן $O(1)$ נצטרך פשוט לגשת למחסנית ולעשות peek. 

כל פעם שנכניס איבר נבדוק אם קטן מהמינימום אם כן נדחוף אותו למחסנית המינימום שלנו והוא יהיה המינימום החדש. כל הוצאת איבר, נבדוק אם הוא המינימום או לא , אם הוא כן, נוציא אותו גם מהמחסנית עזר שלנו.


![[Pasted image 20220629153651.png]]

__א__ 
![[Pasted image 20220629155118.png]]

__ב__ ראשית נוכיח שניתן להמיר עץ חיפוש לעץ 2-3
נוכל לעשות זאת בקלות על ידי הדפסת inorder והכנסת המערך לפי החציונים לעץ 2-3

כיוון שעץ 2-3 יכול להכיל יותר מערך 1 בוודאות יתקיים שעל כל ילד ימני שני של קודקוד היינו עולים למעלה בעץ 