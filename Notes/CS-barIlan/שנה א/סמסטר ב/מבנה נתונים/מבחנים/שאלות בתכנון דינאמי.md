![[Pasted image 20220619230654.png]]

![[Pasted image 20220629212147.png]]

__נאיבי__ $O(2^{n})$ על כל ערך נרוץ על כל הסכומים האפשריים שלו עם $n-1$ הערכים האפשרים רצים על קבוצה החזקה של $[n]$ ובודקים את כל הצירופים האפשריים. 

__ריקורסיבי__ 
נגדיר את הפונקצייה הבאה 
 $$f(A,n,k)=\begin{cases}
    true & k=0  \\
     false & n=0   \\
 f(A,n-1,k)&A[n]>k \\
 or(f(A,n-1,k-A[n]),f(A,n-1,k)) & else
  \end{cases}$$
  הסבר, קלט : המערך כ$A$ גודלו כ $n$ והמספר שמחפשים כ $k$ . אם המשקל שווה ל0 אין מה לחפש כי המספרים טבעיים אז הכל תקין וכנ״ל אם המערך ריק. אחרת לוקחים את האיבר האחרון , אם אין מה לבדוק אותו, כלומר משקלו גבוה יותר מהסכום, נבדוק בלעדיו, אחרת נפעיל את האופרטור הבינארי $or$ על הפונקצייה כאשר מחשיבים את האיבר בסכום ואת הפונקצייה כאשר האיבר לא בסכום. 

__סיבוכיות__  כמו באלגוריתם הנאיבי גם פה במקרה הגרוע אנחנו נבדוק את כל התי קבוצות האפשרויות, ולכן זמן הריצה לא השתנה.  הסיבוכיות מעידה על נכונות האלגוריתם כיוון שגם פה אנחנו סורגים את כל הקבוצות האפשרויות עד שנקבל תשובה. מספיק שאחת מהן תחזיר אמת כדי להגיע לתשובה אבל במקרה הגרוע נסרוק את כל $2^{n}$ תתי הקבוצות האפשרויות עד שנגלה האם קיים סכום או לא. 

__דינאמי__  נשתמש בטכניקה של memorization כלומר מלמעלה למטה, נחזיק מערך דו מימדי המכיל את כל הזוגות הסדורים האפשריים של אינדקס והסכום שאפשר לקבל כלומר מטריצה בגודל $n\times k$ . המערך יהיה מאותחל כולו מ $-1$ המערך יכיל את הערכים true  או false בעת ההשמה (כלומר 0 או 1).
וכעת כל מה שנשאר לעשות הוא לפני הקריאות הריקורסיביות לבדוק האם יש איבר במקום ה $n,k$ של המטריצה שלנו.
אם יש נחזיר אותו , אחרת נבדוק בידיוק את אותם התנאים רק נעשה השמה באופן הבא: 
 $$f(A,n,k)=\begin{cases}
    true & k=0  \\
     false & n=0   \\R[n-1,k]  &R[n-1,k]\neq{-1}  \\
 R[n-1,k]=f(A,n-1,k)&A[n]>sum \\& else\\
 R[n-1,sum]=\\or(f(A,n-1,k-A[n]),f(A,n-1,k)) 
  \end{cases}$$
סיבוכיות זמן+מקום $O(n\cdot k)$ 
```ad-Code
```java

	static int subsetSum(int a[], int n, int sum)
	{
		// Storing the value -1 to the matrix
		int tab[][] = new int[n + 1][sum + 1];
		for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= sum; j++) {
				tab[i][j] = -1;
			}
		}
		if (sum == 0)
			return 1;

		if (n <= 0)
			return 0;

		if (tab[n - 1][sum] != -1)
			return tab[n - 1][sum];

		if (a[n - 1] > sum)
			return tab[n - 1][sum]
				= subsetSum(a, n - 1, sum);
		else {
			if (subsetSum(a, n - 1, sum) != 0
				|| subsetSum(a, n - 1, sum - a[n - 1])
					!= 0) {
				return tab[n - 1][sum] = 1;
			}
			else
				return tab[n - 1][sum] = 0;
		}
	}


```
![[Pasted image 20220629220647.png]]

__נאיבי__ 
אנחנו נרצה את תת הקבוצה הקטנה ביותר שתקיים שסכום הערכים שלה יוצא בידיוק הסכום המבוקש. הפתרון  הנאיבי יהיה לרוץ על קבוצת החזקה של סוגי המטבעות כלומר $2^{k}$ ולחשב את כל האפשרויות השונות.  

__ריקורסיה__ 
נגדיר את הפונקצייה הבאה 

$$f(V,k,n)=\begin{cases}
    0 & k=0 \vee{n=0} \\  n &k=1 \\
 f(V,k-1,n)&V[k]>n \\
 min(f(V,k,n-V[k])+1,f(V,k-1,n)) & else
  \end{cases}$$
  הסבר : 
  * אם ביקשתי סכום שערכו 0 או שאין לי מטבעות אז אין מה לעשות , ואם יש רק מטבע אחד אז יש רק סכום אחד שאפשרי. 
  * אם המטבע ה k יותר גדול מהסכום אז אין לנו מה לעשות איתו ונקרא קריאה ריקורסיבית בלעדיו
  * אחרת, נבדוק מהו המינימום בין הפעלת הקריאה בלעדיו לבין הפעלת הקריאה עמו. נשים לב שלא הורדנו את המספר גם אם לקחנו אותו כי יש אופצייה לבחור בו שוב, אבל הוספנו לתוצאה 1 כי בחרנו כבר מטבע אחד לחישוב. 

__נכונות__
כמו שבשאלה הקודמת גם כן בסופו של דבר נבדוק את כל הצירופים הצירופים האפשריים של תתי הקבוצות ולכן סך הכל הריקורסיה עובדת . (אפשר להוכיח באינדוקציה שאכן בכלל ניתן לקחת $f$ מטבעות מאוסף $V$ עם דרישה לסכום של $k$).

__דינאמי__ 

את הבעיה הזאת נפתור בשיטת top down גם כן, נגדיר מערך דו מימדי בגודל $k\times n$ בדומה לתרגיל הקודם לפני הקריאות הריקורסיביות נבדוק האם קיים ערך במקום עליו אנחנו עומדים, אם כן נחזיר אותו בזמן קבוע אחרת נפעיל את הקריאות הריקורסיביות תוך כדי השמה. 

$$f(V,k,n)=\begin{cases}
    0 & k=0 \vee{n=0} \\  n &k=1 \\ R[k-1,n] & R[k-1,n]\neq0\\
 R[k-1,n]=f(V,k-1,n)&V[k]>n \\
 R[k-1,n]=min(f(V,k,n-V[k])+1,f(V,k-1,n)) & else
  \end{cases}$$

  סיבוכיות $O(n\cdot k)$ 

```ad-Code
```cpp
f(V,k,n):
 if k == 0 or n == o : return 0
 if k==1 : return n
 if R[k-1,n] != 0 : return R[k-1,n]
 if V[k]>n : return f(V,k-1,n)
 return min(f(V,k,n-V[k])+1 , f(V,k-1,n))
```

![[Pasted image 20220630001731.png]]

__נאיבי__ נחשב את כל הקריאות האפשריות , על קבוצת החזקה של הקלט $S$ כלומר כל תתי המחרוזות האפשריות  סך הכל $O(2^n)$ .

__ריקורסיבי__ 
נגיד את הפונקצייה הבאה

```ad-Code
```cpp

f(S,n,i):
  if i>=n
    return true
  for(j=i ; j<=n l j++) :
    return T(S,i,j) and f(S,i,j+1)
```

כלומר נחזיק מצביע לתחילת המילה ועל כל אינדקס שנבחר נבדק האם התת מילה עצמה היא חוקית וגם כל מה שאחריה.
בדומה לאלגוריתמים הריקורסיבים האחרים גם במקרה הזה היעילות לא משתפרת כיוון שאנחנו סורקים את כל תתי המילים האפשרויות ותיתכן כפילויות.

__דינאמי__
נשים לב שהפעם אנחנו עובדים עם אינדקס אחד נוכל לשמור את המידע $f(i)$ במערך חד מימדי $A[n]$ כך שבאיבר האחרון נשמור $true$ ובכל ערך $i$ אחר נשמור האם קיימת חלוקה ל $f(i)$ כלומר לתת הסטרינג $S[i...n]$ .  האלגוריתם יהיה top down כיוון שאנחנו בונים את הסטרינג שלנו מתוך הבנה שהגעה לסוף משמעותה שהגענו ל$true$ 
```ad-Code
```cpp
for i=n to 1 {
  boolean temp = false
 for j=n to i {
   if j >= n:
   temp = T(S, i, j) and A[j+1]
    if j==n:
     temp = T(S, i, j)
     if temp == true:
     A[i] <- true
     break
     if temp == false:
   A[i] <- false
  }
 }
return A[1];
```
נשים לב שtemp שמייצג את הערך העתיד להכנס לאיבר במקום ה $i$ תלוי בערך שבא לפני כי מילה תיחשב תקינה אם גם תת המילה שלפני ותת המילה שאחריה הן תקינות.

זמן הריצה יהיה $O(n^{2})$ כי בעצם מבצעים בנייה של איברים המערך באופן התלוי בכל מי שהיה לפניו. 
סיבוכיות המקום היא $O(n)$ .