![[Pasted image 20220629170806.png]]

__א__ 
הפרכה: נגדיר 
$$f(n)=3, \ \ g(n)=|sin(n)|$$

נקבל 
![[Pasted image 20220629172125.png]]

אין לנו איך לחסום מלמטה כי הקבוע חייב להיות גדול מ 0


__ב__ 
הוכחה , 
אם $f(n)\in\Theta(g(n))$ אז יתקיים :

$$\lim_{n\to\infty}\frac{f(n)}{g(n)}=0$$

במילים, זה אומר שלכל $c_{2},c_{1}>0$ שניקח לא משנה כמה נכפיל את $f(n)$ ו $g(n)$ בהם , עדיין היחס הזה יתקיים לכן 
$o(f(n))=o(g(n))$.

![[Pasted image 20220629174042.png]]

__הפרכה__ נב״ש שקיים מבנה נתונים המקיים את הנ״ל וניתן לו כקלט מערך לא ממויין שגודלו חזקה של 10 הגדולה מ 2.
כיוון שהבנייה חסומה ב $O(n)$ פעולות, ואלגוריתם של מיון מבוסס השוואה חסום ב $O(n\log n)$ הרי שלא ניתן למיין את המערך. (גם לא ניתן לעשות מיון מנייה או מיון ספרות כי אין חסם).
לא משנה מה השינויים שעשינו על המערך נוכל לדעת בוודאות שהוא לא ממויין.

כעת נפעיל את השאילתה find10 על כל המערך, אומנם במערך ממויין היינו יכולים לשלוף את הערך ב $O(1)$ אבל במצב הנוכחי הדבר לא אפשרי כיוון שהמערך בוודאות לא ממויין. גם אם הפעילו את אלגוריתם quick select על האיבר במקום ה10, נוכל לקחת תת המערך שהאיבר ה 10 בו יהיה האיבר במקום ה11 ואם גם על זה עשו את האלגוריתם נוכל לבנות תת מערך אחר. כלומר סך הכל לא ניתן לשלוף כל איבר ב find10 בזמן קבוע. (אם הם היו עושים quick select על כל האפשרויות הם היו עוברים את זמן הריצה הליניארי).
__כדרוש__ 

![[Pasted image 20220629175535.png]]

מחליפים אותו עם העוקב שלו, 34, לאחר מכן נוריד את 30 להיות העלה ונמחק אותו 

יהיה מספר ילדים נמוך מדי לקודקוד עם 51 ו 58 ולכן נצטרך לבצע השלמה או איחוד. 

במקרה שלנו לא ניתן להשלים מהשכן אז נבצע איחוד, שלב ראשון ניקח את את 51 ונאחד עם 53. כעת המצב תקין אז אין צורך לאחד עם השכן , נבצע תיקון ריקורסיבי כדי לראות שהכל תקין במעלה העץ ונקבל שכן. סך הכל :
![[Pasted image 20220629180038.png]]
