![[Pasted image 20220629192720.png]]

בישביל 1,2 מספיק לבחור בעץ avl סטנדרטי .
בשביל מציאת האיבר העוקב נשים לב שלא מספיקות לנו התכונות שאנחנו מכירים כי אם נדפיס inorder ואחר כך נמצא את האיבר המתאים , השאילתה תיקח יותר מדי זמן. 

לכן נוסיף תכונה לכל קודקוד במבנה הנתונים שתחזיר את מספר העצים בתת העץ השמאלי. 
כעת, כשיש לנו מספר זה נוכל לדעת מה האינדקס של קודקוד $x$ על ידי לקיחת מספר כל הקודקודים השמאליים של תתי העץ הימניים של $x$ (כלומר הולכים ימינה מ$x$ ובכל קודקוד שנתקלים לוקחים את כל בניו השמאליים פלוס הקודוקד הזה) והחסרתם מ $n$ . כעת אנחנו יודעים את המיקום של $x$ במערך נסמנו $t$. כעת נרוץ שוב פעם מ $x$ ימינה על כל קודקוד שנלך ימינה נבדוק האם מספר הקודקודים משמאלו גדול מ $n-t$ אם כן אז הערך נמצא בתת העץ השמאלי של הבן הימני. אחרת נמשיך ימינה ובאופן ריקורסיבי נעשה זאת שוב. 


![[Pasted image 20220629194616.png]]
המערכים כולם ממויינים, לכן מה שנעשה זה כך, מכל מערך נשלוף את האיבר הראשון ונעטוף אותו ב מידע שיכיל את המיקום המקורי שלו ב$A_{i}$ כלומר נוסיף לו את $i$ . כעת ניקח את כל $m$ האיברים ונפעיל עליהם build heap עם יחס הסדר של ערימת מינימום. סך הכל זמן הבנייה יהיה $O(m)$ (נשים לב שאת הערימה נבנה רק פעם אחת). כעת שורש הערימה הוא האיבר הנמוך ביותר , נשלוף אותו החוצה ונשמור במערך גדול בגודל $n$ . ברגע ששלפנו את השורש נלך ל $A_i$ המתאים לו וניקח משם את האיבר הבא בגודלו (כיוון שזה מערך ממויין אז אם שלפנו $t$ ערכים ניקח את הערך ה$t+1$). לאחר כל שליפה נבצע הכנסה שאנחנו יודעים שהיא חסומה ב $O(\log m )$  ונבצע את התהליך הזה $n$ פעמים עד שנמלא את כל המערך הגדול שבנינו. 

סך הכל מבחינת סיבוכיות נקבל :
$$m+O(n\log m)\in O(n\log m)$$
