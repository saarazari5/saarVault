![[Pasted image 20220629181401.png]]
__א__ 
פשוט נרוץ נאיבית , נבצע 4 לולאות על כל ערך נחפש את השלישייה המתאימה לו

__ב__
נמיין את המערך עם $merge sort$ שלוקח $O(n)$ סיבוכיות מקום, כעת במקום לחפש רביעייה, נרוץ בשלוש לולאות, על כל שלישייה אפשרית שנקבל , נסמנה $x_{i},x_{j},x_{r}$ נחפש בחיפוש בינארי על המערך הממויין את 
$y-x_{i}-x_{j}-x_{r}$ .

__ג__ נבנה אוסף חדש בגודל $n^2$ המכיל את כל הזוגות הסדורים האפשריים , כעת נמיין את האוסף הזה לפי סכום הזוגות . מה שנשאר לעשות הוא לגשת למערך המקורי ולרוץ עליו בלולאה כפולה 
על כל שני ערכים $x_{i,j}$ שניקח נחפש בחיפוש בינארי סכום שערכו יהיה $y-x_{i}-x_{j}$ וזאת הרביעייה הרצויה.


![[Pasted image 20220629183926.png]]
אם היה קיים אלגוריתם כזה, היינו יכולים להדפיס את העץ בצורה $inorder$ ולקבל את אוסף המספרים הזה בצורה ממויינת. אבל זה בסתירה לחסם תחתון על המיון שהוא $O(n\log n)$ שזה יותר גדול מ $O(n\log^{*}n)$ .


![[Pasted image 20220629184617.png]]

__א__ בהנחה שעוקב הוא תרתי משמע המספר העוקב מבחינת סדר בעץ, אז האלגוריתם תמיד יסתיים כי המספר היחיד שלא יהיה לו עוקב בעץ הוא האיבר הגדול ביותר בעץ הבינארי שהוא תמיד יהיה העלה הימני ביותר. 

__ב__ ההבדל הוא בסדר העדיפויות למחיקה, אנחנו בוחרים בשיטה של מחיקת האיבר העוקב אם ורק אם יש לקודקוד שאותו נרצה למחוק שני הילדים ואז גם בוודאות יש לו עוקב. במידה ואין לו שני ילדים אנחנו מוחקים בשיטה הדומה לשיטה של רשימה מקושרת, לאו דווקא מחיקה לפי הסדר בעץ, מטרת המחיקה לפי הסדר היא לשמור על העץ כעץ בינארי ולא לאבד מצביעים שמקושרים לקודקודים אחרים. 

__ג__ 8 ייתחלף עם 10 שיתחלף עם 13 שיימחק


![[Pasted image 20220629190451.png]]

__א__ עץ שהשורש הוא 3 הילד ימני הוא 5 והילד השמאלי הוא 2, העוקב של 2 יהיה בכלל אביו, מה שלא ייתכן ולכן לא מתאים לכל קודקוד

__ב__ אם א מתקיים זה בהכרח אומר שלקודקוד שלנו יש שני בנים וזה כבר האלגוריתם מחיקה מעץ בינארי שאנחנו מכירים ואוהבים. 

