__סער אזערי__ 

![[Pasted image 20220524201117.png]]
הפתרון הנאיבי יהיה לחשב עבור כל מלבן את השטח הנוצר מהגובה שלו ביחס לשכנים שלו וככה להגיע לפתרון, עם זאת , הדרך אינה יעילה כל כך $O(n^2)$ , אך נשתמש בה כבסיס לייעול כיוון שאנחנו יודעים באמצעות האלגוריתם ה brute force הזה, את הדרך הפעולה הרצוייה.

השאלה המתבקשת לייעול האלגוריתם הינה ״האם ניתן למצוא בזמן יעיל יותר מהוא המלבן הבא מימין והבא משמאל __שיותר נמוכים__ ביחס למלבן שאני נמצא בו?״

לשם כך נבנה מחסנית ריקה נסמנה $s$. המחסנית תכיל בתוכה את האינדקסים של כל המלבנים שיותר גדולים ממלבן באינדקס $i$  בסדר עולה , כלומר, בראש המחסנית יהיה האינדקס הכי גבוה ממה שסרקנו.
 כמו כן נשמור משתנה מקומי $max$ שיחזיק בתוכו את השטח הגדול ביותר שחושב במהלך האיטרצייה.
נרוץ על המלבנים, אם גובה המלבן במקום ה $i$ יותר גדול או שווה מאיבר במערך באינדקס בראש המחסנית נוסיף את האינדקס הזה למחסנית ונקדם את האינדקס ב1
אחרת, 
נוציא איברים מהמחסנית עד שהתנאי העליון יתקיים או שהמחסנית תהיה ריקה, כאשר כל הוצאה מהמחסנית נחשב את השטח ביחס למלבן שעליו אנחנו נמצאים (כלומר מחשבים את כל שטח שמקדים לאינדקס עליו אנחנו נמצאים) ונשמור במשתנה. בסוף נוסיף את האינדקס שאנחנו עליו למחסנית.

ממשיכים באופן הזה על האלגוריתם עד המלבן האחרון . בסוף האיטרצייה נחשב את השטח עבור המלבנים שנשארו במחסנית ונשווה עם השטח המקסימלי (במחסנית יישארו כל המלבנים שאפשר להכפיל אותם מימין עד הסוף __לדוגמה: מלבן 2 בתמונה הנ״ל__).

### זמן ריצה 
אם המערך ממויין עולה אז נכניס את כל האיברים למחסנית בלי הוצאה ואם המערך ממויין יורד אז כל אינדקס שנעצור נכנס למחסנית ובאיטרציה הבאה נחשב את השטח עם כל הקודמים כשבסוף המחסנית ריקה, סה״כ עבור המקרה הראשון יהיה איטרצייה על $n$ איברים והוצאה של $n$ איברים ובמקרה השני פשוט נחשב מיידית לכל איבר את השטח ביחס לכל המקומות לפניו (כיוון שתמיד האיבר בראש המחסנית יהיה יותר גבוה מהאיבר הבא ברשימה) ולכן פשוט נחשב את הגובה לפי ערך המערך כפול האינדקס (כפל זאת פעולה קבועה). סך הכל לשני המקרים $O(n)$ . כל מקרה אחר יוסיף מספר קבוע של חישובים אך זמן הריצה עדיין יישמר.

סיבוכיות מקום $O(n)$.


### הוכחת נכונות 
מהגדרת האלגוריתם אנחנו מחשבים את כל השטחים האפשריים לכל איבר במערך במידה ונוסיף איבר למערך ונחשב מחדש בהכרח יתקיים שהוא יהיה גבוה יותר או נמוך יותר מהאיבר בראש המחסנית , אם הוא גבוה יותר המיקום שלו ייכנס למחסנית ויחושב בסוך האיטרצייה אחרת השטח שלו ביחס לקודמיו יחושב מיידית וישווה עם הגודל המקסימלי שחישבנו עד כה.
### קוד 
![[Pasted image 20220525155758.png]]

![[Pasted image 20220524205623.png]]
### בנייה  
נתחיל מבניית המבנה , נרצה להעלות את האיברים במבנה שלנו, באופן שיקיים את הנתונים, כיוון שאנחנו מקבלים ככקלט איברים ממויינים ויתרה מכך את גודל הסדרה $n$ ואף אנחנו יודעים ש $n$ הוא חזקה של $2$ נסמן $n=2^k$ .  הבסיס למבנה יהיה הרשימה הממויינת שלנו. נבנה רשימה מקושרת חדשה עם $\pm{\infty}$ בקצוות. כל איבר זוגי עולה למעלה לקומה חדשה. כך נבצע בכל קומה בעת בניית המבנה, כלומר, בכל קומה נעבור על האיברים הזוגיים (כאשר מתייחסים לכל קומה כרשימה בפני עצמה) ונעלה אותם לקומה חדשה כך עד שנשאר עם איבר אחד בקומה הגבוהה ביותר.
כעת נשים לב שהמערך בקלט ממויין וכיוון שכל איבר זוגי נעלה למעלה אנחנו יודעים בוודאות שיש לנו $log(n)$ קומות או במקרה של נתוני השאלה $k$ קומות. __נשים לב, שבכל קומה הקצוות הם המצביעים ל $\pm{\infty}$__. 
 כיוון שהמבנה נתונים ממויין נוכל להכניס האיברים לפי האלגוריתם הבא:
 * יצירת רשימה מקושרת עם מצביע להתחלה ולסוף, בגודל $logn=k$ של התחיליות של הרשימות מקושרות ריקות כייצוג של הקומות (כאשר האיבר במקום ה0 הוא הקומה ה0).
 *  נבצע הכנסה של כל האיברים לרשימה מקושרת בקומה ה0, בכנ״ל.
 * כל פעם שנגיע לקומה $i$ (מצביעים לתחילת הקומה) נחזיק מצביע לתחילת הקומה $i-1$ ונרוץ על האיברים במקומות הזוגיים , כל איבר זוגי שיצא נחבר לקומה ה $i$ . נחזיק את המצביעים באופן דו כיווני לשני הצירים, כלומר נוכל לרוץ בכל קומה ימינה ושמאלה ובין הקומות , למעלה למטה.
 * ככה נמשיך עד הקומה ה $k$.

סך הכל קיבלנו $logn$ פעולות ועוד הסדרה החשבונית הבאה: 
$$\displaylines{T(n)=log(n)+n+\frac{1}{2}n+\frac{1}{4}n+\dots+1=\\log(n)+\sum\limits_{i=0}^{log(n)}{\frac{n}{2^{i}}}<2n\in{O(n)}}$$
### שאילתת חיפוש רגילה
נתחיל מהקומה הכי גבוהה שם יש איבר יחיד (אם היה יותר אז לא היינו בקומה הכי גבוהה.) אנחנו מצביעים על $-\infty$,  נבדוק האם הערך מימין יותר גדול או יותר קטן מהמספר שאנחנו מחפשים (כמובן שאם שווה , סיימנו נרד למטה בקומות על לקומה ה0 ונחזיר את המצביע).
אם הערך מימין גדול יותר : נרד למטה לקומה התחתונה ונבצע את אותה בדיקה 
אם הערך מימין קטן יותר : נעבור להצביע עליו בקומה שאנחנו נמצאים בה ושוב נבדוק את האיבר מימין 
__טענת עזר- בכל קומה נצטרך לזוז ימינה לכל היותר פעם אחת, לפני שנרד למטה בעץ או שנמצא את האיבר שלנו.__
בכל קומה מהעליונה לתחתונה כמות האיברים גדלה פי 2 והסדר בכל קומה ממויין. כלומר בכל קומה למספר שאנחנו המחפשים תמיד יהיו שתי טווחים שנצטרך לבדוק באיזה מהם הוא נמצא. כלומר ההחלטה של האם לרדת בקומות תלוי בקבוע (במקרה שהקומות עולות כל איבר זוגי). 

ככה נחזור על האלגוריתם עד הגעה לקומה התחתונה כפי שדיברנו בתרגול , אם הגענו לקומה התחתונה האיבר שנחפש תמיד יהיה האיבר הבא ברשימה.

זמן הריצה :
$$O(\log(n)+1)=O(\log(n))$$ __נשים לב , אם היינו מתחילים מהקומה ה $t$  אז זמן הריצה היה $O(t)$.

### חיפוש אצבע 
מתחילים מהמצביע לקודקוד $x_{i}$ כאשר אנחנו יודעים בוודאות ש $x_{j}$ (האיבר אותו אנחנו מחפשים) גדול יותר. נשים לב שהפתרון הנאיבי היה פשוט לרוץ 
$j-i$ פעמים ולמצוא את האיבר כי אנחנו יודעים שהוא ממויין . נעזר בפתרון הנאיבי כדי להוכיח את זמן הריצה של הפתרון שלנו. כעת, במקום לרוץ באופן איטרטיבי נבצע את האלגוריתם הבא :

כל עוד האיבר שאני מצביע עליו קטן מהאיבר אותו אני מחפש :
אם אפשר לעלות קומה, נעלה, אחרת נזוז (כפי שהוכחנו נזוז בקבוע צעד אחד ימינה) ונבדוק האם הוא האיבר כעת שווה לאיבר אותו אנחנו המחפשים. אם כן סיימנו אחרת אם הוא קטן נעלה קומה. 

כך נמשיך עד שנגיע לאיבר השווה לאיבר אותו אנחנו מחפשים או גדול יותר, במידה והגענו לאיבר אותו אנחנו מחפשים , נרד בקומות עד לקומה ה0 ונחזיר את המצביע כדרוש.

אחרת הגענו לאיבר שיותר גדול מהאיבר אותו אנחנו מחפשים ונבצע חיפוש רגיל לפי האלגוריתם המתואר למעלה.

__נחשב את זמן הריצה :__

אנחנו יודעים שהפתרון הנאיבי הוא $O(j-i)$ אינטואיטיבית עלייה בקומות אמורה להקטין את כמות הפעולות הללו. נראה איך 

במקרה הכי גרוע של האלגוריתם, עלינו $t$ קומות כדי להגיע לאיבר גדול יותר ממה שאנחנו מחפשים וביצענו חיפוש רגיל שדורש מאיתנו לרדת $t$ קומות, סה״כ $2t$ .
בהכרח יתקיים שהמרחק (ביחס לקומה ה0) בין שני איברים סמוכים בקומה ה$t$ יהיה $2^t$. ובהכרח יתקיים בגלל שאנחנו כל עלייה בקומה מצמצים את הפער בין האינדקס $i$ ל $j$ (כי כל הזמן מתקדמים ימינה כדי לעלות קומה): 
$$j-iֿ\geq2^{t}$$
כעת : 
$$2t +O(1) = 2{\log2^t}+O(1)\leq{2log(j-i)+O(1)}\in{O(log(j-i))}$$
__כדרוש__.

![[Pasted image 20220524235425.png]]
נוכיח באינדוקצייה על גובה העץ :
### בסיס 
$h=-1$ : זהו העץ הריק כלומר הרשימה ריקה . (אין מה להדפיס).
$h=0$ : עץ עם קודקוד יחיד לכן ממויין 

### צעד 
נניח עבור כל  עץ בגובה $k\leq n$ ונוכיח עבור עץ בגובה $n+1$ 

נזכר באלגוריתם של $inorder$
```ad-Code
```cpp
void inorderTraverse(node* root){ 
 if(root!=NULL) {
	 inorderTraverse(root->left)
	 print(root.value)
	 inorderTraverse(root->right)
 }

}
```
לפי האלגוריתם הולכים בכל צומת לעץ השמאלי לאחר מכן מדפיסים את הקודקוד של הצומת ולבסוף הולכים לעץ הימני . נזכיר שבעץ חיפוש בינארי כל התת עץ השמאלי מכיל איברים הקטנים יותר מהקודקוד וכל התת עץ הימני מכיל איברים הגדולים יותר מהקודקוד . 

כעת עבור עץ בגובה $n+1$ נקבל לפי הקוד הנ״ל : שנלך לעץ השמאלי בגובה $\leq n$ ועליו נעשה $inorder$ שלפי צעד האינדוקצייה ידפיס לנו את האיברים בסדר ממויין שלפי ההגדרה של עץ חיפוש בינארי כולם יותר קטנים מהקודקוד ה $n+1$ . לאחר מכן נדפיס את הקודקוד ולבסוף נלך לתת העץ הימני בגובה $\leq n$ שלפי הצעד האינדוקצייה הוא גם יודפס ממויין ב $inorder$ ולפי הגדרה של עץ חיפוש בינארי כל איבריו גדולים מ הקודקוד ה $n+1$ .

סך הכל נקבל הדפסה של כל האיברים בסדר ממויין __כדרוש__.


![[Pasted image 20220525001649.png]]
מבנה הנתונים שלנו יהיה מבוסס עץ $AVL$ . בנוסף לנתונים המקורים ממבנה הנתונים הנ״ל כל קודקוד יחזיק שתי פרמטרים נוספים שהם סכום ערכיהם של כל תת העץ הימני ותת העץ השמאלי , נסמן את הפרמטרים הללו $rightSum$ ו $leftSum$ .

### הכנסת איבר 
לפי אלגוריתם הכנסה של עץ $AVL$ , נוסיף שתי פעולות קבועות חדשות :
בדיקה האם האיבר הנכנס יותר גדול מהקודקוד עליו אנחנו נמצאים , אם כן נוסיף את ערכו לערך $rightSum$ של אותו הקודקוד , אחרת נוסיף את ערכו ל $leftSum$. __נשים לב__ אם הגענו בתהליך ההוספה לקודקוד ריק, נאתחל לו את שני הפרמטרים ל$0$ ולאחר מכן נוסיף את הערך למקום המתאים כמתואר. מבצעים זאת באופן רקורסיבי לכל קודקוד שנגיע אליו.
פעולת הבדיקה ופעולת ההכנסה הן קבועות ב $O(1)$ ולכן לא פוגעות ביעילות ההכנסה המוכרת של עץ $AVL$ הלוא היא $O(logn)$ .

### הוצאת איבר 
כמו פעולת ההוצאה הרגילה בעץ $AVL$ , לאחר מציאת הערך המבוקש אותו נרצה להחסיר את ערכו מפרמטר הסכום המתאים מקודקודי האבא שלו. כיוון שאלגוריתם ההוצאה לא שובר את מבנה העץ נוכל להחסיר את הערכים לפני התיקונים ולאחר מכן לעשות את התיקונים הדרושים במקרה ופגענו במבנה העץ לפי אלגוריתם ההוצאה המוכר. הסרה מהסכום לפני התיקונים היא בזמן קבוע $O(1)$ ולכן לא משפיעה על יעילות הוצאת איבר המוכרת. סה״כ שמרנו על $O(logn)$ בסיבוכיות זמן ריצה.

### חיפוש 
כמו חיפוש בכל עץ בינארי רגיל, זמן החיפוש חסום בגובה העץ.

### סכום תחום range(x,y,root,sum)
נשלח לפונקצייה סכום התחלתי שערכו 0, נתחיל מהקודקוד ונבדוק את שני בניו, אם הקודקוד קטן מ x הטווח נלך לתת העץ הימני בלבד , ואם הוא גדול מ y נלך לתת העץ השמאלי בלבד. במקרה ששני התנאים לא מתקיימים נכנס לשני תתי העצים ונבצע את האלגוריתם שיתואר למטה עבור מקרה שבוא אנחנו באיבר בטווח.
נמשיך את הפעולה הזאת באופן ריקורסיבי, נחלק בכל קודקוד שנעצור למקרים הבאים- 

* __הגענו ל $x$ :__ במצב זה נכניס את x ואת סכום תת העץ הימני ל sum, במצב זה ייתכן שהכנסנו ערכים הגדולים מ y ולכן נרצה לתקן, נתקן על ידי הפעלת אלגוריתם החיפוש על $y$ עבור תת העץ הימני המדובר עם התוספת הבאה: כל פעם שנעבור בקודקוד שיותר גדול מ$y$ נוריד sum את סכום ערכי כל תת העץ הימני כולל הקודקוד . אם הגענו ל $y$ עצמו שוב נוריד את סכום ערכי תת העץ הימני ללא הקודקוד. אם לא הגענו לקודקוד המקיים את התנאים נמשיך באלגוריתם החיפוש. לאחר סיום החיפוש נחזיר את הערך $sum$ וסיימנו.

 * __הגענו ל $y$__ : אלגוריתם הזהה ל מצב שבו הגענו ל $x$ ההבדל הוא שנוסיף ל $sum$ את ערכי כל תת העץ השמאלי ונחסר את סכומי תתי העץ שמאליים עבור קודקודים קטנים או שווים ל $x$. בסוף הריצה הזאת גם נחזיר את $sum$ וסיימנו.

 * __הגענו ל $t\in[x,y]$__: נכניס ל $sum$ את סכומי הערכים $rightSum$ ו $leftSum$ ונריץ את הפעולה פעם נוספת על קודקוד תת העץ הימני וקודקוד תת העץ השמאלי, במטרה להחסיר את הערכים שמחוץ לטווח נפעיל על כל קודקוד את אלגוריתם החיפוש המתאור הנ״ל בהתאם לערכו (אם הוא גדול מ y אז נחפש את x כמו במקרה הראשון, אחרת נחפש את y ונפעיל את האלגוריתם המתואר בסעיף השני).

נשים לב שאלגוריתם הפעולה הינו חיפוש של שני ערכים בעץ, לכן חסומה כמו אלגוריתם החיפוש שלנו בגובה העץ (פעולת הוספה והחסרה הינן קבועות). לכן סך הכל גם החזרת הסכום חסומה בגובה העץ __כדרוש__.