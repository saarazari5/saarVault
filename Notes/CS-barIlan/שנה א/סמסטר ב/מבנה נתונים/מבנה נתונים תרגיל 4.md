![[Pasted image 20220524201117.png]]
הפתרון הנאיבי יהיה לחשב עבור כל מלבן את השטח הנוצר מהגובה שלו ביחס לשכנים שלו וככה להגיע לפתרון, עם זאת , הדרך אינה יעילה כל כך $O(n^2)$ , אך נשתמש בה כבסיס לייעול כיוון שאנחנו יודעים באמצעות האלגוריתם ה brute force הזה, את הדרך הפעולה הרצוייה.

השאלה המתבקשת לייעול האלגוריתם הינה ״האם ניתן למצוא בזמן יעיל יותר מהוא המלבן הבא מימין והבא משמאל __שיותר נמוכים__ ביחס למלבן שאני נמצא בו.



![[Pasted image 20220524205623.png]]
### בנייה  
נתחיל מבניית המבנה , נרצה להעלות את האיברים במבנה שלנו, באופן שיקיים את הנתונים, כיוון שאנחנו מקבלים ככקלט איברים ממויינים ויתרה מכך את גודל הסדרה $n$ ואף אנחנו יודעים ש $n$ הוא חזקה של $2$ נסמן $n=2^k$ .  הבסיס למבנה יהיה הרשימה הממויינת שלנו. נבנה רשימה מקושרת חדשה עם $\pm{\infty}$ בקצוות. כל איבר זוגי עולה למעלה לקומה חדשה. כך נבצע בכל קומה בעת בניית המבנה, כלומר, בכל קומה נעבור על האיברים הזוגיים (כאשר מתייחסים לכל קומה כרשימה בפני עצמה) ונעלה אותם לקומה חדשה כך עד שנשאר עם איבר אחד בקומה הגבוהה ביותר.
כעת נשים לב שהמערך בקלט ממויין וכיוון שכל איבר זוגי נעלה למעלה אנחנו יודעים בוודאות שיש לנו $log(n)$ קומות או במקרה של נתוני השאלה $k$ קומות. __נשים לב, שבכל קומה הקצוות הם המצביעים ל $\pm{\infty}$__. 
 כיוון שהמבנה נתונים ממויין נוכל להכניס האיברים לפי האלגוריתם הבא:
 * יצירת רשימה מקושרת עם מצביע להתחלה ולסוף, בגודל $logn=k$ של התחיליות של הרשימות מקושרות ריקות כייצוג של הקומות (כאשר האיבר במקום ה0 הוא הקומה ה0).
 *  נבצע הכנסה של כל האיברים לרשימה מקושרת בקומה ה0, בכנ״ל.
 * כל פעם שנגיע לקומה $i$ (מצביעים לתחילת הקומה) נחזיק מצביע לתחילת הקומה $i-1$ ונרוץ על האיברים במקומות הזוגיים , כל איבר זוגי שיצא נחבר לקומה ה $i$ . נחזיק את המצביעים באופן דו כיווני לשני הצירים, כלומר נוכל לרוץ בכל קומה ימינה ושמאלה ובין הקומות , למעלה למטה.
 * ככה נמשיך עד הקומה ה $k$.

סך הכל קיבלנו $logn$ פעולות ועוד הסדרה החשבונית הבאה: 
$$\displaylines{T(n)=log(n)+n+\frac{1}{2}n+\frac{1}{4}n+\dots+1=\\log(n)+\sum\limits_{i=0}^{log(n)}{\frac{n}{2^{i}}}<2n\in{O(n)}}$$
### שאילתת חיפוש רגילה
נתחיל מהקומה הכי גבוהה שם יש איבר יחיד (אם היה יותר אז לא היינו בקומה הכי גבוהה.) אנחנו מצביעים על $-\infty$,  נבדוק האם הערך מימין יותר גדול או יותר קטן מהמספר שאנחנו מחפשים (כמובן שאם שווה , סיימנו נרד למטה בקומות על לקומה ה0 ונחזיר את המצביע).
אם הערך מימין גדול יותר : נרד למטה לקומה התחתונה ונבצע את אותה בדיקה 
אם הערך מימין קטן יותר : נעבור להצביע עליו בקומה שאנחנו נמצאים בה ושוב נבדוק את האיבר מימין 
__טענת עזר- בכל קומה נצטרך לזוז ימינה לכל היותר פעם אחת, לפני שנרד למטה בעץ או שנמצא את האיבר שלנו.__
בכל קומה מהעליונה לתחתונה כמות האיברים גדלה פי 2 והסדר בכל קומה ממויין. כלומר בכל קומה למספר שאנחנו המחפשים תמיד יהיו שתי טווחים שנצטרך לבדוק באיזה מהם הוא נמצא. כלומר ההחלטה של האם לרדת בקומות תלוי בקבוע (במקרה שהקומות עולות כל איבר זוגי). 

ככה נחזור על האלגוריתם עד הגעה לקומה התחתונה כפי שדיברנו בתרגול , אם הגענו לקומה התחתונה האיבר שנחפש תמיד יהיה האיבר הבא ברשימה.

זמן הריצה :
$$O(\log(n)+1)=O(\log(n))$$ __נשים לב , אם היינו מתחילים מהקומה ה $t$  אז זמן הריצה היה $O(t)$.

### חיפוש אצבע 
מתחילים מהמצביע לקודקוד $x_{i}$ כאשר אנחנו יודעים בוודאות ש $x_{j}$ (האיבר אותו אנחנו מחפשים) גדול יותר. נשים לב שהפתרון הנאיבי היה פשוט לרוץ 
$j-i$ פעמים ולמצוא את האיבר כי אנחנו יודעים שהוא ממויין . נעזר בפתרון הנאיבי כדי להוכיח את זמן הריצה של הפתרון שלנו. כעת, במקום לרוץ באופן איטרטיבי נבצע את האלגוריתם הבא :

כל עוד האיבר שאני מצביע עליו קטן מהאיבר אותו אני מחפש :
אם אפשר לעלות קומה, נעלה, אחרת נזוז (כפי שהוכחנו נזוז בקבוע צעד אחד ימינה) ונבדוק האם הוא האיבר כעת שווה לאיבר אותו אנחנו המחפשים. אם כן סיימנו אחרת אם הוא קטן נעלה קומה. 

כך נמשיך עד שנגיע לאיבר השווה לאיבר אותו אנחנו מחפשים או גדול יותר, במידה והגענו לאיבר אותו אנחנו מחפשים , נרד בקומות עד לקומה ה0 ונחזיר את המצביע כדרוש.

אחרת הגענו לאיבר שיותר גדול מהאיבר אותו אנחנו מחפשים ונבצע חיפוש רגיל לפי האלגוריתם המתואר למעלה.

__נחשב את זמן הריצה :__

אנחנו יודעים שהפתרון הנאיבי הוא $O(j-i)$ אינטואיטיבית עלייה בקומות אמורה להקטין את כמות הפעולות הללו. נראה איך 

במקרה הכי גרוע של האלגוריתם, עלינו $t$ קומות כדי להגיע לאיבר גדול יותר ממה שאנחנו מחפשים וביצענו חיפוש רגיל שדורש מאיתנו לרדת $t$ קומות, סה״כ $2t$ .
בהכרח יתקיים שהמרחק (ביחס לקומה ה0) בין שני איברים סמוכים בקומה ה$t$ יהיה $2^t$. ובהכרח יתקיים בגלל שאנחנו כל עלייה בקומה מצמצים את הפער בין האינדקס $i$ ל $j$ (כי כל הזמן מתקדמים ימינה כדי לעלות קומה): 
$$j-iֿ\geq2^{t}$$
כעת : 
$$2t +O(1) = 2{\log2^t}+O(1)\leq{2log(j-i)+O(1)}\in{O(log(j-i))}$$

__כדרוש__.

```ad-Code
```cpp
int* fingerSearch(){


}

```

![[Pasted image 20220524235425.png]]
נוכיח באינדוקצייה על גובה העץ :
### בסיס 
$h=-1$ : זהו העץ הריק כלומר הרשימה ריקה . (אין מה להדפיס).
$h=0$ : עץ עם קודקוד יחיד לכן ממויין 

### צעד 
נניח עבור כל  עץ בגובה $k\leq n$ ונוכיח עבור עץ בגובה $n+1$ 

נזכר באלגוריתם של $inorder$
```ad-Code
```cpp
void inorderTraverse(node* root){ 
 if(root!=NULL) {
	 inorderTraverse(root->left)
	 print(root.value)
	 inorderTraverse(root->right)
 }

}
```
לפי האלגוריתם הולכים בכל צומת לעץ השמאלי לאחר מכן מדפיסים את הקודקוד של הצומת ולבסוף הולכים לעץ הימני . נזכיר שבעץ חיפוש בינארי כל התת עץ השמאלי מכיל איברים הקטנים יותר מהקודקוד וכל התת עץ הימני מכיל איברים הגדולים יותר מהקודקוד . 

כעת עבור עץ בגובה $n+1$ נקבל לפי הקוד הנ״ל : שנלך לעץ השמאלי בגובה $\leq n$ ועליו נעשה $inorder$ שלפי צעד האינדוקצייה ידפיס לנו את האיברים בסדר ממויין שלפי ההגדרה של עץ חיפוש בינארי כולם יותר קטנים מהקודקוד ה $n+1$ . לאחר מכן נדפיס את הקודקוד ולבסוף נלך לתת העץ הימני בגובה $\leq n$ שלפי הצעד האינדוקצייה הוא גם יודפס ממויין ב $inorder$ ולפי הגדרה של עץ חיפוש בינארי כל איבריו גדולים מ הקודקוד ה $n+1$ .

סך הכל נקבל הדפסה של כל האיברים בסדר ממויין __כדרוש__.