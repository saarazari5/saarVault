__סער אזערי__ 

![[Pasted image 20220607194018.png]]
__בנייה__ -
בעת קליטת המערך בגודל $n$ נסמנו $A[n]$ נבצע את הפעולה הבאה, נפעיל $quickselect$ באופן ריקורסיבי על איבר החציון של המערך באופן הבא:
* מציאת איבר החציון
* להשתמש בו כ $pivot$ כדי לסדר את כל האיבר הגדולים ממנו בצד ימין של המערך והקטנים ממנו בצד שמאל
* הפעלת $quickselect$ על החצי השמאלי של אותו מערך כאשר תנאי העצירה הוא תת מערך בגודל $1$ . נסמן כל איבר חציון עם flag כדי שנדע שאכן הוא איבר חציון.  

הוכחת סיבוכיות זמן ריצה : 
$$T(n)=T(\frac{n}{2})+O(n)\underset{\text{master theorem}}\in{O(n)}$$
הראנו שאלגוריתם $quickselect$ מתבצע ב $O(n)$ וסידור האיברים כשאיבר החציון הוא $pivot$  גם לוקחת $O(n)$ סך הכל עם האלגוריתם הריקורסיבי נקבל את הנ״ל.

 __שאילתה__ - 
ניעזר באלגוריתם הדטרמיניסטי למציאת איבר $k$ בגודלו כפי שלמדנו בתרגול $quick select$ באופן הבא: 

* $k=\frac{n}{2}$ - נחזיר פשוט את איבר החציון שאנחנו יודעים שהוא במיקום המתאים לו..
* $k>\frac{n}{2}$ -כיוון שסידרנו את האיברים , האיבר ה $k$ בגודלו נמצא בוודאות בצד ימין של המערך, האיבר בוודאות נמצא בחצי הימני ונוכל להפעיל את האלגוריתם $quickselect$ על חציו הימני של המערך על אינדקס $k-\frac{1}{2}n$ .
* $k<\frac{n}{2}$ כעת, האיבר אותו אנחנו מחפשים נמצא בחציו השמאלי של המערך והוא נמצא בין שני חציונים ( או שהוא חציון בעצמו), נלך ל $A[k]$ , אם הוא מסומן כחציון , נחזיר אותו כי אנחנו יודעים שכל החציונים נמצאים במקומם , אחרת נלך לאינדקס הראשון משמאל ומימין שאיבריהם הם חציונים נסמנם ב $l,r$ בהתאמה. הסיבה לכך היא  שאת כל צד שמאל של המערך סידרנו לפי החציונים באופן כזה שאם אינדקס גדול מחציון מסויים וקטן מחציון אחד אז האיבר המתאים לאותו אינדקס חייב להיות בין שני החציונים האלה.
ברגע שסימנו את $l,r$ נבצע $quickselect$ על האיבר $k-l$ בתת מערך $A[l...r]$. האיבר שייבחר זה האיבר הדרוש.

__הוכחת נוכחות__ -
עבור $k\geq{\frac{n}{2}}$ הנכונות נובעת ישירות מבניית המבנה ומההוכחות שעשינו על $quickselect$ בתרגול.
עבור $k<\frac{n}{2}$ אנחנו יודעים שלכל איבר חציון $i$ יתקיים שהאיברים שגדולים מאיבר חציון זה יהיו מימין לאיבר והאיברים שיהיו משמאל יהיו קטנים יותר בגלל שעשינו $partioning$  בעת הבנייה, לכן לא משנה מהו $k$, הוא בהכרח יימצא בין שני החציונים או שהוא יהיה חציון בעצמו ובהכרח יתקיים שהאיבר ה$k$ בגודלו יהיה בין 2 החציונים האלה.

__סיבוכיות__- 
אם $k=\frac{n}{2}$ אז השליפה תקרה ב $O(1)$ ,
אם $k>\frac{n}{2}$ אז מבצעים את אלגוריתם $quickselect$ על חציו הימני של המערך  $O(\frac{n}{2})$ וכיוון ש $k$ גדול מ$\frac{n}{2}$ הוא בהכרח חסום גם ב $O(k)$ .
אם $k<\frac{n}{2}$ - אם האינדקס הוא חציון $O(1)$ אחרת אחרת הוא נמצא בין שתי אינדקסים שהם בהכרח חזקות של $2$ כי כל פעם מוצאים את החציון על מערך בגודל $n\over{2^{i}}$ , כלומר, $k$ תמיד יהיה גדול יותר מהמערך המצומצם שאנחנו עובדים איתו אחרת $k$ היה שייך לתת מערך אחר בין שתי חציונים אחרים. סך הכל גם זמן הריצה כאן הוא $O(k)$.

![[Pasted image 20220608140136.png]]

נשתמש באלגוריתם מורחב של אלגוריתם מוכר הנקרא [Boyer–Moore majority vote algorithm](https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm) . בגלל שמבקשים את מספר האלמנטים שיהיו יותר מ $\frac{n}{3}$ הרי שיכולים להיות רק בכל המערך שיקיימו את התנאים האלה , לכן האלגוריתם יעבוד באופן הבא: 
נפעיל את האלגוריתם הנ״ל על שתי איברים כך שנדע בוודאות שלא נקבל את אותה התוצאה בלי לקבל את אותה המערך , נעשה זאת על ידי החזקה של 4 משתנים 
candidate1 and counter1 ובנוסף candidate2 and counter2.

* נרוץ על הקלט שלנו, אם $candidate1=A[i]$ אז $counter1++$  אחרת, נפעיל את אותו תנאי בידיוק על $candidate2$ .
* אם $counter1=0$ אז נבצע השמה $candidate1=A[i]$ ובאותו אופן עבור $counter2$ .
* אחרת יתקיים ש $A[i]$ שונה משתי המועמדים, ונקטין את הסופרים שלהם ב$1$ .

האלגוריתם הנ״ל מבטיח שבסוף האיטרציה $candidate1$ ו $candidate2$ יהיו שתי האיברים שמופיעים הכי הרבה פעמים במהלך האיטרצייה. (הוכחת נכונות בהמשך).

כעת, נאתחל את הסופרים ל0, נרוץ על המערך שוב פעם ונבדוק אם $A[i]=candidate1$ אז נעלה את הסופר המתאים ב$1$ וכנ״ל לגבי $candidate2$ .

בסיום האיטרצייה השניה נבדוק האם $counter1$ יותר גדול מ $\frac{1}{3}n$  וכנ״ל לגבי $counter2$ , אם כן נחזיר את הערכים המתאימים.

__זמן ריצה__:
רצנו על הלולאה פעמיים באופן ליניארי ולכן רצים $2n$ פעמים שזה כמובן חסום ב $O(n)$ .מבחינת סיבוכיות מקום הוספנו 4 משתנים קבועים ולכן $O(1)$ .

__הוכחת נכונות__ :
האלגוריתם תמיד ימצא את שני האיברים עם מספר האיברים הגדול ביותר, כיוון שהשמה יכולה להיות למועמד אחד בלבד בכל איטרצייה (תנאי בסגנון else if) וכל פעם שמוצאים מספר ששונה משני המועמדים מורידים את הcounter ולא מבצעים השמה חדשה, כלומר אם יש מספר $x$  שמופיע יותר פעמים ממספר $y$ בסופו של דבר הוא יוביל לזה שהספירה עבור $y$ תהיה $0$. חשוב לציין שאנחנו לא יודעים כמה פעמים כל מספר הופיע בסוף האיטרצייה אלא רק מי מופיע הכי הרבה, אם נרצה לחשב מספר מדוייק נצטרך לרוץ שוב כפי שעשינו. 

```ad-Code
```java
	
	static void findMajority(int arr[], int n)
	{
		int count1 = 0, count2 = 0;

		int candidate1 = 0;
		int candidate2 = 0;
	
		for (int i = 0; i < n; i++) {
	
			if (candidate1 == arr[i])
				count1++;

			else if (second == arr[i])
				count2++;
		
			else if (count1 == 0) {
				count1++;
				candidate1 = arr[i];
			}
	
			else if (count2 == 0) {
				count2++;
				candidate2 = arr[i];
			}
			
			else {
				count1--;
				count2--;
			}
		}
	
		count1 = 0;
		count2 = 0;

		for (int i = 0; i < n; i++) {
			if (arr[i] == candidate1)
				count1++;
	
			else if (arr[i] == candidate2)
				count2++;
		}
	
		if (count1 > n / 3){
			\\ candidate1 is valid
		}
		if (count2 > n / 3){
		    \\ candidate2 is valid
		}
		\\no elements fit the condition
	}


```

![[Pasted image 20220608181806.png]]

נגדיר את המבנה כ מעטפת ל עץ $AVL$ המקבל כקלט מספר $m$ ושומרת אותו , מספר זה יסמל את החסם העליון של המספרים הטבעיים שאנחנו חוסמים. זה כמובן אתחול ב $O(1)$.

כעת, בעת בניית המבנה בהינתן קבוצה $S$ נבנה מערך לא ממויין בגודל $n$ שזה מספר איברי הקבוצה, ועל כל איבר נבצע המרה למספר בבסיס $n$ (הסבר ללמה עשינו זאת בהמשך). בגלל שידוע שכל איבר בקבוצה הוא מספר טבעי ולכן חסום כ$integer$ פעולת ההמרה תהיה ב $O(1)$ לכל מספר סך הכל $O(n)$ פעולות.

כעת כשכל האיברים מומרים לבסיס $n$ ננצל את החסם שקיבלנו על גודל הקבוצה :
$$\sqrt{m}<n<m\leftrightarrow m<n^{2}<m^{2}$$
כלומר אנחנו יודעים שיתקיים ש $m\leq{n^{2}-1}$ ולכן בבסיס $n$ זה אומר שכל האיברים יהיו לכל היותר 2 ספרות בבסיס $n$ , אם היה מספר $m$ שבו 3 ספרות, אז בבסיס $n$ היה ניתן לבטא את ספרות באופן הבא בבסיס $10$ : 
$$a_{3}\cdot n^{2} + a_{2}\cdot n+a_{1} > n^{2}$$
__בסתירה__ .

כעת נבצע מיון [[radix sort]] על איברי המערך , כיוון שאנחנו יודעים שיש לכל היותר 2 ספרות , יתקיים ש $d=2$ כלומר, מספר העמודות שווה למספר הספרות המקסימלי , ו $R=n-1$ כי במיון ספרות, המערך הקבוע יהיה בגודל הספרה הכי גדולה באותו בסיס שבמקרה זה , $n-1$ . נקבל שזמן הריצה של המיון הינו 
$$O(2(n-1+n))=O(4n-1)=O(n)$$
כעת יש לנו מערך ממויין וכל שנשאר לעשות הוא להכניס את לעץ $AVL$ שלנו. הוכחנו שהכנסת מערך ממויין באופן ריקורסיבי לוקחת גם היא $O(n)$ לכן סך הכל זמן הריצה של הבנייה שלנו הוא ליניארי לכמות האיברים בקבוצה $S$.

__כל שאר הפעולות הוכחנו כבר שעבור עץ   AVL הן חסומות בגובה העץ שהוא logn, רק צריך עבור פעולת ההכנסה להוסיף בדיקה האם הוא בטווח המתאים שזאת פעולה קבועה__ __כדרוש__. 

__הוכחת נכונות__ 
כיוון שביצענו אך ורק פעולות שאת נכונותם הוכחנו בעבר, ושאת זמני הריצה שלהן פירטנו למעלה, בניית המבנה תעבוד כדרוש. כמו כן כל שאר הפעולות הן פעולות סטנדרטיות שמבצעים על כל עץ $AVL$ סטנדרטי. 

![[Pasted image 20220608205620.png]]
__א__. זמן ריצה במקרה הגרוע יהיה $O(n^{2})$ לדוגמה, ניקח מערך בגודל $\frac{n}{2}+1$ שאיבר אחד באינדקס $i$ יהיה עם $\frac{n}{2}$ ספרות ובשאר האינדקסים תהיה ספרה אחת בלבד.
סכום הספרות יהיה $n$.
במצב זה זמן הריצה יהיה תלוי בחסם שלנו ב $count sort$ עבור עמודה בודדת , שזה 9 ועוד גודל המערך שזה $\frac{n}{2}$ כפול מספר הספרות הכי גדול שזה גם $\frac{n}{2}$.
סך הכל סיבוכיות המיון במקרה זה תהיה :
$$O(\frac{n}{2}(\frac{n}{2}+9))\in O(n^{2})$$ __ב__. ניעזר בעובדה שישנו חסם עליון למספר הספרות והוא $n$ . העובדה שיש חסם עליון למספר הספרות והנתון שסכום הספרות של כל האיברים הוא $n$ גם כן, מעידה על כך שגודל המערך הוא לכל היותר $n$ ($n$ איברים עם ספרה אחת בכל תא). עכשיו כשאנחנו מבינים זאת, האינטואצייה אומרת שיש לנו חסם שלפיו נוכל למיין את המספרים לפי כמות הספרות. 
* עבור כל איבר במערך נצמיד לו ערך שמכיל את כמות הספרות שלו .
* נבצע מיון מנייה על מספר הספרות , מיון זה הוא יציב ולכן האיבר הראשון שיש בו את מספר הספרות הנמוך ביותר במערך המקורי יהיה האיבר הראשון וכן הלאה..
* כעת נבצע מיון [[radix sort]] על תתי המערכים שספרותיהם באותו אורך. בסיום המערך יהיה ממויין.


__נכונות__ 
כפי שהסברנו מספר הספרות חסום ב $n$ כמובן שאם מספר הספרות עבור מספר בודד הוא $n$ אז יהיה איבר בודד במערך לפי נתוני השאלה, בכל מקרה מיון המנייה כפי שהוכחנו בעבר יסדר את האיברים במיון יציב לפי סדר הספרות. לאחר מכן מיון $radix$ על תתי המערכים בעלי מספרים עם אותם ספרות יסדר פנימית באופן יציב את המספרים עבור כל תת מערך. כיוון שהוכחנו כבר את נכונות שתי שיטות המיון באופן כללי השיטה הזאת תעבוד על המערך שלנו מעצם השימוש בשיטות מיון אלו. __כדרוש__.

__זמן ריצה__ 
* __מדידת הספרות__ - תלוי במספר הספרות של כל מספר בודד, סך הכל אנחנו יודעים שסכום הספרות הוא $n$ ולכן $n$ פעולות לכל איברי המערך.
* __מיון המנייה__ - החסם הוא $n$ וגודל המערך הוא $k$ שחסום על ידי $n$ ולכן סך הכל $O(n+k) = O(k)$ .
* __מיון הבסיס__ - 

נגדיר ב $A_{i}$ את תת המערך של הספרות בעלי $i$ ספרות. לכל קבוצה כזאת נסמן את גודל הקבוצה ב$c_{i}$ ואת סכום הספרות כ $n_{i}$  ויתקיים :
$$\forall_{i\in[n]}:radix_{i}=O(i(c_{i}+10))=O(\frac{n_{i}}{c_{i}}(c_{i}+10))\in O(n_{i})$$
המעבר השני נובע כי בכל תת קבוצה יש את אותו מספר ספרות ולכן $i$ ניתן לבטאו כחלוקה של סכום הספרות הכולל בגודל תת קבוצה.

סך הכל אנחנו סוכמים את כגודל תתי הקבוצות פעולה שחסומה בחסם עליון על ידי סכום הספרות של של כל תת קבוצה כזאת כלומר : זמן הריצה הכולל חסום בקבוע על ידי $O(n)$ __כדרוש__.