
1)

 ![[Pasted image 20220505203038.png]]

![[Pasted image 20220505203102.png]]

בהנחה וכל הביטים דולקים בהתחלה נוכל לכבות את הביט הראשון ולאחר מכן פשוט לרוץ על האיברים בכיוון אחד לבחירתנו עד להגעת אותו הביט הכבוי.

זמן ריצה $O(n)$ :
```ad-Code
```cpp
int length(Train* p, int counter) {
	counter = 0;
	// toggle the light
	p.toggle()
	p.next()
	counter++;
	while(p.next().light.isOn() != false) {
		p.next()
		counter++;
	}
	return counter;
}
```


![[Pasted image 20220505204420.png]]

נתחיל מ $counter = 0$ , כעת , נרוץ עם כיוון השעון על הרכבת עד אשר יתקיים $counter=l\in\mathbb{N}$
במהלך הריצה לנקודה הזאת נדליק את הנורה הראשונה ונכבה את כל הנורות שלאחר מכן. 
נחזור בחזרה $l$ צעדים כאשר כל צעד אחורה נקטין בחזרה את counter.
אם כאשר $counter = 0$ יתקיים שהנורית הראשונה עדיין דולקת נחזיר false . אחרת נחזיר true. 

סיבוכיות זמן ריצה : 
$$T(n)=2\cdot l + O(1)\in O(l)$$

```ad-Code
```cpp
int isLarger(Train* train ,int l) { 
 int counter = 0;
 train.toggleOn();
 train.next();
 counter++;
 
 while(counter<=l){
	train.toggleOff(); 
    train.next();
    counter++;
 }

 while(counter>=0){
	train.prev()
	counter --; 	 
 } 

 if(train.isOn()){
	 return 1;
 }else {
   return 0; 
 }
}
```



![[Pasted image 20220505205843.png]]
בדומה לאלגוריתם הקודם , נתחיל מ counter = 0 ונדליק את הנורית הראשונה.
כל פעם שנתקדם נעלה את __counter__ ב 1 , נכבה את הנורית שעליה עמדנו ולאחר שהתקדמנו יותר ממה שהגענו פעם שעברה, (שמירה משתנה מקומי __previousCounter__) נחזור אחורה ונקטין את counter בהתאם עד שערכו יהיה 0.  תתואר על ידי הסדרה החשבונית הבאה : כאשר $a_{n}$ מייצג את הצעד ה $n$ ויתקיים $a_{n+1}=a_{n}+1$. כיוון שנרצה כל ריצה קדומה לרוץ צעד אחד יותר מהריצה הקודמת. 
בכל פעם ש ערכו של counter יהיה 0 נבדוק האם הנורית שהדלקנו בהתחלה עדיין דולקת, אם כן נמשיך להתקדם קדימה , אחרת נחזיר את ערכו של previousCounter שכן הוא ייצג את הערך האחרון שהגענו אליו לפני שחזרנו אחורה.

__סיבוכיות ריצה:__  נשים לב שבגלל שהולכים קדימה אחורה בהתאם לסדרה החשבונית שתיארנו, זה פשוט פעמיים סכומה
$$2\sum_{k=1}^{n}{k}=\frac{2n(n+1)}{2}=n^{2}-n\leq{n^2}\in{O(n^2)}$$
![[Pasted image 20220505213022.png]]

נסתכל על האינדקסים של הרכבת כמערך עולה ממש $A[1...n]$ וכיוון שהוא ממויין נוכל הלכה למעשה לבצע עליו ״__חיפוש בינארי__״ אבל אנחנו לא יודעים איזה מספר לחפש , נשתמש ב counter שלנו עבור זה: 

נתחיל מ counter = 1 
נפעיל את המתודה שכתבנו בסעיף ב על counter אם נקבל true אז נדע שאורך הרשימה קטן או שווה ל coutner . אחרת נקדם את counter בכפילות של 2 $counter=counter*2$ עד שנקבל true . 
ברגע שקיבלנו את הערך המבוקש מהמתודה של סעיף ב. אנחנו יודעים בוודאות שמספר הקרונות ברכבת שלנו קטן מ counter נוכל פשוט לרוץ אחורה מה קרון במיקום ה coutner עד הקרון הראשון (לפי האלגוריתם של סעיף ב הוא היחיד שנורתו תהיה דולקת בריצה אחורה מהאינדקס $l$ )  נספור כמה צעדים חזרנו אחורה עד הנורית הדולקת וזה האורך המבוקש.

סיבוכיות ריצה: 
כיוון שהאלגוריתם של סעיף ב הוא ליניארי בעצם אנחנו סוכמים את 2 בחזקת counter אך בגלל שcoutner גדל כל פעם והוא לא מספר קבוע זה יהיה סכום זה סדרה הנדסית מהצורה הבאה : 
$$\sum_{i=0}^{k}2^{i}=2^{k+1}-1$$
כאשר k הוא מספר הפעמים שהכפלנו את counter על לקבלת ערך true .

כעת , ידוע לנו שיתקיים $2^{k-1}\leq{n}\leq{2^k}$

כלומר יתקיים $2\cdot{2^{k-1}}<2\cdot{n}$  ועל כן : $2^{k}<2\cdot{n}$
ולכן מתקיים ש : 
$$2^{k+1}-1=2\cdot 2^{k} -1 < 2\cdot 2{n}-1=4n-1 $$
השלב השני כולל ריצה של $2^{k}$ צעדים ולאחר מכן חזרה אחורה עד הגודל המבוקש (עד הנורית הדולקת) כלומר $n$ צעדים.

לכן השלב השני יהיה זמן ריצה של 
$$2^{k}+n<2n+n=3n\in O(n)$$
וסה״כ : 
$$2^k+n+2^{k+1}-1<3n+4n-1=7n-1\in{O(n)}$$
__כדרוש.__ 


![[Pasted image 20220505224311.png]]

  ראשית , עבור זמן הבנייה נדרש : לבנות את המערך ולאחר מכן למיין אותו כפי שעשינו ב 2sum. ולכן זמן הריצה של הבנייה יהיה זהה $O(n\log{n})$ כאשר:
  * $n$ זה עבור יצירת המערך והכנסת האיברים לתוכו
  * $\log{n}$ עבור המיון.

כעת , ננתח את בעיית ה sum3  : 
בהינתן קלט $y$ נוכל להסתכל על הבעיה שלנו כבעיית 2sum אם נתבונן בה באופן הבא: 
$$\forall_{1\leq{i}\leq{n}}\ : \ 2sum(y-A[i])$$
בדרך זו נוכל על ידי שימוש באלגוריתם של 2sum  במשך n פעמים למצוא האם קים סכום משולש כדרוש. 

זמן ריצה :  כיוון שאנחנו מריצים את 2sum על כל איבר במערך הרי ש יתקיים $T(n)\in{O(n\cdot{f(n)})}$  כדרוש.



![[Pasted image 20220506213659.png]]

בישביל כל ארבעת הפעולות הראשונות מספיק להשתמש במחסנית הרגילה ויכולותיה : push(),pop(),isEmpty (עם מעט שינויים שיתמכו באיבר מינימום אך יעילותן לא תשתנה)

=={$isEmpty$ -פשוט נשמור משתנה שסופר הוצאות והכנסות מהמחסנית.}==

בישביל פעולת המינימום נגדיר משתנה חדש שקוראים לו $min$ ובכל הכנסה נבצע לו השמה אם יתקיים שהערך שהוכנס קטן יותר מהערך הנוכחי של $min$ . (במקרה והמחסנית ריקה פשוט נבצע השמה מיידית). 

#### push
נבצע השמה ל $min$ לפי קלט $x$ בשיטה הבאה: 

* __המחסנית ריקה__ : במצב זה $min=x$ 
* __המחסנית לא ריקה__ : נחלק לתתי מצבים הבאים - 
	1) $x\geq{min}$ - פשוט נכניס את $x$ למחסנית כדרוש.
	2) $x<min$ - כעת, יש מינימום, נגדיר $min=x$ אבל לתוך המחסנית עצמה, נכניס : 
     $2x-min$  (נסביר בהמשך).

#### pop  
נרצה להוציא איבר $y$ מסוף המחסנית בשיטה הבאה : 

* $y\geq{min}$ אז ערכו של $min$ לא משתנה.
* $y<min$ נחזיר את $min$ למשתמש כי זה הערך המקורי שהוא שם ($y$ שמור במחסנית עם המניפולצייה שעשינו למעלה) ולאחר שהחזרנו למשתמש את $min$ נשנה את ערכו להיות : $min=2min-y$

```ad-Code
```cpp

struct MinStack
{
	stack<int> s;
	int min;
	int size=0;

	int 
	int getMin()
	{
		if (size > 0){
			return min
		}
	}

	int pop()
	{
		if (size > 0)
		{
			return;
		}

		int y = s.top();
		s.pop();
		int temp = 0; 
		if (y < min)
		{
			temp = min;
			min = 2*min - y;
			return temp;
		}
		size--;
		return y;
	}


	void push(int x)
	{
		if (size > 0)
		{
			min = x;
			s.push(x);
			return;
		}

		else if (x < min)
		{
			s.push(2*x - min);
			minEle = x;
		}

		else
		s.push(x);
		size++;
	}
};
```

__זמן ריצה $O(1)$ לכל הפעולות.__ כדרוש.

![[Pasted image 20220506232514.png]]

דרך החשיבה לבניית מבנה הנתונים הזה היא שנרצה לייצג אותו באופן כזה שכמות ההעתקות שנצטרך לעשות תהיה הקטנה ביותר. כלומר מטרתנו היא שנעשה העתקות רק בעת הוספה למערך. 

נגדיר את מבנה הנתונים שלנו כשתי תתי מערכים $l$ ו $r$ כאשר לשניהם יש איבר משותף שהוא האיבר הראשון שנכניס (במקום ה0). לשניהם ניתן גודל התחלתי של 2. כמו כן, נחזיק משתנה size שסופר את כמות האיברים בשני המערכים.

#### $r$ : 
מייצג את החצי הימני של המערך , כשנרצה להכניס איברים לסוף המערך נשתמש בו. כאשר נגמר המקום, נגדיל את המערך פי 2.
כאשר נרצה למחוק איברים מסוף המערך, נמחק מהמערך הזה גם כן עד שהוא יתרוקן ואז נשתמש במחיקה מתחילת המערך על $l$ (הסבר בהמשך).

 
#### $l$: 
מייצג את החצי השמאלי של המערך __מהסוף להתחלה__ כלומר האיבר האחרון במערך $l$ יהיה האיבר הראשון במערך הכולל של מבנה הנתונים שלנו. כאשר נרצה להוסיף לתחילת מבנה הנתונים שלנו פשוט נוסיף איברים רגיל למערך $l$ כפי שעשינו על $r$ באופן דומה נמחק מתחילת הרשימה על ידי מחיקת האיברים לפי הסדר עד שמערך $l$ יתרוקן. ברגע שהוא יתרוקן , נמחק מ $r$ באופן הסטנדרטי על ידי מחיקה והעתקה של האיברים.

### העלות לשיעורין : 
| פעולה                 | עלות אמיתית           | עלות לשיעורין |
| --------------------- | --------------------- | ------------- |
| הכנסת איבר להתחלה/סוף | 1 או n אם צריך להעתיק | 3             |
| החזרת איבר במקום הi   | 1                     | 1             |
| מחיקה מהסוף           | 1                     | 1             |
| מחיקה מההתחלה                      | 1 או n אם המערך השמאלי ריק                      |3               |
