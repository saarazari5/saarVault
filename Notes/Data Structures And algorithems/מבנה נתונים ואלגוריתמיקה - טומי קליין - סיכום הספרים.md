__סער אזערי__ 
# הפרד ומשול
בהגדרה - הפרד ומשול זוהי פרדיגמה לתכנון אלגוריתם המשתמשת בריקורסיה על מנת להפוך בעייה קלה לבעיות קלות יותר , זאת באה עם היתרונות והחסרונות שלה , למשל אנחנו עלולים לחשב מספר ערכים , מספר רב של פעמים כפי שנראה בפרק של [[#תכנון דינאמי]]. 
הרעיון מאחורי הפרדיגמה של הפרד ומשול היא פשוטה ואומרת : 
* תפריד את הבעיה לבעיות קטנות יותר (__הפרד__). 
* תפתור את הבעיות הקטנות יותר(__משול__).
* מזג את התוצאות.

![[Pasted image 20220621181444.png|400]]

היכולת הזאת לפשט את הבעיה מאפשרת לנו לפתור בעיות ביעילות ריצה שלא היינו מגיעים אליה בתכנות לא רקורסיבי. 

כעת נראה מספר בעיות הניתנות לפתרון בעזרת ריקורסייה.

### מינימום ומקסימום 
##### מינימום
נניח שיש לנו מערך $A[n]$ (האלמנטים יכולים להיות מכל סוג כל עוד יכולת ההשוואה מוגדרת על אותו הסוג). ננסה למצוא את איבר המינימום  של המערך הזה 

$$\text{min index m} :\forall{i\in[n]}:\ \  A[m]\leq{A[i]}$$

 הפתרון הטריוויאלי העולה בראש של כל מתכנת, היא להחזיר משתנה מקומי $min$ ולשמור אליו את הערך המינימלי תוך כדי ריצה על המערך. או בתיאור פסודו:
  
 ![[Pasted image 20220621182038.png]]


עם זאת אנחנו נאלץ לבצע $n-1$ השוואות ונרוץ על כל המערך, לא נשמע כזה נורא אך ניתן לפתור את זה אחרת . 

נוכל אולי לבטא את $n$ כביטוי בחזקת $2$ למשל $2^{m}$ ונוכל לחלק את המערך שלנו לזוגות (אולי יישאר איבר בודד אבל זה לא משנה),  נשווה כל זוג והמנצח ממשיך לשלב הבא ככה עד שנשאר איבר אחר (מעין טורניר בודוקאי). 

בפסודו: 
![[Pasted image 20220621182524.png]]
__נשים לב שאנחנו רוצים לזוז כל פעם בקפיצות ביחס לקומה בה אנחנו נמצאים ככל ש i מתקדם ככה יש פחות ופחות איברים במערך , על מנת שלא נקצה עוד זכרון נרוץ בקפיצות המתוארות למעלה__.

באופן ויזואלי : 
![[Pasted image 20220621182639.png]]


האם שיפרנו משהו? עבדנו קצת קשה אבל סך הכל נראה ש נקבל 

$$\frac{n}{2}+\frac{n}{4}+\dots+2+1=n-1$$


נשאלת השאלה, האם הדבר במקרה? 

לכל שיטה בה נבחר אנחנו תמיד נצטרך לעבור על $n$ האיברים במערך כדי לדעת האם האיבר עליו אנחנו עומדים הוא המינימום או לא. כלומר אנחנו תמיד נמצא את עצמנו בונים מעין עץ בינארי שלם  לכל השוואה שנבחר וכפי שנדבר בהמשך , 

__לכל עץ בינארי עם $n$ עלים, יש בידיוק $n-1$ קודקודים פנימיים__. 
לכן על מנת למצוא את המינימום נצטרך לעשות $n-1$ השוואות, לא ניתן לייעול.

##### מקסימום 
נשמע שזאת אותה הבעיה לא? פשוט להחליף את הסימן (להחליף $\leq$ ב $\geq$ ).
המעבר בין בעיה א׳ לבעיה ב׳ הוא אלגוריתם בפני עצמו הנקרא [reduction](https://en.wikipedia.org/wiki/Reduction_(complexity)) , זהו כלי בסיסי אך אפשר לדבר עליו רבות.

במקרה הזה המעבר די פשוט והוא עוזר לנו גם לדעת שנדרשת $n-1$ פעולות על מנת למצוא את המקסימום.


##### מינימום ומקסימום ביחד 
נוכל פשוט לחבר את שתי התוכנות לפעולה אחת ולקבל את התוצאה ב $2n-2$ שהיא חסומה ב $O(n-1)$ כמו השיטות הקודמות .

![[Pasted image 20220621185317.png]]

אבל בואו ננסה לייעל את השיטה הזאת , 
  דרך אחת תהיהי להוסיף $else$ בין שני ההשוואות כי כמובן שאם אחת מתקיימת השנייה לא. במערך עולה ממויין עם זאת, עדיין נקבל $2n-2$ פעולות. לא רע במיוחד אבל נוכל לייעל .

כעת, סוף סוף נוכל לדבר ולהראות איך נשתמש ב __הפרד ומשול__ כדי לפתור בעיות,

הפעולה תחזיר $(M,m)$ אחד מייצג את המקסימום ואחד את המינימום (לתוהים ששואלים איך אפשר להחזיר דבר כזה בתכנות, פשוט בונים struct , class או tuple). 

__הפרד__ - נחלק את המערך לחצי כל פעם - תנאי העצירה יהיה כאשר גודל תת המערך הוא 2 ואז נוכל להחזיר השוואה רגילה .

__משול__ - על כל תת מערך שמאלי וימני נפעיל רקורסיבית את הפעולה שוב פעם.

__מזג__ - נחזיר את המקסימום בין $M_{1,2}$ כאשר $1$ זה תת המערך השמאלי ו $2$ זה תת המערך הימני.  באופן דומה נחזיר את המינימום בין $m_{1},m_{2}$ .

```ad-Code
``` psudo
Algorithm: Max - Min(x, y)
if y – x ≤ 1 then
return (max(numbers[x], numbers[y]), min((numbers[x], numbers[y]))
else
(max1, min1):= maxmin(x, ⌊((x + y)/2)⌋)
(max2, min2):= maxmin(⌊((x + y)/2) + 1)⌋,y)
return (max(max1, max2), min(min1, min2))
```

 נחשב את זמן הריצה : 
 עבור $n$ שקטן או שווה ל$2$ אז זמן הריצה זהו זמן ריצה קבוע , לכן מה שמעניין זה כאשר $n>2$ .

$$T(n)=2\cdot T(\frac{n}{2})+2=\dots=1.5n-2\in O(n)$$

צמצמנו את זמן הריצה אבל זה לא ממש נחשב שיפור, וזה בלי לקחת בחשבון את העובדה שהריקורסייה תופסת יותר זכרון ואולי בכלל עדיף את הקוד הליניארי והשימוש בלולאה כמו מקודם... אבל עדיין זאת דרך לעבוד עם הפרד ומשול. 


### מיון מיזוג 
הצורך להחזיק אוסף מסוייף בסדר כלשהו הוא צורך תמידי הניכר בכל תחומי חיינו, גם בתכנות הרבה מאוד פעמים נרצה את המידע שלנו בסדר כלשהו. השיטה הטירוויאלית שכולם מכירים bubble sort היא המוכרת מכולם והפשוטה מכולם אך היא לוקחת $\Omega(n^{2})$ השוואות. 

באלגוריתם מיון המיזוג נשתמש בהפרד ומשול כדי לייעל את זמן המיזוג שלנו:

__הפרד__ - כל פעם נחלק את המערך לשני חצאים. 

__משול__ - ברגע שנגיע למערך בגודל 2 נחליף את סדר האיברים בהתאם לגודלם 

__מיזוג__ - לאחר שסידרנו כל תת מערך נחבר את החלקים למערך אחד גדול וממויין.

קוד המיזוג יהיה מאוד נאיבי כמובן שצריך לדעת באיזה אופן למזג וזה לא מספיק סתם לחבר בין שני המערכים, ישנם מספר דרכים למזג בין מערכים לא אפרט את כל התהליך כי זה לא רלוונטי , חשוב לדעת שכולן בסך הכל לוקחות $O(n)$ מבחינת זמן ריצה
 מצרף פה כמה אימפלמנטציות אפשריות : 

##### TOP - DOWN 
```ad-Code
``` cpp 

// Split A[] into 2 runs, sort both runs into B[], merge both runs from B[] to A[]
// iBegin is inclusive; iEnd is exclusive (A[iEnd] is not in the set).
void TopDownSplitMerge(B[], iBegin, iEnd, A[])
{
    if (iEnd - iBegin <= 1)                    // if run size == 1
        return;                              // consider it sorted
    // split the run longer than 1 item into halves
    iMiddle = (iEnd + iBegin) / 2;          // iMiddle = mid point
    // recursively sort both runs from array A[] into B[]
    TopDownSplitMerge(A, iBegin,  iMiddle, B);  // sort the left  run
    TopDownSplitMerge(A, iMiddle,    iEnd, B);  // sort the right run
    // merge the resulting runs from array B[] into A[]
    TopDownMerge(B, iBegin, iMiddle, iEnd, A);
}

//  Left source half is A[ iBegin:iMiddle-1].
// Right source half is A[iMiddle:iEnd-1   ].
// Result is            B[ iBegin:iEnd-1   ].
void TopDownMerge(A[], iBegin, iMiddle, iEnd, B[])
{
    i = iBegin, j = iMiddle;
 
    // While there are elements in the left or right runs...
    for (k = iBegin; k < iEnd; k++) {
    // If left run head exists and is <= existing right run head.
        if (i < iMiddle && (j >= iEnd || A[i] <= A[j])) {
            B[k] = A[i];
            i = i + 1;
        } else {
            B[k] = A[j];
            j = j + 1;
        }
    }
}
```

##### BOTTOM - UP 

``` ad-Code
```cpp
//  Left run is A[iLeft :iRight-1].
// Right run is A[iRight:iEnd-1  ].
void BottomUpMerge(A[], iLeft, iRight, iEnd, B[])
{
    i = iLeft, j = iRight;
    // While there are elements in the left or right runs...
    for (k = iLeft; k < iEnd; k++) {
   // If left run head exists and is <= existing right run head.
        if (i < iRight && (j >= iEnd || A[i] <= A[j])) {
            B[k] = A[i];
            i = i + 1;
        } else {
            B[k] = A[j];
            j = j + 1;    
        }
    } 
}
```

סך הכל הפסודו קוד יהיה מהצורה של אלגוריתם המיון יהיה מהצורה 

![[Pasted image 20220621202353.png]]

ננתח את הסיבכויות זמן ריצה לפי שיטת המאסטר 
$$T(n)=2T(\frac{n}{2})+n$$
לפי שיטת המאסטר נקבל שמספר הפעולות הריקורסיבי שווה למספר הפעולות הלא ריקורסיביות ולכן 
$$T(n)\in\Theta(n\cdot\log_{2}(n))$$
(הבסיס הדיפולטי בסיכום זה יהיה 2 תמיד, רשמתי את זה פה רק כדי שיהיה ברור).


__אנקדוטה__ - כל אלגוריתם מיון על מידע שכל מה שידוע עליו הוא יחס הסדר תמיד יהיה חסום ב $O(nlogn)$. 

### כפל של מספרים גדולים
על פניו נשמע כמו כותרת מוזרה כי תכנותית אנחנו רושמים פשוט
$\text{return }x\cdot{y}$ 

אז מה זה אומר בכלל ? נסתכל על הבעיה באופן תיאורטי ונניח שגודל המספר יכול להיות אין סופי , למרות שבמעבדי 64 ביטים הייצוג המקסימלי של מספר מספיק לרוב הבעיות שאנחנו מתמודדים איתם, נרצה להבין תיאורטית איך ניתן לייעל כפל כזה בהינתן שאנחנו מקבלים קלטים בגדלים לא ידועים השואפים למספר אינסופי.

יהי $X ,Y$ שני מספרים ששניהם באורך $n$ ביטים (כלומר בייצוג הבינארי שלהם). נניח את אורך הביטים בלי הגבלת הכלליות כיוון שאם נרצה להקטין מספר פשוט נשים כמה 0 שצריך מה msb .

אז איך בכלל מתחילים לחשב זמן ריצה של דבר כזה? שלא לדבר על איך משתמשים בהפרד ומשול כדי לחשב את זה ... לפי החוקים של כפל אנחנו בעצם נבצע $n^{2}$ פעולות כפל וחיבור באלגוריתם הנאיבי ולכן חסום ב $\Theta(n^2)$ . 

![[Pasted image 20220622101259.png]]

זה בשיטה הנאיבית. ננסה לראות כמה יצא לנו על ידי שימוש בהפרד ומשול 
נגדיר $X=x_{1}x_{2}x_{3}\dots x_{n}$  וגם $Y=y_{1}y_{2}y_{3}\dots{y_{n}}$.  כאשר כל ספרה שייכת לקבוצה הבינארית וכל ספרה היא ביט.

נחלק באמצע את מספר הספרות באופן הבא 

![[Pasted image 20220622102015.png]]

כעת כמו שניתן לפרק מספר לספרות בבסיס 10 נעשה זאת על המספרים שלנו באופן הבא 
$$\displaylines{
X=X_{1}2^{\frac{n}{2}}+X_{2}\\
Y=Y_{1}2^{\frac{n}{2}}+Y_{2}
}$$

הכפל בינהם יהיה 

$$XY=X_{1}Y_{1}2^{n}+(X_{1}Y_{2}+X_{2}Y_{1})2^{n/2}+X_{2}Y_{2}$$
וכאן בעצם יש לנו איזשהי זהות ריקורסיבית וזהות זאת תהיה המשול שלנו, על כל תתי מספרים בינאריים ניקח את החצאים וננחשב רקורסיבית את הביטוי המתמטי הזה.

בפסודו קוד זה ייראה ככה : 

![[Pasted image 20220622103239.png]]

ומבחינת סיבוכיות זמן ריצה נקבל 

$$T(n)=4T(\frac{n}{2})+cn$$
כאשר $cn$ מייצג את כל הפעולות הלא ריקורסיביות כמו העלאת חזקה וכל פעולות החיבור שנעשה.
לפי שיטת המאסטר נקבל שהסיבוכיות הזאת היא גם כן $\Theta(n^{2})$ וזה לא עזר. נוכל לייעל את הזמן ריצה הזה אך לא בהרבה על ידי כך שנשים לב שמתקיים 

$$E=(X_{1}+X_{2})(Y_{1}+Y_{2})=X_{1}Y_{1}+X_{1}Y_{2}+X_2Y_{1}+X_{2}Y_2$$
נסמן $A=X_{1}Y_{1}$  ו $B=X_{2}Y_{2}$ 

כלומר באמצע החישוב של $A,B$ נוכל לייצר תלות עם הביטוי האמצעי ולחסור פעולה ריקורסיבית אחת, נקבל זמן ריצה קצת יותר יעיל של $n^{1.5}$ .

המסקנה היא שצריך לדעת מתי להשתמש בהפרד ומשול כי לא בהכרח שזה יהיה שווה את זה.


__אנדקוטה , פעולת העלאה בחזקת n של מספר בשיטת הפרד ומשול היא לוגריתמית ביחס ל n__ (לא נוכיח את זה בסיכום הזה).

#### תרגילים הפרד ומשול 
![[Pasted image 20220622105923.png]]

על מנת נפתור את הבעיה באותה סיבוכיות בצורה לא ריקורסיבית פשוט נבין מה עשינו בשיטה הריקורסיבית ב [[#מינימום ומקסימום ]]. בעצם עשינו שיטת טורניר, כל פעם קפצנו בקפיצות זוגיות והשוונו בין הערכים. כלומר עלינו לשמר את היכול להשוות איברים בזוגות ולקפוץ בקפיצות זוגיות .

סך הכל הפתרון יהיה מהצורה 
``` ad-Code 
```cpp

struct Pair
{
	int min;
	int max;
};

struct Pair getMinMax(int arr[], int n)
{
	struct Pair minmax;	
	int i;
	
	// If array has even number of elements
	// then initialize the first two elements
	// as minimum and maximum
	if (n % 2 == 0)
	{
		if (arr[0] > arr[1])	
		{
			minmax.max = arr[0];
			minmax.min = arr[1];
		}
		else
		{
			minmax.min = arr[0];
			minmax.max = arr[1];
		}
		
		// Set the starting index for loop
		i = 2;
	}
	
	// If array has odd number of elements
	// then initialize the first element as
	// minimum and maximum
	else
	{
		minmax.min = arr[0];
		minmax.max = arr[0];
		
		// Set the starting index for loop
		i = 1;
	}
	
	// In the while loop, pick elements in
	// pair and compare the pair with max
	// and min so far
	while (i < n - 1)
	{		
		if (arr[i] > arr[i + 1])		
		{
			if(arr[i] > minmax.max)	
				minmax.max = arr[i];
				
			if(arr[i + 1] < minmax.min)		
				minmax.min = arr[i + 1];	
		}
		else	
		{
			if (arr[i + 1] > minmax.max)	
				minmax.max = arr[i + 1];
				
			if (arr[i] < minmax.min)		
				minmax.min = arr[i];	
		}
		
		// Increment the index by 2 as
		// two elements are processed in loop
		i += 2;
	}		
	return minmax;
}

```

הקוד קצת ארוך אבל סך הכל, רצנו על האיברים בזוגות במקום לרוץ על כל איברים המערך, באופן זה חסכנו את מספר האיטרציות.

![[Pasted image 20220622124229.png]]

הבעיה היא שהביטוי הפנימי נותן את $X+X_{2}$ ולכן זה בעצם יוצא שאנחנו עושים את הקריאה הריקורסיבית פעמיים כדי לחלק את המספר לשתי חצאים , כלומר אנחנו שוב נעשה 4 פעמים פעולות ריקורסיביות וזה לא מייעל את הזמן ריצה אנחנו נקבל $\Theta(n^{2})$ שוב.

![[Pasted image 20220622152007.png]]

נסתכל על הבעיה בצורה הנאיבית שלה, נרוץ על שתי לולאות הלולאה החיצונית תחזיק אינדקס והלולאה הפנימית תחשב את המינימום עבור אינדקס זה, ככה נעשה עבור כל האינדקסים האפשריים (נשים לב שאין טעם לחזור אחורה כיוון שסכום הוא חילופי ולכן כבר חישבנו. את המקסימום כשזזים אחורה).

כעת שיש לנו אינטואצייה על האלגוריתם הנאיבי נבין מה יש לנו כאן, 

* הסכום הכי קטן יכול להיות בחציו השמאלי של המערך , בחציו הימני או בשילוב של שניהם
* מתוך ההבנה הזאת נחלק את המערך ל2 בצורה ריקורסיבית 
* ניקח מקסימום בכל אחד מהחצאים
* בהינתן נקודה שמאלית , נקודה ימנית  ואמצע. נחשב את המקסימום כולל האמצע על ידי חישוב המינימום בין הסכום מאמצע לנקודה שמאלית , בין אמצע לנקודה ימנית ובין החיבור שלהם.

```ad-Code
```cpp

int minCrossingSum(int arr[], int l, int m, int h)
{
	// Include elements on left of mid.
	int sum = 0;
	int left_sum = INT_MAX;
	for (int i = m; i >= l; i--) {
		sum = sum + arr[i];
		if (sum < left_sum)
			left_sum = sum;
	}

	// Include elements on right of mid
	sum = 0;
	int right_sum = INT_MAX;
	for (int i = m + 1; i <= h; i++) {
		sum = sum + arr[i];
		if (sum < right_sum)
			right_sum = sum;
	}

	// Return sum of elements on left and right of mid
	return min(left_sum + right_sum, left_sum, right_sum);
}

// Returns sum of maximum sum subarray in aa[l..h]
int minSubArraySum(int arr[], int l, int h)
{
	// Base Case: Only one element
	if (l == h)
		return arr[l];

	// Find middle point
	int m = (l + h) / 2;

	return min(minSubArraySum(arr, l, m),
			minSubArraySum(arr, m + 1, h),
			minCrossingSum(arr, l, m, h));
}

```

זמן הריצה של זה יהיה 
$$T(n)=2T(\frac{n}{2})+\Theta(n)$$
לפי שיטת המאסטר נקבל שזמן הריצה הוא $\Theta(n\log(n))$ __כנדרש__. 


![[Pasted image 20220622190534.png]]

אם נפתח את $T(n)$ נקבל מעין עץ שהחלוקה של מספר הילדים לכל קודקוד תלוייה ב $s$ 

![[Pasted image 20220622194355.png]]

וכעת אנחנו יודעים בוודאות שמספר הפעולות הריקורסיביות הוא לכל היותר גובה העץ $\log_{s}(n)$ .
באופן כללי העבודה שתבוצע ברמה ה$i$ תהיה : 
$$O(n^{d})\cdot{\frac{m^{i}}{s^{di}}}$$
והעבודה התבוצע סך הכל תהיה 

$$\sum\limits_{i=0}^{\log_{b}(n)}O(n^{d})\cdot{\frac{m^{i}}{s^{di}}}=O(n^{d})\sum\limits_{i=0}^{\log_{b}(n)}(\frac{m}{s^{d}})^{i}$$

נשים לב שקיבלנו בעצם סדרה הנדסית כאשר $q=\frac{m}{s^{d}}$ ו $O(n^{d})$ הוא קבוע 
כעת נחלק למקרים :  
* $\frac{m}{s^{d}}<1$ 
אז הטור מתכנס לקבוע ולכן $T(n)$ שייך ל $O(n^{d})$ 
* $\frac{m}{s^{d}}=1$ 
אז נקבל $O(n^{d})\log_{s}(n)\in{O(n^{d}logn)}$ כי מעבר בין בסיסים תלוי בקבוע ולכן זה לא משנה.
* $\frac{m}{s^{d}}>1$ 
נקבל שהאיבר החשוב בסכום הוא האיבר האחרון  כי הוא הגדול ביותר התלוי ב$n$ נקבל : 
$$\displaylines{O(n^{d})\cdot (\frac{m}{s^{d}})^{log_{s}(n)}=\\O(n^{d}\cdot \frac{m^{log_{s}(n)}}{s^{d\cdot log_{s}(n)}})=O(n^{d}\frac{n^{log_{s}(m)}}{n^{d\cdot{log_{s}(s)}}})=O(n^{d}\frac{n^{log_{s}(m)}}{n^{d}})}$$
וסה״כ נקבל $O(n^{log_{s}(m)})$ __כנדרש__ .


![[Pasted image 20220622230551.png]]

__1__ . במערך ממויין איבר החציון יהיה האיבר האמצעי במערך. לכן נרצה להוכיח שהאלגוריתם אכן מביא את איבר זה בהינתן מערך לא ממויין . 

האלגוריתם הפרד ומשול פה , מפצל את המערך לשתי חלקים ומפעיל את האלגוריתם על איבר החציון על כל אחד מתתי המערכים , ככה האלגוריתם הרקורסיבי ימשיך עד שיגיע לשתי תתי מערכים בגודל 5 ויחשב ישירות את החציון בזמן קבוע עבור $A_{1,2}$ . לכן באופן ריקורסיבי האלגוריתם אמור לעבוד עד לנקודה זו. 
החלק המעניין של ההוכחה הוא בהגדרת הקבוצה $C$  נבנה מערך שמכיל את כל האיבר הגדולים מ $m_1$ כולל  ואת כל האיברים הקטנים ממש מ $A_{2}$ (בלי הגבלת הכלליות $m_{1}<m_{2}$) נשים לב שיכול להיות ש $m_{2}$ נמצא במערך הזה בכל מקרה כי הוא גדול מ $m_{1}$ ויש סיכוי שהוא היה גם ב $A_{1}$. בכל מקרה משהו חשוב נוסף הוא שמספר האיברים הגדולים מ $m_{1}$ יהיו שווים למספר האיברים הקטנים מ $m_{2}$ במערך הזה כיוון ששניהם החציונים. 

במילים אחרות $m_{1}$ ו$m_2$ הם רבעונים של המערך $A$ ואנחנו לוקחים את כל מה שבינהם . (לפי יחס הסדר המוגדר על האיברים ולא לפי אינדקסים במערך) לכן החציון של המערך המקורי בהכרח יהיה בפנים __כדרוש__ . 


__2__ . גודל $C$  בכל איטרציה ריקורסיבית יהיה תלוי ב $n$ גודלו יהיה $n/2$ מהסיבה של הוא מורכב מהחצי הגדול של האיברים בתת המערך השמאלי שזה $n/4$ וכנ״ל לגבי החצי הקטן של האיברים של תת המערך הימני שזה $n/4$. 

__3__. זמן הריצה פה יהיה על כל תת מערך במקרה הגרוע מבצעים שוב פעם את מציאת החציון על מערך חדש לכן נוסחת הנסיגה תהיה מהצורה 
$$T(n)=3T(\frac{n}{2})+O(n)\in \Theta(n^{\log(3)}=n^{1.6})$$

כאשר מתייחסים לזמן הבנייה של $C$. לפי שיטת המאסטר. הסיבה שהאלגוריתם מיותר זה כי יכלנו פשוט למיין עם $merge sort$ ולהשיג תוצאה יותר טובה .


# מבני נתונים ליניאריים 
## שמירת מידע וניהולו 
לפעמים כמתכנתים נרצה יכולות מתקדמות לשמירה וניהול המידע איתו נרצה לבצע כל מיני פעולות , כאן נכנסים לתמונה מבני הנתונים שהם הנושא של הקורס הזה. כשמדברים ניהול מידע באוסף אנחנו מדברים על ניהול של יישות הנקראת record שהיא יכולה להכיל מספר רב של שדות (למשל סטודנט : שם, שם משפחה , מזהה , כתובת , תחום לימוד , ציונים וכו....). נרצה יכולת לנהל את הrecords בצורה שמתאימה לתוכנית שלנו בצורה היעילה ביותר. אין באמת תשובה נכונה לאיזה מבנה נתונים צריך להשתמש כי כל תוכנית וצרכיה שלה. לכל מבנה יהיו היתרונות והחסרונות שלו וצריך לבחור אותו בהתאם לשאילתות שנרצה לבצע על המידע.

## רשימה 
אחד הפתרונות המוכרים ביותר היא לעבור עם  [sequential allocation](http://www.xpode.com/ShowArticle.aspx?Articleid=282)
שמאפשר לשמור את המידע בזכרון בסדר מסויים של הכתובות ובקפיצה לפי גודל הrecord שאותו אנחנו שומרים (למשל רשימה בגודל 10 של מספרים שהאיבר הראשון שמור בכתובת 0, גודל כל מספר הוא 4 בייטים ולכן האיבר האחרון יהיה בכתובת 40).
היכולת הזאת טובה מאוד להכנסות והוצאות של איברים אך גרועה לחיפוש . __הפתרון__ שמירה של האוסף בצורה ממויינת ומיון על ידי [[binary search]].

## רשימה מקושרת 
אחת הבעיות של רשימה היא החסרון שלה בעדכון איברים , כיוון שהרבה פעמים נרצה להכניס איברים תוך כדי שמירה על יחס הסדר המוגדר בין ה records יכולה להיווצר בעיה בשימוש בהקצאה רציפה כיוון שהדבר ידרוש מאיתנו לשנות ולהזיז את האיברים בישביל לפנות מקום לאיבר שנרצה להכניסץ נוכל לפתור את הבעיה הזאת על ידי שימוש ב [linked allocation](http://www.xpode.com/ShowArticle.aspx?Articleid=282) , שזה בעצם אומר שנוכל להקצות מקומות שהם לא בהכרח בסדר רציף, באופן זה נוכל ליצור רשימה מקושרת שמחוברת על ידי מצביעים לכתובות האלו וכשנרצה להכניס כתובת חדשה זה יהיה מאוד פשוט. הבעיה כעת היא שחיפוש הוא לא כזה פשוט יותר כמו ברשימה רגילה שבה כאשר האוסף ממויין נוכל לבצע חיפוש בינארי יעיל לפי אינדקסי החציון.  עכשיו , גם אם האוסף ממויין לגשת לאיבר באינדקס כלשהו לוקח $O(n)$ פעולות. נלמד מבני נתונים שעוזרים לנו להתמודד עם הבעיות האלו בהמשך .

![[Pasted image 20220623113056.png]]
## תור
אחד הדרכים היותר טבעיות לארגן את המידע בסדר מסויים הנקרא תור (queue). התור מאפשר לשמור את הנתונים לפי סדר הכנסתם על מנת להוציאם אותו הסדר (FIFO-first in first out). לתור יש את היכולת להכניס איברים לתחילתו ולהוציא מסופו באופן מיידי שלא כולל סריקה, עושים זאת על ידי החזקת שני מצביעים לקידמת התור ולסופו. ניתן לשמור את האיברים ברשימה מקושרת או בהקצאה רציפה כאשר השימוש בהקצאה רציפה דורש מאיתנו לדעת בערך את מספר האיברים איתם נרצה להתעסק אחרת קיים הסיכון ל overflow. 

פעולות ההכנסה וההוצאה נקראות enqueue ו dequeue .
![[Pasted image 20220623123201.png]]

#### __מימושים לתור :__ 

* _מערך_

```ad-Code
```cpp

struct Queue {
	int front, rear, capacity;
	int* queue;
	
	Queue(int c)
	{
		front = rear = 0;
		capacity = c;
		queue = new int;
	}

	~Queue() { delete[] queue; }

	// function to insert an element
	// at the rear of the queue
	void queueEnqueue(int data)
	{
		// check queue is full or not
		if (capacity == rear) {
			return;
		}

		// insert element at the rear
		else {
			queue[rear] = data;
			rear++;
		}
		return;
	}

	// function to delete an element
	// from the front of the queue
	void queueDequeue()
	{
		// if queue is empty
		if (front == rear) {
			printf("\nQueue is empty\n");
			return;
		}

		// shift all the elements from index 2 till rear
		// to the left by one
		else {
			for (int i = 0; i < rear - 1; i++) {
				queue[i] = queue[i + 1];
			}

			// decrement rear
			rear--;
		}
		return;
	}


```

נבין מה קורה פה - כמו שאמרנו כשעובדים עם מערך צריך שיהיה capacity כל שהוא (מומלץ לפחות) מתודת ההכנסה היא די פשוטה ולוקחת $O(1)$ בהינתן שלא חרגנו מה מכנסה. מתודת ההוצאה דורשת ההעתקה של כל האיברים אחורה וההקטנה איבר ה rear ב1 ולכן זה חסום ב$O(n)$ .

* _רשימה מקושרת_
```ad-Code
```cpp
struct QNode {
	int data;
	QNode* next;
	QNode(int d)
	{
		data = d;
		next = NULL;
	}
};

struct Queue {
	QNode *front, *rear;
	Queue()
	{
		front = rear = NULL;
	}

	void enQueue(int x)
	{

		// Create a new LL node
		QNode* temp = new QNode(x);

		// If queue is empty, then
		// new node is front and rear both
		if (rear == NULL) {
			front = rear = temp;
			return;
		}

		// Add the new node at
		// the end of queue and change rear
		rear->next = temp;
		rear = temp;
	}

	// Function to remove
	// a key from given queue q
	void deQueue()
	{
		// If queue is empty, return NULL.
		if (front == NULL)
			return;

		// Store previous front and
		// move front one node ahead
		QNode* temp = front;
		front = front->next;

		// If front becomes NULL, then
		// change rear also as NULL
		if (front == NULL)
			rear = NULL;

		delete (temp);
	}
};
```
שיטה זאת היא העדיפה כמובן כיוון שבמקרה זה אנחנו לא צריכים להעתיק שום דבר בהסרה והוצאה מהתור ולכן כל הפעולות הן ב $O(1)$ .


#### דוגמאות לשימוש בתור -  optimal prefix code 
 [prefix code](https://www.cs.princeton.edu/courses/archive/spr01/cs126/assignments/prefix.html) זה איזשהו פרמטר שניתן לתת לאובייקט בישביל לזהות אותו בצורה יותר מהירה. 
 נניח שיש קבוצה של מספרים בעלת עוצמה $n$ , נסמנן $a_{i}:i\in[n]$ . נרצה באופן מתמשך להוריד את שני האיברים הקטנים ביותר מהסדרה ולהוסיף את סכומם כאיבר חדש בקבוצה , כך עד שיישאר איבר אחד, זהו חלק מפתרון של מציאת ה optimal prefix code (לא נגע בפתרון כולו) לפרמטר כלשהו. ברור לנו שאם הקבוצה לא ממויינת נצטרך $n^{2}$ השוואות. 
 נוכל למיין ב $nlogn$ ואז לשמור ברישמה מקושרת מה שיאפשר הוצאה , סכימה והכנסה מחדש בזמן קבוע , ונבצע זאת $n-1$ פעמים ולכן עדיין נהיה חסומים ב $nlogn$ פעולות. 

נוכל לבצע את המטלה הזאת בזמן זהה אם נשתמש בשני תורים $Q_{1}$ $Q_{2}$ . בראשון נשמור את איברי הקבוצה המקוריים בסדר לא יורד (עולה שווה). את השני נחזיק ריק והוא יכיל רק את האיברים שנוצרים על ידי האלגוריתם כלומר סכום של שני איברים מינימליים מהקבוצה . כעת נחפש את המינימום בשני התורים אך שהפעם לא צריך להסתבך לאן מכניסים את הסכום החדש. פשוט ייכנס למאחורי $Q_{2}$ .  אם המערך ממויין זמן העבודה הוא ליניארי 

![[Pasted image 20220623155501.png]]

## מחסנית 
המקבילה של FIFO של המסנית היא LIFO (last in first out). בגלל זה למבנה נתונים קוראים מחסנית, הקליע האחרון שנכניס למחסנית הוא הראשון שיצא בלחיצה על ההדק. 

כמו [[#תור]] גם מחסנית ניתן לממש על ידי הקצאות רציפות והקצאות מקושרות. בניגוד לתור אנחנו לא מתעסקים עם תחתית המחסנית אלא רק עם מי שנמצא למעלה שהוא ה $top$ .  באופן סכמתי זה יראה כך :
![[Pasted image 20220623161246.png]]

כיוון שהמימושים נורא זהים על מערך ורשימה מקושרת ארשום פה רק את הפסודו קוד של כל אחד מהם 
![[Pasted image 20220623162759.png]]

בשני המקרים הוצאה והכנסה היא ב $O(1)$ אבל נורא קשה לבצע פעולות סריקה וכו...

#### דוגמאות לשימוש במחסנית -  ביטויים אריתמטיים 
נסתכל על ביטוי מתמטי שאנחנו נתקלנו בו ביסודי 
$$4+3 \times5$$
בעוד שהמחשבוני כיס הפשוטים יתרגמו את זה כ35, אנחנו עוד משהיינו ילדים הבנו שיש פה עדיפות לפעולת הכפל לפני פעולת החיבור והתשובה האמיתית היא 19 . ומה אם היה את הביטוי הבא 
$$(4+3)\times 5$$
סגנון הכתיבה הזה כנראה מגיע מסיבות היסטוריות שכן , כיום כשאנחנו מפעילים פונקצייה על משתנה מסויים אנחנו רושמים $f(x)$ ואם זה שני משתנים אז $f(x,y)$ ולא $xfy$ . באופן דומה היינו צריכים לרשום את הביטוי שלנו באופן הבא $add(4,multiply(3,5))$ על מנת שזה יהיה דומה לאופן שבוא רושמים פונקציות.

סגנון הכתיבה הזה נקרא [Polish notation](https://en.wikipedia.org/wiki/Polish_notation) .(נקרא גם prefix notation)
בסגנון הכתיבה הזה נרשום את הביטוי באופן הבא 
$$+4\times 3\ \ 5\ \ \ \ \ \text{ or}\ \ \ \ \times+\ 4\ \ 3\ \  5$$
באופן דומה. יש סגנון כתיבה הנקרא [Reverse Polish notation](https://en.wikipedia.org/wiki/Reverse_Polish_notation). (נקרא גם  postfix notation).
בשיטה זאת נרשום קודם את המספרים ולאחר מכן את הביטוי המתמטי שנרצה לבצע. זה יראה כך 
$$4\ \  3\ +\ 5\ \times \ \ \ \ \text{ or}\ \ \ \ \ 4\ \ 3\ \  5\ \times+$$

הסטנדרט הנ״ל נקרא [Infix notation](https://en.wikipedia.org/wiki/Infix_notation). בשיטה הזאת למחשב יכולה להיות בעיה לדעת מהן סדרי העדיפויות אך בשיטת postfix למעשה הדבר נהיה די פשוט, סך הכל לבצע סריקה של המחסנית תהיה פשוטה מאוד על ידי סריקה של הביטוי עם מחסנית באופן הבא : 
מכניסים איברים למחסנית נניח שהשניים האחרונים שנכנסו הם $y,z$ ברגע שייכנס אופרטור $X$ מוציאים את שני האיברים הנ״ל מהמחסנית ומחזירים למחסנית את התוצאה המתקבלת מהפעלת האופרטור על איברים אלו. 

בפסודו - 

![[Pasted image 20220623181003.png]]

ובאופן ויזואלי  על הביטוי 
$$\displaylines{
\text{infix: }(4+3)\times(2\uparrow(14-8)/2)\\
\text{postfix: }4\ \ 3+2\ \ 14\ \ 8-2/\uparrow\times
}$$
![[Pasted image 20220623181559.png]]

דיברנו על איך להשתמש במחסנית בישביל לחשב בהנחה שהביטוי הגיע בצורת postfix. עם זאת אנחנו יודעים שבפועל אנחנו רושמים ביטוי בצורת infix. נשאלת השאלה איך מתבצעת ההמרה מביטוי אריתמטי רגיל לביטוי בצורת postfix שעליו ניתן לבצע חישובים? לא אפרט כאן את ההסבר אך גם לשימוש הזה משתמשים במחסנית ובטבלת עדיפויות כאשר לסוגריים ניתן העדיפות הכי גבוהה (זה יינתן בצורת מספר) , ולאחר מכן באמצעות הטבלה האופרטים נשמרים במחסנית לפי סדר העדיפויות שלהם. 

__אנקדוטה__ המחסנית באה לידי ביטוי גם כאשר אנחנו שומרים זכרון במחשב, בעיקר של משתנים מקומיים שבסוף קריאת הפונקצייה ירדו מהstack. למשל בקריאות ריקורסיביות הפרמטרים נשמרים בstack אחד על השני וכל חזרה אחורה המשתנים המקומיים יורדים מהstack עד שהריקורסיה מסתיימת.

### SKIP LIST 
רשימה מקושרת לא תומכת בחיפוש בינארי , ורשימה רגילה לא מאפשרת לנו החלפה , הכנסה ומחיקה בצורה מהירה. 
נרצה מבנה נתונים שמאפשר לנו לחפש ולהכניס איברים בזמן לוגריתמי לכמות האיברים .
#### בניית skip list
ניקח את איברי הרשימה המקושרת ונוסיף שני איברים בקצוות איברי sential שנראה שימושים שלהם גם בתרגילים למטה.
נשנה עוד רשימה שתכיל את כל האיברים במקומות הזוגיים עם פוינטר בין האיברים ברשימה הזאת לאיברים ברשימה המקורית 
![[Pasted image 20220629022242.png]]
באופן זה נוכל לדלג על איברים בעת חיפוש (במקרה הזה על חצי מהאיברים מדלגים במקרה הגרוע).
נוכל באופן כללי לבנות את המבנה הזה שכל קומה מכילה את האיברים במקומות הזוגית בקומה שמתחתיה עם פוינטרים שמחברים זה ייראה כך 
![[Pasted image 20220629022421.png]]
בדומה קצת ל [[#ערימות]] ול [[#עצי AVL]] כל שכבה אנחנו מקבלים פחות איברים (במבנים הנ״ל זה אומנם הפוך אבל אותו רעיון) ובגלל שכל פעם מעלים רק את המקומות הזוגיים הקומה סך הכל יהיו $logn$ קומות.

#### חיפוש
יתחיל מהקומה הגבוהה ביותר ובהתאם לבדיקה האם האיבר גדול יותר או קטן יותר מהאיבר הראשון בקומה נדע על כמה איברים לדלג, ברגע שמצאנו את התחום אפשר לרדת למטה בקומה ולחפש בטווח המצומצם. 
הרעיון מאחורי זה הוא מבנה שנותן לנו בערך חיפוש בינארי על כתובות זכרון לא ידועים, בקומה הגבוהה ביותר אני מסנן חצי מהמערך ולאחר מכן רבע ולאחר מכן שמינית וכן הלאה עד להגעה לאיבר הרצוי.

דוגמה לחיפוש 71 בskip list
![[Pasted image 20220629022812.png]]

#### תמיכה בהכנסות 
* נמצא את המיקום שבוא הוא אמור להיות על ידי חיפוש בינארי.
* כל איבר שנכנס יתחיל מהרמה התחתונה, אם הוא נמצא בין שני איברים, הוא מיד עולה למעלה. אם באופן כללי נוצר רצף של שלושה איברים מההכנסה, האיבר האמצעי מבינהם יעלה למעלה.
* זה יחזור על עצמו כל רמה עד הרמה האחרונה שבטוח לא יהיה מצב כזה (אם היה אז פשוט הייתה נוצרת עוד רמה, קצת כמו עצי [[#עצי B]] שהבנייה נעשת מלמטה למעלה).
(תמיכה במחיקות היא כבר יותר מסובכת ולא אכנס לזה כאן)
#### החזרת האיבר ה k בגודלו 
נחזיק בכל קודקוד ובכל קומה מידע המעיד על המרחק בינו לבין האיבר הבא באותה קומה אבל המרחק ייצג את הקומה המקורית! , לדוגמה
![[Pasted image 20220629023909.png]]
בין 34 ל64 יש 3 איברים ברשימה המקורית. 
באופן זה נוכל לדעת האם הדילוג מתאים לנו למציאת $k$ ואם כן נדלג, אחרת נכנס פנימה. 

### תרגילים רשימות ליניאריות
![[Pasted image 20220623210018.png]]

נשתמש בשני פוינטרים שמתחילים בתחילת המערך אחד מהם נריץ בצורה רגילה ואת השני נריץ פי 3 יותר מהר. חשוב לציין שלא נקבל שגיאת overflow בגלל שאנחנו יודעים שהרשימה היא בגודל 3k. 
נריץ כך עד שהמצביע המהיר יותר יצביע על null .
__טענה__ המצביע האיטי יותר יהיה בידיוק באינדקס 1/3n.
__הוכחה__ המצביע המהיר יותר מגיע לסוף הרשימה שאורכה $n$ בקצב של $3$ צעדים כל איטרצייה כלומר סך הכל עשה $1/3n$ צעדים. בגלל שהמצביע האיטי יותר עושה צעד בודד כל איטרצייה הוא בהכרח יהיה באינדקס $1/3n$ .

כעת אנחנו דילגנו על השליש הראשון, נעביר את המצביע שהגיע לסוף הרשימה למיקום של המצביע השני באינדקס $1/3n$ . כעת יש לנו בעיה נוספת, יש לנו שני שליש נוספים לסריקה אנחנו צריכים לסרוק רק את השליש הראשונים. לכן נעשה באותו אופן הנ״ל רק שהפעם במקום להזיז פי 3 יותר מהר נזיז פי 2 באופן זה נסרוק את החצי הנוצר שהוא בעצם השליש האמצעי מהרשימה המקורית __כדרוש__. 

```ad-Code
```code

p=head q=head
while q.next not equal null :
	p = p.next()
	q = q.next().next().next()
	
q=p
while q.next() not equal null :
	print(p)
	p=p.next()
	q=q.next().next()

```

כפי שהוכחנו בתרגול יהיה מעגל אם ורק אם המצביעים הנ״ל ייפגשו מתישהו בחסם התלוי בגודל הרשימה (כלומר יהיה סיבוב אחד ועוד מספר קבוע של צעדים). לא אפרט פה את כל ההוכחה אבל ניתן לקרוא עוד ב [Floyd’s Cycle-Finding Algorithm](https://en.wikipedia.org/wiki/Cycle_detection).

![[Pasted image 20220623214315.png]]
הפתרון הוא לשמור את איברי המטריצה ברשימה מקושרת של רשימות מקושרות (או רשימה מקושרת דו מימדית) כאשר האיברים בשורה הראשונה במטריצה ששונים מ 0 יהיו ברשימה הראשונה וכן הלאה עד $n$ . כמו כן, כל איבר שנשמור במרשימה המקושרת בנוסף לערכו יכיל את המיקום המקורי שלו במטריצה כזוג סדור, כל נדע האם עלינו לכפול בו או לא.
כיוון שמחפשים רק את איברי ה $trace$, אנחנו יודעים שיתקיים 
$$a_{ii}=C_{i}(M)\cdot R_{i}(M)$$
וה$trace$ יהיה סכומם של כל איברים אלו, מהנתון שמספר האיברים בכל השורות והעמודות ששונות מ 0 חסום ב $O(n)$ והעובדה שאנחנו סך הכל סוכמים ומבצעים פעולות כפל על כל איברים אלו שאלה פעולות קבועות, אנחנו נמצא את ה $trace$ ב $O(n)$ 


![[Pasted image 20220624123912.png]]
* נוכל להשתמש בחיפוש בינארי פשוט נתחיל מאמצע המערך , אם האיבר שלילי והאיבר לפניו חיובי סיימנו, אחרת נלך לחצי של תת המערך השמאלי. אם האיבר חיובי והאיבר אחריו שלילי גם סיימנו , אחרת נלך לחציו של תת המערך הימני. 
סך הכל כפי שהוכחנו על אלגוריתם חיפוש בינארי זה ייקח $O(logn)$

* במקרה הזה נצטרך אקסטרה מקום עבור פוינטר נוסף , שאיתו נעשה חיפוש ליניארי ועם הפוינטר השני נעשה את החיפוש הבינארי הנ״ל . כלומר אחר סורק רגיל והשני סורק בחיפוש בינארי.

* נשתמש בטכניקה שראינו ב [skip list](https://www.geeksforgeeks.org/skip-list/) . נזוז בקפיצות של $2^i$ כלומר סדרה הנדסית. ברגע שמצאנו אינדקס שהחזקה הבאה אחריו היא שלילית ניקח את המערך $A[2^{i}...min(2^{i+1},n)]$ ועליו התת מערך הזה נעשה חיפוש בינארי.
* סך הכל אנחנו עושים $i$ פעולות כדי להגיע למצוא את תת המערך ואז עוד $log(min(2^{i+1},n)-2^{i})$ וסך הכל נקבל פעולה לוגריתמית שחסומה באינדקס הנתון כיוון ש $2^{i}$ זה מספר הצעדים שהיינו זזים בזמן ליניארי וכנל לגבי מה שבתוך הלוג השני. סך הכל האינדקס שיימצא בתוך הלוג השני ועוד $i$ פעולות יהיה בעצם $log(k)$ פעולות.


![[Pasted image 20220624123209.png]]

__סתירה__ , על פניו נראה שאפשר כי ראינו אלגוריתם ל[מיון מחסנית בעזרת מחסנית אחרת)](https://www.geeksforgeeks.org/sort-stack-using-temporary-stack/) שזה בידיוק מה שהתרגיל מבקש. עם זאת הקאץ׳ כאן הוא שאסור לנו להשתמש במשתנה עזר כדי לשמור ערך מסויים מחוץ למחסנית. חייב לעשות את זה אך ורק עם ראשי המחסנית. מצב זה כבר לא אפשרי למשל 

עבור הקלט $1,3,2$ לא נצליח לפתור את הבעיה נדגים זאת ויזואלית:

![[Pasted image 20220624134553.png]]

אומנם  1 נמצא בקדמת הכביש אך מכאן נכנס למחזוריות כזאת שלא נוכל לסדר את 2 ו 3 בסדר המתאים.

![[Pasted image 20220624135235.png]]
![[Pasted image 20220624135244.png]]

נתבונן במשחק לדוגמה עבור 5 ילדים ו ושהחסם העליון הוא 2 

![[Pasted image 20220624154022.png]]

בגלל שאנחנו יודעים שלא משנה מה ערכו של $k$ תמיד יושמט ילד , אז אין חשיבות בכלל לערכו של $k$ בשביל חישוב הריצה זה תמיד יהיה $O(k\cdot n)$. זאת כיוון שלכל מהלך שנבצע ומספר ההזות שנזיז תמיד מישהו יוצא מהמשחק. כל מהלך אנחנו מבצעים  $i\leq k$ פעולות ונבצע זאת $n$ פעמים. הסיבה שאנחנו משאירים את $k$ ולא חוסמים ב $n$ ישירות היא ש $k$ יכול להיות יותר גדול מ $n$ ואז זמן הריצה יהיה גדול בהרבה.
  
זה הקוד עבור $circularLinkedList$ : 

```ad-Code
```java

public int findTheWinner(int n, int k) {
 CircularLinkedList circularGame = new CircularLinkedList(n);         
   int count = k;
    CircularLinkedList.Node currentNode=circularGame.head();
    while (circularGame.hasNotRemainedOne()) {
	 CircularLinkedList.Node kNode = 
       circularGame.incrementWithSteps(currentNode, count);
       currentNode = kNode.next;
       circularGame.remove(kNode);
     }
     return circularGame.head().value;
    }

```

במקרה של מערך נתנהל באותו אופן רק שהפעם יהיה בעייתי להסיר איברים לכן נוסיף $flag$ בוליאני שיקבע האם הבן אדם במשחק או לא. סך הכל זמן הריצה יהיה זהה 

```ad-Code
```java

  public int findTheWinner(int n, int k) {
    // true if i-th friend is left
    boolean[] friends = new boolean[n];
    int friendCount = n;
    int fp = n; // friends' pointer
    while (friendCount > 1) {
      for (int i = 0; i < k; ++i, ++fp)
        while (friends[fp % n]) 
          ++fp;                 
      friends[(fp - 1) % n] = true;
      --friendCount;
    }
    for (winnerIndex = 0; friends[winnerIndex]; 
     ++winnerIndex);
    return winnerIndex + 1;
  }

```

מבחינת זמן הריצה בין שני הפעולות אין שינוי עם זאת, חשוב לשים לב שבעבודה עם מערך אנחנו מעולם לא מקטינים אותו כמו ברשימה מעגלית. לכן בחסמים מאוד גדולים אנחנו נבצע יותר פעולות.


![[Pasted image 20220624163524.png]]
חשוב לשים לב שיש לנו sentinel element כלומר פוינטר התחלתי שיצביע לתחילת הרשימה תמיד.

__insert__ : 
 אם הרשימה ריקה פשוט הnode יצביע על עצמו משני הכיוונים וה start יצביע על node גם כן. במצב בוא הרשימה לא ריקה אנחנו נלך ל $prevNode$ של האיבר הראשון (ככה נגיע לאיבר האחרון ישר) ואחריו נשים את האיבר החדש שנכנס 

```ad-Code
```cpp

void insertEnd(struct Node** start, int value)
{
	if (*start == NULL)	{
		struct Node* new_node = new Node;
		new_node->data = value;
		new_node->next = new_node->prev = new_node;
		*start = new_node;
		return;
	}
	
	Node *last = (*start)->prev;
	struct Node* new_node = new Node;
	new_node->data = value;
	new_node->next = *start;
	(*start)->prev = new_node;
	new_node->prev = last;
	last->next = new_node;
}

```

ובאופן ויזואלי :

__אם ריק__ 
![[Pasted image 20220624164916.png]]

__אם לא ריק__ 

![[Pasted image 20220624164939.png]]

__deletion__ :
אם הרשימה ריקה כולל start , פשוט מחזירים null .
אחרת מחזיקים שני פוינטרים אחד לראש המעגל ואחד נוסף שבינתיים יהיה null.
נזוז על גבי הרשימה עד שנמצא את האיבר שאותו נרצה להסיר עם הפוינטר הראשון כאשר כל איטרציה נבצע השמה של הפוינטר הראשון לפוינטר השני .
אם מצאנו את האיבר שלנו נבדוק שהוא לא היחיד ברשימה (הוא היחיד אם הוא גם הקודם וההבא בתור של עצמו). במידה והוא האיבר היחיד נגדיר ש start=null וסיימנו.
כעת נבדוק מספר דברים
* האם האיבר שאנחנו עומדים עליו הוא האיבר הראשון - אם כן נזיז את המצביע השני לקודמו והוא יצביע לסוף . ונשנה בהתאם את ערכי המצביעים : 
start.next = start.next.next וגם נשנה את ההצבעות באיבר האחרון 

* אם הוא האיבר האחרון אז נזיז את המצביע השני להתחלה ונשנה כמו למעלה רק על המצביעים ההפוכים.

* בכל מקרה אחר המעגל לא מורגש ולכן ננהל את זה כמו רשימה מקושרת דו כיוונית רגילה.

```ad-Code 
```c
void deleteNode(struct Node** start, int key)
{
	// If list is empty
	if (*start == NULL)
		return;

	// Find the required node
	// Declare two pointers and initialize them
	struct Node *curr = *start, *prev_1 = NULL;
	while (curr->data != key) {
		// If node is not present in the list
		if (curr->next == *start) {
			return;
		}

		prev_1 = curr;
		curr = curr->next;
	}

	// Check if node is the only node in list
	if (curr->next == *start && prev_1 == NULL) {
		(*start) = NULL;
		free(curr);
		return;
	}

	// If list has more than one node,
	// check if it is the first node
	if (curr == *start) {
		// Move prev_1 to last node
		prev_1 = (*start)->prev;

		// Move start ahead
		*start = (*start)->next;

		// Adjust the pointers of prev_1 and start node
		prev_1->next = *start;
		(*start)->prev = prev_1;
		free(curr);
	}

	// check if it is the last node
	else if (curr->next == *start) {
		// Adjust the pointers of prev_1 and start node
		prev_1->next = *start;
		(*start)->prev = prev_1;
		free(curr);
	}
	else {
		// create new pointer, points to next of curr node
		struct Node* temp = curr->next;

		// Adjust the pointers of prev_1 and temp node
		prev_1->next = temp;
		temp->prev = prev_1;
		free(curr);
	}
}


```

![[Pasted image 20220624171436.png]]
(a) : 
$$n^{2}-n\geq\frac{1}{2}n^{2}=n^{2}-\frac{1}{2}n^{2}$$
על מנת שהנ״ל יתקיים נצטרך ש 
$$n<\frac{1}{2}n^{2}=n\cdot\frac{1}{2}n$$
כיוון ש$n$ הוא מספר טבעי הנ״ל יתקיים לכל $n$ שגדול מ1 .ולכן 
$$\exists_{n_{0}=1,C=\frac{1}{2}}\forall_{n>n_{0}}:n^{2}-n>Cn^{2}$$
לכן אנחנו מקיימים את ההגדרה $n^{2}-n\in\Omega(n^{2})$ .

(b) : 
$$\displaylines{
\log(n)+\cos(n)\leq \log(n)+1=\log(n)+\log(2)<2\log(n)
}$$
המעבר האחרון נכון לכל $n>2$ . לכן חסום מלמעלה על ידי $logn$
 
באופן דומה נבצע על החסם התחתון של קוסינוס שהוא $-1$ ונקבל שהוא חסום למטה על ידי $logn$ . סך הכל פונקצייה זו מהווה חסם הדוק.


![[Pasted image 20220624182112.png]]
* נסמן $n=2^m$
$$T(2^{m})=T(2^\frac{m}{2})+1$$ כעת נגדיר $S(m)=T(2^{m})$ ונקבל :

$$S(m)=S(\frac{m}{2})+1$$
בעצם קיבלנו ש $T(n)=S(m)\in O(log(m))=O(\log(\log(n)))$

*  סעיף ב יהיה -  $f(n)=2^\sqrt{logn}$ 
(ג זה נושא שלא למדנו)


# עצים כלליים ובינארים
בפרק הקודם דיברנו על מבני הנתונים הליניאריים - יש להם יתרונות רבים, עם זאת , הבעיה הכי גדולה שלהם היא שתמיד נצטרך לבחור בין היכולת לחפש ביעילות, לבין היכולת לגשת למידע ולעדכן מידע במהירות. ברוב המקרים תהיה התנגשות בין השניים. המגבלה הזאת שלכל record יש רק איבר אחד הבא אחריו יכולה להיות יתרון ומגבלה גדולה. בשביל זה עצים נכנסים לתמונה והם יאפשרו לנו להגיד מבני נתונים שלא מגבילים אותנו מהבחינה הזו. 

__הגדרה__ : עץ במונחים של מבנה נתונים (בתורת הגרפים יכול להיות מוגדר אחרת) הוא אוסף של אלמנטים הנקראים $nodes$ שמקיימים -
* יש אלמנט הנקרא $root$ 
* כל מי שאינו ה $root$ בעץ יכול להיות ה $root$ בתת עץ משלו או חלק מתת עץ אחר. במילים אחרות אם ניקח תת קבוצה של הקבוצה שלנו בלי ה $root$ ואפשר גם בלי אלמנטים נוספים, נקבל עץ .

![[Pasted image 20220624190014.png]]
לדוגמא, 2 במקרה זה הוא שורש העץ אבל אם ניקח את הקבוצה ת 7,10,11,6 נקבל עץ גם כן. אחת הדוגמאות מוכרות של עצים היא ה [DOM](https://he.wikipedia.org/wiki/Document_Object_Model) שזה אובייקט שמתאר את תגיות ה$html$ שאיתם בונים אתרים. 

למעשה כמעט כל מבנה נתונים ליניארי יכול להחשב כעץ שלכל עץ יש ילד אחד.

__טרמינולוגיה חשובה בעצים__
* השורש - ה node העליון ביותר (ללא אבא)
* node/צומת - קודקוד בעץ - יכול להכיל data כלשהו ובנוסף מחזיק בתוכו מצביע לילדים שלו (לפי סוג העץ נקבע כמה ילדים יש לו אבל בעץ כללי אין מגבלה).
* ילד- קודקוד שיש לו אבא
* קשת- חיבור בין בני קודקודים 
* עלה- קודקוד שאין לו ילדים 
* גובה- המרחק הארוך ביותר בין שורש לעלה
* עומק / רמה - המרחק בין קודקוד כלשהו לשורש העץ. (נשים לב שעומק תלוי ב node שבוא אני נמצא)
* שכנים/קרובים - כל הקודקודים שיש להם אבא משותף.

__הגדרות בסיס__ 
* לעץ כללי יש לפחות קודקוד אחד 
* עץ עם קודקוד יחיד (שורש בלי ילדים) , גובהו $0$.

![[Pasted image 20220624193720.png]]
בעצים שיטת הסריקה המומלצת ביותר היא על ידי ריקורסיה כמו כן , עץ הוא [מבנה נתונים מופשט](https://en.wikipedia.org/wiki/Abstract_data_type) וניתן לממשו בשיטות רבות ומגוונות (אולי כאלו שגם לא דורשים סריקה ריקורסיבית). השיטה הקלאסית למימוש עץ היא על ידי אובייקט $node$ שמכיל מידע ומערך לילדים שלו.

באופו כללי ניתן להסתכל על עץ באופן הריקורסיבי הבא :
![[Pasted image 20220624193849.png]]

## עץ בינארי 
__הגדרה:__ עץ בינארי הוא אוסף המקיים את התכונות הבאות 
* או שהוא ריק 
* אם לא ריק , השורש מכיל שני תתי עצים שהם בעצמם עצים בינאריים . 
במילים אחרון לכל אב יש שני בנים לכל היותר. 

נשים לב שעץ בינארי הוא לא מקרה פרטי של עץ כיוון שהקבוצה הריקה היא יכולה להיות העץ הבינארי הריק בעוד שבעץ כללי חייב שיהיה לפחות שורש.
__העץ הריק הוא עץ ללא שורש וללא קודקודים וגובהו מסומן כ $-1$ .__


### מעצים כלליים לעצים בינאריים 
ניקח ״יער״ מסודר שזה בעצם אוסף של עצים כלליים.. ניתן להמיר יער סדור (אוסף של עצים כללים שמוגדר עליהם יחס סדר כלשהו) לעץ בינארי על ידי פונקצייה חח״ע כלומר שלכל עץ יער יש עץ בינארי שקול .

הפונקצייה תעבוד באופן הבא : יהי $T$ עץ בינארי ו $F$ יער סדור.
* השורש של $T$  יהיה השורש של העץ השמאלי ביותר ביער $F$ . 
* הילד שמאלי של קודקוד $v$ ב $T$ יהיה הילד השמאלי __(אם יש ילד אחד אז הוא אוטומטי שמאלי, כי אין פה יחס סדר עדיין על האיברים בעץ)__ של אותו הקודקוד ביער. הילד הימני יהיה השכן המיידי מצד ימין של $v$ ב $F$ אם יש כזה (אם אין אז אין ילד ימני). השורשים של היער הם מקרה מיוחד והם נחשבים שכנים אחד של השני.

בצורה ויזואלית - 

![[Pasted image 20220624220444.png]]

__אנקדוטה__ דיברנו על כך ניתן לייצג יער כעץ בינארי עם שימוש בפונקצייה הפיכה, נוכל לקבוע משהו יותר חזק מזה, בהינתן $n+1$ קודקודים נוכל לדעת בידיוק כמה יערות וכמה עצים בינאריים ניתן לבנות מיער זה. לשם כך נגדיר שעץ $T$ עם שורש $R$ ו $k$ תתי עצים יסומן כך : 
$$(RT_{1}T_{2}\dots{T_{k}})$$
זאת הגדרה ריקורסיבית ולכן נפתח סוגריים על כל תת עץ של תת עץ וכן הלאה... למשל עבור העץ הבא 

![[Pasted image 20220624224434.png]]

הסידור יהיה
$$\bigg(\big( 3\ (2)\ (4)\big)\big(9\big)\big(10\ (8\ (7))\big)\bigg)$$
 למעשה נוכל להגדיר את זה גם בלי ערכים כלל , אם מעוניינים רק במבנה העץ.
 $$\bigg(\big( \ ()\ ()\big)\big(\big)\big(\ (\ ())\big)\bigg)$$
	לא נפרט את ההוכחה המלאה אבל ראינו משהו דומה , [מספר קטלן](https://he.wikipedia.org/wiki/%D7%9E%D7%A1%D7%A4%D7%A8_%D7%A7%D7%98%D7%9C%D7%9F) יכולים להגדיר לנו בידיוק כמה סוגריים כאלה ניתן לשים על $n$ ערכים שונים. לכן יש סך הכל : 
	$$\frac{1}{n+1}\binom{2n}{n}$$
	אפשרויות ליצור יערות מ $n$ קודקודים שונים.
	

### תכונות העצים הבינאריים
נדבר על שיטות הסריקה של עץ בינארי. מטרת הסריקה יכולה להיות שונה ולכן בחירת שיטת הסריקה תהיה קשורה למטרה שלשמה רוצים לסרוק : 

##### סריקות DFS (חיפוש עומק)
__pre-order__ - עבור כל צומת  נדפיס את ערכו , לאחר מכן נעבור לבנו השמאלי של העץ, לבסוף נלך לבנו הימני. 
__in-order__ - עבור כל צומת יש להדפיס תחילה את הבן השמאלי, לאחר מכן לעבור לערכו שלו ולבסוף לבן הימני. 
__post-order__ - עבור כל צומת יש להדפיס את הבן השמאלי, לאחר מכן את הבן הימני ולבסוף את ערך הצומת עצמו.

__נשים לב שזאת סריקה ריקורסיבית לכן, למשל, בסריקת in-order אנחנו נמשיך לרדת בצמתים כל עוד יש בן שמאלי ורק אז נעלה למעלה__ .

```ad-Code
```cpp
struct Node{
    int data;
    Node *left, *right;
};
void preOrderPrint(Node *root)
{
  print(root->name);                                  //record root
  if (root->left != NULL) preOrderPrint(root->left);  //traverse left if exists
  if (root->right != NULL) preOrderPrint(root->right);//traverse right if exists
}

void inOrderPrint(Node *root)
{
  if (root.left != NULL) inOrderPrint(root->left);   //traverse left if exists
  print(root->name);                                 //record root
  if (root.right != NULL) inOrderPrint(root->right); //traverse right if exists
}

void postOrderPrint(Node *root)
{
  if (root->left != NULL) postOrderPrint(root->left);  //traverse left if exists
  if (root->right != NULL) postOrderPrint(root->right);//traverse right if exists
  print(root->name);                                   //record root
}
```
__חשוב מאוד__ סריקת $pre order$ וגם $post order$ מאפשרת לנו לשחזר את העץ במדוייק אם העץ הוא עץ חיפוש בינארי (נפרט בהמשך). כמו כן בהינתן סריקת $inorder$ ו וכל סריקה אחרת, גם כן ניתן לשחזר את העץ גם אם אינו עץ חיפוש ($in$ ייתן לנו את תתי העצים בעוד ש $post$ ייתן לנו את השורשים).

##### סריקות BFS (חיפוש רוחב)
נשתמש בתוך כדי לסרוק את האיברים בעץ , קומה קומה 
כל קומה נכניס איברים לתור ונדפיס אותם , מיד לאחר הדפסה נוציא אותם מהתור ונכניס את האיברים הבאים בקומה... נמשיך ככה עד שנגיע לעלים .

```ad-Code
```cpp
void printLevelOrder(Node* root)
{
	if (root == NULL)
		return;
	queue<Node*> q;
	q.push(root);

	while (q.empty() == false) {
		// Print front of queue and remove it from queue
		Node* node = q.front();
		cout << node->data << " ";
		q.pop();

		if (node->left != NULL)
			q.push(node->left);
		if (node->right != NULL)
			q.push(node->right);
	}
}

```

#### עץ בינרי שלם  complete binary tree
עץ המכיל איבר יחיד או מכיל שורש ושתי תתי עצים שהם בעצמם עץ בינארי שלם. במילים אחרות, זה עץ שלכל קודקוד יש או 0 בנים, או 2 בנים .
![[Pasted image 20220625105510.png]]

ההגדרה הריקורסיבית הזו מופשטת ומאפשרת לנו ״להפריט״ אותה למבנים אחרים , למשל נוכל להשתמש בה כדי לייצר ביטויים אריתמטיים המכילים אופרטים בינאריים. במבנה של עץ בינארי שלם נוכל להגדיר ביטוי אריתמטי כעץ כזה שלכל קודקוד יכול להיות משתנה (orpand) או אופרטור שלו יש שני ילדים או שני תתי עצים שהם בעצם ביטויים אריתמטיים . ויזואלית: 
![[Pasted image 20220625110051.png]]
זה בעצם הביטוי 
$$(a-b)\times(c\uparrow{d/e})$$
נזכיר ש $\uparrow$ זה העלאה בחזקה.

יותר מזה צורות הסריקה השונות יביאו לנו את הביטויים האלה בצורת $prefix$ $infix$ $postfix$ של הביטויים.
![[Pasted image 20220625110251.png]]

#### עץ בינארי כמעט מלא / כמעט שלם 
הטרמינולוגיה קצת מבלבלת אבל עץ בינארי כמעט שלם (אני מעדיף לקרוא לו כמעט מלא) הוא עץ שלם שכל העלים הם ברמה $h$ או ברמה $h-1$ (כאשר $h$ זה גובה העץ). וכל העלים ברמה $h$ נמצאים בצד השמאלי ביותר של העץ (זה יכול לגלוש לתת העץ הימני גם).

אפשר להגדיר את זה גם באופן הבא: 
* לכל קודקוד (צומת) ברמה $h-2$  יש בוודאות שני בנים 
* ברמה $h-1$ אם יש קודקוד שיש לנו שני בנים, גם לשכן שלו יש שני בנים.
* ברמה $h-1$ אם יש קודקוד שיש לו בן אחד , אז הוא שמאלי ולכל הקודוקדים משמאלו יש שני בנים.

![[Pasted image 20220627004708.png]]
  
#### עץ בינארי מלא full binary tree
זה עץ שבוא לכל הצמתי מלבד העלים יש שני בנים בידיוק והעלים כולם נמצאים באותה רמה. (מקרה פרטי של עץ בינארי שלם).

![[Pasted image 20220625110721.png]]

#### עץ חיפוש מאוזן 
משפחה של עצים תקרא מאוזנת אם לכל עץ במשפחה המכיל $n$ קודקודים, גובהו יהיה חסום ב $O(logn)$ . (בכוונה מגדירים על משפחה כי רוצים שכל העצים יהיו חסומים באותו קבוע).

__נשים לב ההגדרות המדוייקות יכולות להשתנות במקומות מסויימים שבוא אתם צורכים את הידע שלהם , עם זאת התכונות יישארו אותם תכונות__. 

#### הוכחות בעצים
בגלל המבנה הריקורסיבי של עץ בינארי , את רוב ההוכחות המתמטיות על עצים נוכל ונרצה להוכיח באינדוקציה, הרבה הוכחות נוכל לעשות באינדוקצייה שבסיסה הוא מספר הקודקודים , מספר העלים , העומק וכו... אלטרנטיבה תהיה לבצע אינדוקצייה על __מבנה העץ עצמו__ . כלומר על תתי העצים (כפי שהגדרנו עץ בינארי שילדיו הם עצים בינאריים בעצמם). באופן הזה, נוכל בעצם להתחמק מלהראות תכונות מסויימים כל קודקודים, קשתות, וכו. 

__משפטים__ 
* __בעץ בינארי שלם עם $n\geq{1}$ עלים, יש $n-1$ קודקודים פנימיים (קודקוד פנימי זה כל קודקוד שהוא לא עלה כולל השורש)__.
הוכחה: 
הבסיס יהיה פשוט בכל מקרה, אם יש קודקוד אחד הוא שורש ועם 0 קודקודים פנימיים.
נוכל להוכיח באינדוקצייה על מספר העלים ובהנחת האינדוקצייה נתחיל להתסבך, לכן נעשה אינדוקציה על מבנה העץ. 

בצעד האינדוקציה , נרצה להניח שהטענה מתקיימת על עצים עם $k-1$ עלים ונוכיח על עץ עם $k$ עלים.
נסתכל על השורש ונסמן את תתי העצים כ $T_{L},T_{R}$ . כיוון שהעץ שלם אנחנו יודעים שיש שני תתי עצים כאלה (אם היה רק אחד זה היה בסתירה להגדרה והיינו נשארים רק עם השורש). כיוון שההגדרה היא שגם תתי העצים עצמם הם עצים בינארים שלמים, לכל אחד מהם יש לפחות עלה אחד. 
נסמן את מספר העלים של כל תת עץ כזה כ $k_L$ ו $k_{R}$ (אנחנו יודעים ששניהם גדולים או שווים ל1 ולכן כל אחד מהם בנפרד קטן ממש מ $k$) ואנחנו יודעים שמתקיים 
$$k=k_{R}+k_{L}$$
מספר הקודקודים הפנימיים בכל תת עץ כזה, לפי הנחת האינדוקצייה יהיה $k_{R,L}-1$ בהתאמה, סך הכל נקבל שמספר הקודקודים הפנימיים בעץ הגדול הוא 
$$k_{R}-1+k_{L}-1+1=k-1$$
(ההוספה של האחד היא בגלל שסופרים את השורש של העץ הגדול שלא שייך לתתי העצים בספירה). 


* עץ בינארי עם עומקי עלים $l_{i}:i\in[n]$ ($n$ עלים וכל עלה יש עומק שלו , לאו דווקא שונים) יהיה עץ שלם __אם ורק אם__ מתקיים $\sum\limits_{i=1}^{n}2^{-l_{i}}=1$ . (אם זה קטן מאחד נקבל עץ לא שלם, אם זה גדול מ1 נקבל שאנחנו לא עובדים עם עץ).

נוכיח באינדוקצייה על מבנה העץ : 
בבסיס אם $n=1$ אז כפי שהגדרנו הגובה של שורש הוא $0$ ונקבל $2^{0}=1$.
בצעד נסתכל על תתי העצים ונסמן שבתת העץ השמאלי יש $k$ עלים וניתן להם את האינדקסים $[k]$ . ובתת העץ הימני יש $k+1,....,n$ עלים. כמו כן נגדיר את הגובה של העלה ה$i$ בתת העץ המתאים לו כ $d_{i}=l_{i}-1$ סך הכל יתקיים מהנחת האינדוקצייה השלמה על מבנה העץ.

$$\displaylines{
\sum\limits_{i=1}^{n}2^{-l_{i}}=\sum\limits_{i=1}^{k}2^{-l_{i}}+\sum\limits_{i=k+1}^{n}2^{-l_{i}}=\\
\sum\limits_{i=1}^{k}2^{-d_{i}-1}+\sum\limits_{i=k+1}^{n}2^{-d_{i}-1}=\\
\frac{1}{2}\sum\limits_{i=1}^{k}2^{-d_{i}}+\frac{1}{2}\sum\limits_{i=k+1}^{n}2^{-d_{i}}=\frac{1}{2}+\frac{1}{2}=1
}$$
המעבר האחרון נובע כי זה בידיוק הנחת האינדוקצייה, על תתי העצים האלה.

__אפשר לנסח את המשפט גם באופן הבא: בעץ בינארי שלם עם $n$ קודקודים יש $\lceil\frac{n}{2}\rceil$ עלים. כמו כן המשפט נכון גם לעצים מלאים ,מאוזנים וכמעט מלאים__

__משפטים נוספים (בלי הוכחה)__ 
* בעץ בינארי מלא בכל רמה $i$ יש $2^i$ קודקודים.
וסה״כ בעץ בינארי מלא יש $2^{h}-1$ קודקודים (כי עולים עד $logn$ ואז זה סדרה חשבונית פשוטה). כאשר הגובה זה $k+1$ כאשר k זאת הרמה הנמוכה ביותר בעץ, נזכיר שמתחילים מ 0.

## עץ חיפוש בינארי 
עד עכשיו דיברנו על עץ בינארי ברמה המופשטת שלו, אבל לא ממש הגדרנו איך אנחנו מסדרים את האיברים בתוך המבנה הזה. בשיטה זו אנחנו מכניסים את ה records לעץ בהתאם לערכיהם ויחס הסדר המוגדר על האיברים. וניתן לזהות את האיבר לפי ערכו. 

![[Pasted image 20220625131737.png]]

__הגדרה__ : בעץ חיפוש בינארי על כל node עם ערך $v$ הערכים בתת העץ השמאלי של קודקוד זה יהיו קטנים מ $v$ והערכים בתת העץ הימני יהיו גדולים יותר.

### חיפוש 
החיפוש מתחיל בשורש, אם האלמנט לא נמצא שם נבדוק האם הערך קטן יותר או גדול מהשורש או מהקודקוד עליו אנחנו נמצאים, לאחר מכן באופן ריקורסיבי נרד בתת העץ המתאים עד שנגיע לעלה (הילד הימני והשמאלי של עלה יהיה null ואם נגיע למצב הזה נדע שלא מצאנו את האיבר שאנחנו מחפשים בתת עץ זה). את מתודת החיפוש ניתן לבנות באופן כזה שאנחנו נותנים מצביע לתחילת העץ או תת העץ אותו נרצה לבדוק (לרוב זה יהיה השורש). 

בפסודו: 

![[Pasted image 20220625132420.png]]
נשים לב שאנחנו מחזירים שלישייה סדורה, שמגידרה האם מצאנו או לא מצאנו את האיבר , מצביע לאותו קודקוד ומיקום בעץ הכולל (האם זה עץ ימני או שמאלי).

קשה לדבר על זמני ריצה בעצי חיפוש בינאריים, זאת כיוון שבהתאם לסוג העץ זמני הריצה משתנים אבל כשאין מגבלות על העץ זה חסום במספר האיברים בעץ במקרה הגרוע. 

### הכנסה
כדי להכניס ערך מסויים יש לבדוק שהוא לא קיים בעץ קודם, אם לא מצאנו אנחנו נקבל מצביע לעלה בו נצטרך להכניס אותו ובאיזה צד הוא אמור להכנס. זה בידיוק המידע שאנחנו צריכים כדי לבצע הכנסה בזמן קבוע : 

![[Pasted image 20220625140127.png]]

במילים מה שקורה בקוד הוא ששאילת החיפוש תחזיר flag אם הערך נמצא או לא, במידה ולא אנחנו אמורים לקבל מצביע לעלה $R$ שמתחתיו נצטרך לשים את העלה, את הצד היה ניתן לבדוק בזמן קבוע גם כן אבל כבר קיבלנו אותו בשאילתת החיפוש אז נשתמש בו. לפיכך גם ההכנסה חסומה ב מספר הקודקודים.

## מחיקה 
השאילתה המעניינת היא שאילתת המחיקה , במבני הנתונים הליניאריים היחס בין הכנסה להוצאה היה די סימטרי (גם בקוד לא היה הרבה שוני). המצב שונה בעצי חיפוש בינאריים כיוון שיש מספר מקרים שצריך לקחת בחשבון .  נדגים ויזואלית על העץ הזה מהתמונה למעלה: 
![[Pasted image 20220625131737.png]]
* השלב הראשון, בדיקה שהאיבר נמצא במידה וכן נבדוק את המקרים הבאים.
* אם הוא עלה, צריך רק לשחרר אותו מהזכרון ולהחליף את ערכו ב null. (למשל נרצה למחוק את 52).
![[Pasted image 20220625141523.png]]
* אם לקודקוד שנרצה למחוק יש ילד אחד, המחיקה תתבצע בדומה לרשימה מקושרת, נקשר בין האבא לילד ונעיף את הקודקוד המחבר מהעץ. למשל נמחק את הקודקודים הפנימיים עם ילד אחד : 4,17
![[Pasted image 20220625141649.png]]

* אם לקודקוד שנרצה למחוק יש שני ילדים , זה המקרה המסובך יותר כיוון שלאותו קודקוד יש מצביע אחד לאבא ושני מצביעים מתחתיו , קישור שלהם ישירות לאבא יכול לשבש את העץ. הפתרון הוא פשוט , לא נמחק את הקודקוד עצמו אלא נחליף את ערכו בערך של האיבר השמאלי ביותר (הקטן ביותר) של תת העץ הימני של אותו קודקוד (כלומר, לצאת ימינה לתת העץ הימני , ומייד לאחר מכן ללכת הכי שמאלה שאפשר, אם אי אפשר פשוט לוקחים את השורש של תת העץ הימני) . __אם זה נשמע מוכר לכם, אז זה בידיוק ההדפסה של inorder שדיברנו עליה מקודם__ כלומר פשוט לקחת את האיבר הבא בהדפסת inorder ולשים את ערכו במקום האיבר שלנו. לבסוף מוחקים את הקודקוד שמייצג את האיבר הזה שהוא בוודאות שייך למקרה שיש לו ילד אחד או שהוא עלה (אחרת הוא לא היה השמאלי ביותר). 
![[Pasted image 20220625143149.png]]

__בדומה לרשימות מקושרות נוכל לטפל במקרה קצה שבוא מוחקים את השורש על ידי החזקת מצביע ללא ערך לשורש__ 


__אנדקודטה__ שחזור עצים בינאריים על ידי $inorder$ ו $postorder$ או על שחזור עץ חיפוש על ידי $preorder$ או $postorder$.
דיברנו על זה שבעצי חיפוש ההדפסות הללו יכולות לעזור לנו לשחזר את העץ במדויק במיפוי של 1:1 (כלומר יש רק עץ אחד בהינתן הצורות האלה שיקיים את זה), נראה איך : 

##### __post and in :__
בהינתן שתי התצוגות האלה נוכל לשחזר את העץ באופן הבא: 
* האיבר האחרון ב$post$ יהיה השורש
* נמצא את השורש ב $in$ וכעת אנחנו יודעים שכל האיברים ב $in$ מימין ל שורש הזה הם תת העץ הימני וכל מי שמשמאל יהיו האיברים בתת העץ השמאלי.
* ״משמיטים״ את האיבר שמצאנו משני ההדפסות, כעת מבצעים את אותו תהליך באופן ריקורסיבי על $in$ ו $post$ של תתי העצים. 

 __דוגמה__ 
 עבור ההדפסות 
```
in[]   = {4, 8, 2, 5, 1, 6, 3, 7}
post[] = {8, 4, 5, 2, 6, 7, 3, 1}
```
$1$ יהיה השורש. 
תת העץ השמאלי יהיה 
```
[5, 2, 8, 4]
```
ותת העץ הימני יהיה 
```
[6,3,7]
```
וההדפסות שלהם ב$post$ יהיו $6,7,3$  ו $8,4,5,2$ . 
__אני לא אדגים זאת בקוד אבל נוכל לאתר בקלות את ההדפסות post על ידי שימור באיבר הבא אחרי השורש ב. inorder. בדוגמה שלנו, ניקח את 6, נמצא אותו בpost וכל מי שמשמאלו חייב להיות בתת העץ השמאלי בצורת post.__ (הסברתי את זה כי אומנם ויזואלית קל לראות את זה אבל מבחינת קוד זה דורש קצת עבודה להפעיל את הקריאה הריקורסיבית על שתי ההדפסות האלו).

__חשוב לציין שאם מבקשים מאיתנו להמיר לעץ בינארי שלם על בסיס inorder 
בלבד, הדבר אפשרי, הפתרון יהיה למטה בתרגילים.__

##### __pre :__ 
בהדפסת $preorder$ נוכל לשחזר את עץ חיפוש גם כן באופן הבא: 
* האיבר הראשון הוא תמיד השורש
* כעת נמצא את האיבר הראשון בהדפסה שהוא יותר גדול מהשורש.
* כל האיברים מימינו כולל אותו הם תת העץ הימני, כל האיברים משמאלו הם תת העץ השמאלי.
* מפעילים את הפעולה באופו ריקורסיבי על שני תתי העצים

__על post זה יהיה הפוך__ 
```ad-Code
```c
node* constructTreeUtil(int pre[], int* preIndex, int low,int high, int size) {

	if (*preIndex >= size || low > high)
		return NULL;
	node* root = newNode(pre[*preIndex]);
	*preIndex = *preIndex + 1;
	
	if (low == high)
		return root;
	int i;
	for (i = low; i <= high; ++i)
		if (pre[i] > root->data)
			break;


	root->left = constructTreeUtil
	(pre, preIndex, *preIndex,i - 1, size);
	root->right
		= constructTreeUtil(pre, preIndex, i, high, size);

	return root;
}
```


### תרגילים עצים בינאריים וכלליים 
![[Pasted image 20220625151106.png]]
בהינתן 3 ערכים $x,y,z$ ללא יחס סדר, אנחנו יודעים שניתן להגדיר 5 יערות שונים עבור הערכים הללו (לפי מספרי קטלן וההוכחה למעלה ב[[#מעצים כלליים לעצים בינאריים]]) אנחנו גם יודעים שפונקציית המעבר מיער לעץ בינארי היא הפיכה ולכן יש סך הכל 5 עצים בינאריים מקבילים והם כלהלן : 
![[IMG_B8CCDA0FB534-1.jpeg|550]]

![[Pasted image 20220625153057.png]]
__יש פה טעות עם B__ אבל לפי התשובות הוא שורש העץ אז נשתמש בזה.

דיברנו כבר על האלגרותים ממש כדי לבצע את זה למעלה נעבור על זה בקצרה על הדוגמה הזאת: 

* השורש יהיה $B$ . וניתן לראות שאין לו תת עץ ימני ולכן נדלג ישר להבא בתור שהוא $H$. 
* תת העץ השמאלי של $H$ יהיה $G,L,F,I,K,A,C,N$ ב $in$ ותת העץ הימני יהיה $J,E,M,D$
*  נמצא את צורת $post$ של תתי העצים 
$L,F,G,K,C,N,A,I$  וגם $J,D,M,E$ 

* נבצע את התהליך הריקורסיבי שוב על שני תתי העצים ונקבל בסוף : 

![[Pasted image 20220625153835.png|450]]

__אם יש לי $pre$ ו $post$ אני לא בהכרח יכול למצוא את העץ במדוייק למשל:__
![[Pasted image 20220625154011.png]]
שתי העצים הללו יכילו את אותה הצורה של $pre$ ו $post$ כיוון שאין ילד שמאלי הולכים ישר לימני והפוך . הצורות יהיו $AB$ עבור pre ו $BA$ עבוד post .

![[Pasted image 20220625154143.png]]

נוכיח באינדוקצייה על מבנה העץ .
__בסיס__ : עץ שלם עם קודקוד 1 יהיה עם 0 ילדים שזה מקיים את המשוואה
__צעד__ : נניח נכונות עבור עץ בגובה של לכל היותר $k$ עלים ונוכיח עבור עץ עם $n+1$ 
יהיה $T$ עץ טרני שלם בגובה $k+1$.
מהגדרת העץ טרנרי שלם אנחנו יודעים בוודאות שיש לשורש של עץ זה שלושה תתי עצים טרניים בעצם, נסמנם $T_{1,2,3}$ בהתאמה. לכל תת עץ כזה יתקיים שיש לפחות קודקוד אחד. ונסמן את מספר העלים של כל אחד כ $n_{1,2,3}$ בהתאמה. יתקיים שמספר העלים של שלושתם שווה למספר העלים הכולל של העץ נסמנו $n$, וגם שכל אחד מהם בנפרד קטן ממספר העלים הכולל של העץ כי יש לפחות קודקוד אחד בכל תת עץ. כמו כן, שלושת העצים האלה הם בגובה הקטן מ $k$ לכן הנחת האינדוקצייה תקפה עליהם. נסמן את מספר הקודקודים הפנימיים של $T$ כ $s$ ויתקיים 
$$s=\frac{n_{1}-1+n_{2}-1+n_{3}-1}{2}+1=\frac{\sum\limits_{i=1}^{3}n_{i}-1}{2}=\frac{n-1}{2}$$
__כדרוש__ .


![[Pasted image 20220625162917.png]]

אפשר להסתכל על כל מספר כהדפסת $inorder$ של עץ בינארי (אני מניח שכל $A_{i}$ ממויין ואין כפילויות של ספרות). כעת אנחנו יכולים להתייחס לסדרה העצים הזאת כיער ואנחנו יודעים כבר ממספר קטלן שמספר האפשרויות לספר $n$ איברים ביער הוא מספר קטלן. עם זאת נשים לב שאנחנו לא צריכים לקחת את כל האפשרויות למשל לא נרצה לעטוף סוגריים כל מספר בנפרד חייב לעטוף לפחות 2 איברים בסוגריים ולכן על כל $n$ איברים נרצה להתייחס לזה כאילו אנחנו עובדים מול $n-1$ איברים. סה״כ נקבל
$$\frac{1}{n}\binom{2n-2}{n-1}$$   
נשים לב שמבחינת פתרון התרגיל, לעטוף $k\in[n]$ סדרות מספרים בסוגריים זה שקול ללסדר את $k$ העצים הבינאריים השקולים כעץ אחד. וזה בגלל שלא חשוב לנו הסדר הפנימי של העצים אז מתייחסים לכל עץ כאיבר בפני עצמו.

זה מספר המיזוגים שאפשר לעשות לסדרת המספרים הנ״ל.  __(ביקשו 10 אני לא אחשב את זה אבל פשוט תציבו ותקבלו תשובה)__ .

![[Pasted image 20220625175243.png]]
__נשים לב שמבקשים מאיתנו למזג לעץ בינארי מלא!__ לכן מספיק שנשיג צורת inorder של העץ הממוזג על מנת לבנות אותו כמו שצריך. 
כמו כן נשים לב שנחסכו בדיקות נוספות בגלל שנתון שכל איבר בעץ שונה לגמרי.

* ניקח את שני עצי החיפוש ונבנה מערכים ממויינים מערכיהם בצורת $inorder$.
* נמזג את שני המערכים באופן כזה שהמיון יישמר (פתרון בקוד למטה).
* כעת קיבלנו את העץ הממוזג החדש בצורת $inorder$.
* נשתמש באלגוריתם המרה של מערך ממויין לעץ בינארי שלם.

__מיזוג שני מערכים ממויינים__ 
```ad-Code 
```cpp

void mergeArrays(int arr1[], int arr2[], int n1,
							int n2, int arr3[])
{
	int i = 0, j = 0, k = 0;

	// Traverse both array
	while (i<n1 && j <n2)
	{
		// Check if current element of first
		// array is smaller than current element
		// of second array. If yes, store first
		// array element and increment first array
		// index. Otherwise do same with second array
		if (arr1[i] < arr2[j])
			arr3[k++] = arr1[i++];
		else
			arr3[k++] = arr2[j++];
	}

	// Store remaining elements of first array
	while (i < n1)
		arr3[k++] = arr1[i++];

	// Store remaining elements of second array
	while (j < n2)
		arr3[k++] = arr2[j++];
}
```
  סיבכויות זמן ריצה : O(n1 + n2)


__המרת מערך ממויין לעץ בינארי שלם__ (לא מלא)
```ad-Code
```cpp

TNode* sortedArrayToBST(int arr[],
						int start, int end)
{

	if (start > end)
	return NULL;

	/* Get the middle element and make it root */
	int mid = (start + end)/2;
	TNode *root = newNode(arr[mid]);

	/* Recursively construct the left subtree
	and make it left child of root */
	root->left = sortedArrayToBST(arr, start,
									mid - 1);

	/* Recursively construct the right subtree
	and make it right child of root */
	root->right = sortedArrayToBST(arr, mid + 1, end);

	return root;
}
```
סיבוכיות זמן ריצה $O(n)$


*מבחינת זמן ריצה כולל 

* בישביל הכנסה ל $inorder$ של שני המערכים נצטרך $O(k)+O(l)\in O(k+l)$ 
* בישביל המיזוג למערך גדול נצטרך גם כן $O(k)+O(l)\in O(k+l)$ 
* נצטרך $O(k+l)$ כדי להכניס לעץ בינארי שלם את האיברים לפי האלגוריתם המתואר למעלה.

__חשוב לציין__ בגלל הנתון על מספר הקודקודים אנחנו יודעים להגיד שמערך הממוזג יש $2^n$ איברים כלומר העץ הבינארי השלם שבנינו יהיה __מלא__ כי לפי האלגוריתם האמצע יהיה השורש ויש מספר זוגי של איברים במערך כלומר בהכרח יתקיים שהילדים של השורש יהיה האיברים במקום הרבע והשלושה רבעים וסה״כ בכל רמה $i$ יהיה $2^{i}$ ילדים. __כדרוש__.


## עצי AVL
עץ $AVL$ הוא אחד המימושים ל [self-balancing binary search tree](https://en.wikipedia.org/wiki/Self-balancing_binary_search_tree) שנועד לשמור על גובה העץ במספר מסויים כדי לייעל את זמן החיפוש הבינארי של עץ חיפוש בינארי. 
__(אמרנו שבמקרה הגרוע עץ בינארי יכול להיות פשוט רשימה מקושרת  ואז זמן החיפוש יהיה $O(n)$ כי גובה העץ הוא כמספר האיברים, ואומנם הסדר ממויין אבל אי אפשר לעשות חיפוש בינארי על מבני נתונים שמאוכלסים בזכרון בצורה מקושרת ולא רציפה, כפי שדיברנו למעלה, לא ניתן לגשת אליהם בזמן יעיל מספיק).__

אנחנו נלמד על סוגים של עצים מאוזנים בהמשך , אבל בגדול מטרתם כמו $AVL$ שתיכף נדבר גם עליו היא לשמור על גובה העץ חסום במספר מסויים על מנת לייעל את החיפוש וההכנסה. 

המימוש של $AVL$ ניתן לנו על ידי George adelson-velsky ו evgenii landis ומכאן גם שמו של העץ. 

__תזכורת__ : גובה העץ הוא בעצם מספר הרמות בעץ פחות 1 (לכן עבור קודקוד בלי ילדים גובה העץ הוא 0 ולא 1, אפשר להגדיר את זה גם כמרחק הגדול ביותר בין עלה לשורש, מרחק בעץ = מספר הקשתות בין קודקוד מסויים לשורש).


__הגדרת עץ AVL__ - עץ ייקרא עץ AVL אם הוא עץ בינארי ולכל קודקוד בעץ ההפרש בין גובה תת העץ הימני לתת העץ השמאלי בערך מוחלט הוא לכל היותר אחד.

$$\forall_{v\in T}:|d(T_{L(v)})-d(T_{R(v)})|\leq1$$
__הבחנה__ אם בעץ $AVL$ יש קודקוד עם ילד אחד, ילד זה הוא עלה בהכרח. 

דוגמאות לעץ $AVL$ תקין: 
![[Pasted image 20220625211738.png]]


דוגמה לעץ לא מאוזן : 
![[Pasted image 20220625211757.png]]
(איפה שהנקודה השחורה שם נשבר האיזון)

__משפט__ : העומק של עץ $AVL$ נסמנו $T$ עם $n$ קודקודים חסום בלוג של מספר הקודקודים , ליתר דיוק 
$$d(T)\leq1.4404\log(n+1)-1.33\in O(\log(n))$$

איך בכלל מוכיחים דבר כזה? אולי אינדוקציה על מספר הקודקודים? הבעיה היא שגובה העץ הוא מספר טבעי אבל הפעלת לוג על מספר הקודקודים לא תיתן לנו מספר טבעי ולכן אנחנו עלולים לקבל מספרים לא נכונים על ידי שימוש באינדוקצייה למשל על 1000 ו 1001 קודקודים נקבל את אותו גובה $12$ כשנעגל אותו למרות שבפועל נקבל מספרים שונים. 
כשרוצים להוכיח נכונות של פרמטר מסויים הרבה פעמים קל להוכיח את הפונקצייה ההפיכה על הפרמטר הנגדי בוא משתמשים 

__למת עזר__ : עץ $AVL$ בעל גובה $k$ ומספר קודקודים $n$ יקיים 
$$n\geq{a^{k}}\ \ \ \ where\ \ \ : a>1$$
כלומר יש יחס אקספוננציאלי בין מספר הקודקודים לעומק העץ . 

![[Pasted image 20220625213749.png]]

כלומר יש פונקצייה הפיכה בין השניים . 

בגלל שזאת פונקצייה הפיכה בין תכונות העץ נוכל להסתכל על הבעיה מזווית אחרת  ולהוכיח את למת העזר מה שיגרור באופן מיידי את הטענה המרכזית שלנו.

כעת, על הפרמטר הזה כן נוכל להוכיח באינדוקצייה .
נגדיר $N(k)$ שזה מספר הקודקודים בעץ $AVL$ מינימלי בגובה $k$ (מינימלי אומר שיש בו כמה שפחות קודקודים והוא עדיין avl ושומר על התכונות של עץ כזה והוא גם בגובה הדרוש).

__בסיס__ עבור $k=0$ יש רק עץ אחד בגובה $0$ וזה עץ עם שורש בלי עלים. לכן $1=N(0)$ . 
עבור $k=1$ צריך קודקוד אחד בעומק 0 ועוד קודקוד נוסף בעומק 1 , $2=N(1)$ .
עבור $k=2$ באותו אופן יתקיים $4=N(2)$ 

זה נראה כאילו היחס הוא $N(k)=2^{k}$ אבל זה לא המצב כי ב $k=3$ נקבל שמספר הקודקודים בעץ המינימלי הוא $7$.

באופן כללי, עבור עץ $AVL$ עם גובה $k$ גדול מ $2$ לפחות לאחת מתתי העץ שלו הינו בגובה $k-1$ מהגדרת $AVL$. __אבל__ בגלל שזה עץ מינימלי עם $N(k-1)$ קודקודים, הגובה של התת עץ השני חייב להיות בגובה $k-2$ (אם היה $k-1$) אז העץ לא היה מינימלי ... 
סה״כ כעת אנחנו יודעים שלעץ מינימלי מספר הקודקודים יקיים 
$N(k)=N(k-1)+N(k-2)+1$ בידיוק. (הוספנו אחד בגלל השורש).

__אנדקדוטה__ נסתכל על סדרת פיבונצי 
$$F(0)=0,F(1)=1\ \ \ F(i)=F(i-1)+F(i-2)\ \text{for: }i\geq2$$
ישנו מונח הנקרא יחס הזהב שאומר שכל שני איברים עוקבים בסדרה שואפים אליו , יחס זה הוא $1.618$ . [יחס הזהב](https://he.wikipedia.org/wiki/%D7%99%D7%97%D7%A1_%D7%94%D7%96%D7%94%D7%91) אני מציע לקרוא פה עוד על יחס הזהב אבל בפשוט יתקיים ששני איברים פיבונאצי מקיים את השיוויון המתואר ששיוויון זה הוא שורשי הפולינום , $x^{2}-x-1$ ולהם שני פתרונות החיובי זה יחס הזהב: 
$$\varphi=\frac{1+\sqrt{5}}{2}=1.618\ \ and \ \ \hat\varphi=\frac{1-\sqrt{5}}{2}=-0.618$$
ומתקיים 
$$F(i)=\frac{1}{\sqrt{5}}(\varphi^{i}-\ \hat\varphi^{i})$$
בגלל שהשורש השלישי קטן מאחד כשנעלה בחזקה גבוהה במיוחד הוא יהיה זניח (חשוב להמשך).

לא אפרט יותר מדי על המשך ההוכחה אך הקשר בין יש יחס בין עץ avl מינימלי בגובה $k$ לסדרת פיבונצי והוא: 

![[Pasted image 20220625222342.png]]

נשתמש בזה כדי לתאר קשר כללי : 
$$\displaylines{
N(k)= \\ N(k-1)+N(k-2)+1= \\ (F(k+2)-1)+(F(k+1)-1)+1=\\ F(k+3)-1
}$$
וכעת מהקירוב הנ״ל 
$$n\geq F(k+3)-1\approx\frac{1}{\sqrt{5}}\varphi^{k+3}-1$$ בעצם פה הוכחנו את מה שניסינו להוכיח בטענת עזר ומזה נוציא את הוכחת הטענה המקורית באופן הבא 

$$k+3\leq\log_{\varphi}(\sqrt{5}(n+1))$$
$$k\leq\log_{\varphi}(\sqrt{5}(n+1))-3\approx1.4404\log_2(n+1)-1.33$$
כאן דיברנו על עץ avl מינימלי ויתקיים שבמקרה הגרוע עומק של עץ סך הכל גדול יותר ב $44\%$ מהעץ במקרה הטוב ביותר. זה מרמז לנו שחיפוש בעץ מסוג זה הוא יעיל במיוחד ביחס לעצי חיפוש בינאריים שאין לנו הבטחה טובה כמו זו.

### הכנסה
עכשיו כשאנחנו יודע שההגבלות על עץ $AVL$ תורמות לנו מבחינת יעילות . אנחנו נרצה לדאוג מבחינת אלגוריתם ההכנסה שלנו לשמר את התכונות של עץ כזה כך שאם נרצה להכניס ערך חדש לעץ , כעת אין לנו חופש בחירה, נצטרך לעבוד טיפה כדי לאזן את העץ ולמקם את הקודקוד בידיוק במקום המתאים ככה שהעץ לא יאבד מאיזונו. 

אנחנו נרצה לדעת יותר מידע על כל קודקוד בעץ ולשם כך נגדיר פרמטר חדש לקודקוד . נקרא לו $BF(v)\rightarrow\text{Balance Factor of Node v}$ והוא יהיה שווה ל 
$$BF(v)=d(T_{R(v)})-d(T_{L(v)})$$
במילים זה ההפרש בין גובה תת העץ הימני לגובה תת העץ השמאלי ואנחנו יודעים 
$$BF(v)\in\{-1,0,1\}$$
מהגדרת עץ $AVL$ , כל קודקוד יקבל מאזן חיובי אם תת העץ הימני גבוה יותר , 0 אם הם שווים ומינוס אם תת העץ השמאלי גבוה יותר. בצורה ויזואלית זה ייראה כך 

![[Pasted image 20220625232929.png]]

נגדיר שאם המאזן הוא $0$ אז העץ מאוזן, אחרת הוא לא מאוזן עם נטייה בהתאם לסימן.

כמו כן נניח שעצי $AVL$ נבנים מ $0$ ולא ניתנת מהמרה מעץ שאינו $AVL$ לעץ כזה.

כיוון שעץ $AVL$ יורש מעץ בינארי הליך ההכנסה יתחיל זהה, אם נרצה להכניס ערך נתבונן במסלול שהוא היה אמור לעבור בהליך ההכנסה של עץ בינארי רגיל . למשל עבור העץ הנ״ל עם המספר 31, המסלול יהיה : 51 , 39 , 27 . כעת אנחנו יודעים שעבור קודקוד שלא שייך למסלול הזה כל תתי העץ שלו לא ישנו את המאזן כתוצאה מההכנסה. 
במילים אחרות , נרצה לבדוק את המאזן על הקודקודים שבמסלול ההכנסה. 
__נשאלת השאלה__ איך אנחנו נסרוק שגיאות לאחר שהגענו לקודקוד האחרון לפני הכנסה בעץ בינארי? הרי לקודקוד אין רפרנס לאביו בעץ... והתשובה פשוטה, נכניס את הקודקודים במסלול ההכנסה ל מחסנית $S$ . כמו כן, על כל איבר שנשמור במחסנית נשמור גם לאיזה כיוון אנחנו ממשיכים במסלול מהנקודה בה אנחנו נמצאים, למשל עבור המסלול דוגמה שלנו : $S = [(v_{20}, R), (v_{52}, L), (v_{39}, L), (v_{27}, R)]$ 

__(נשים לב, מבחינת מימוש בקוד לא בהכרח חייב להשתמש במחסנית, ניתן לממש את הקוד באופן ריקורסיבי כך שברגע שהכנסה מסתיימת נעלה למעלה בהירכייה ונקבל בחינם את המצביעים שעברנו במעלה הדרך , הכל תלוי באיך מימשנו הכנסה של עץ חיפוש בינארי) .__

משיטת ההכנסה של [[#עץ חיפוש בינארי]] אנחנו יודעים שהקודקוד שייכנס תמיד יהיה עלה. יתרה מכך, אם המאזן של קודקוד האבא שלו הוא 0 סימן שלפני ההכנסה אותו קודקוד אב היה עלה בעצמו.
נסמן את קודקוד האב כ $z$ , אנחנו היודעים שהכנסת קודקוד $v_{x}$ תשנה את מאזר העץ $T_z$ (תת העץ ששורשו הוא $z$). (למשל הכנסת הערך 15 לעץ שבתמונה למעלה תשנה את המעץ של $T_{17}$ וגם של $T_{12}$).

כעת נמשיך לעלות במחסנית ששם נשמר הנתיב שממנו באנו , 

* נרוץ על המחסנית ונעדכן את פרמטר המאזן של כל קודקוד במחסנית כל עוד המאזן לפני עדכון הוא $0$ היא תעדכן לפי הפרמטר הנוסף שנמצא במחסנית שמודיע על כיוון ההגעה. אחרי עדכון נוציא מהמחסנית את הקודקוד ונמשיך לקודקוד הבא עד ש: 

1) הגענו לשורש- זה אומר שמאזן כל העץ תקין נעדכן את המאזן של $T$ והוא עדיין שומר על התנאים של עץ $AVL$ . 
2) כשהגענו לעץ לא מאוזן מהצד שמתקן את האיזון, נסביר באמצעות דוגמה ,
 נניח שאנחנו מגיעים ל קודקוד $w$ שמאזנו יהיה $BF_{(w)}=-$ ואנחנו מגיעים לקודקוד מצד ימין שלו. במקרה זה (וגם במקרה ההפוך) המאזן של העץ חוזר להיות $0$ שזה מצב תקין . האיטרציה בשלב זה __יכולה לעצור__ ולא צריכה להמשיך לבדוק את שאר הקודקודים במחסנית כיוון שאם המאזן נהיה $0$ לא שינינו את הגובה של תת העץ $T_w$ ולכן כל מי שמעליו לא צריך לעבור איזון כי הוא עדיין עומד בתקן $AVL$ כמו מלפני.
3) כשהגענו לשורש לא מאוזן מהצד ה״כבד יותר״ כלומר, הצד שאם נכניס אליו עוד איבר האיזון יישבר עוד יותר. (למשל בדוגמה למעלה המאזן היה - לפני הכנסה לכן אם נכניס עוד קודקוד לתת העץ השמאלי, המאזן יהיה $-2$ , מצב שלא תואם את הגדרת העץ.).  מבחינה ויזואלית זה ייראה משהו כזה 
 ![[Pasted image 20220626110820.png]]

$T_\delta$ הינו תת העץ שאליו נכנס הקודקוד, ובקודקוד האבא שלו למעשה, נשבר האיזון.
__מסתבר, שהפעולות איזון שצריך לבצע שונות בהתאם לאיזה מתתי העץ של $\delta$ מכיל את הקודקוד החדש__ .
לצערנו הרב, נצטרך לעשות zoom-in פנימה לתוך העץ $T_\delta$ כדי להבין מה נשבר. 

__לפני שנחלק למקרים, אנחנו יודעים להגיב בוודאות ש המאזן לפני הכנסה של $\delta$ הוא 0, אם זה לא היה המצב היינו מבצעים את האיזון עוד לפני שהגענו ל $a$ ויוצאים בשלב הזה.

על מנת לסדר את האיזון נצטרך להבין עם איזה מקרה של ״שבירה״ אנחנו מתמודדים, היוצרים של $AVL$ , הציעו אלגוריתם הכולל 4 אפשרויות. :

1) __RRrotarion__ - זה קיצור של right-right והמשמעות היא שנוצר חוסר איזון משום שתת העץ הימני  $T_\delta$  של השורש $a$ גדול מתת העץ השמאלי של השורש $a$ , __ובנוסף__ תת העץ הימני של $T_\delta$ נסמנו $T_{r\delta}$  גדול מתת העץ השמאלי  $T_{l\delta}$ . 

![[Pasted image 20220626115449.png]]

2)  __LLrotarion__ - זה קיצור של left-left והמשמעות היא שנוצר חוסר איזון משום שתת העץ השמאלי  $T_\delta$  של השורש $a$ גדול מתת העץ הימני של השורש $a$ , __ובנוסף__ תת העץ השמאלי של $T_\delta$ נסמנו $T_{l\delta}$  גדול מתת העץ הימני  $T_{r\delta}$ . 

![[Pasted image 20220626115749.png|350]]


__את שני המקרים האלו ניתן לפתור על ידי רוטציה בין השורש לבין בנו הימני אם אנחנו ב RR , או בנו השמאלי במקרה שאנחנו ב LL באופן הבא: 

לדוגמה ,  אם $a$ הוא השורש ו $b$ הוא תת העץ השמאלי ויש הפרה מסוג $LL$ אז $b$ יהפוך להיות השורש, $a$ יהפוך להיות תת העץ הימני של $b$ , תת העץ הימני של $b$ יהפוך להיות תת העץ השמאלי של $a$ ,באופן דומה על הצד הימני.
נשמע קצת מבלבל, נדגים ויזואלית
__LL__ : 
![[Pasted image 20220626120750.png]]

__RR__ :
![[Pasted image 20220626122849.png]]


__נשים לב שתמיד אנחנו נרצה לאזן את העץ ולשחק עם המשקלים, כלומר תמיד תהיה החלפה של השורש באיזשהו אופן__ .


3) __LRrotation__- זה קיצור של left-right ומצב זה נוצר בגלל ש תת העץ השמאלי של השורש גדול מהימני, ובתוך תת העץ השמאלי עצמו, תת העץ הימני שלו גדול מתת העץ השמאלי שלו, לדוגמה : 

![[Pasted image 20220626123721.png]]

4) 3) __RLrotation__- זה קיצור של right-left ומצב זה נוצר בגלל ש תת העץ הימני של השורש גדול מהשמאלי, ובתוך תת העץ הימני עצמו, תת העץ השמאלי שלו גדול מתת העץ הימני שלו, לדוגמה : 
![[Pasted image 20220626124345.png]]

__שימו לב שזה לא משנה איפה בתת עץ של תת העץ הגדול יותר מכניסים את האיבר כי אין שם שבירה בשני המקרים__ 

את שני המקרים הללו ניתן לפתור על ידי רוטציה כפולה. הרוטצייה תעבוד ככה :

* RL - נבצע רוטציית $LL$ בתוך תת העץ הפנימי ולאחר מכן $RR$  על השורש עם בנו הימני. 
* LR- נבצע רוטציית $RR$ בתוך תת העץ הפנימי ולאחר מכן $LR$ על השורש עם בנו השמאלי

__לדוגמא__ : 
![[Pasted image 20220626130121.png]]

__באופן דומה עושים על $RL$ 

__ולסיכום__
ברגע שהכנסו קודקוד חדש בהכנסה כמו בעץ חיפוש רגיל, עולה במסלול שלנו ובודקים את המאזן , אם הוא $0$ משנים בהתאם למאיפה באנו וממשיכים, אם הוא שונה מ $0$ ובאנו מהמקום שמאזן את זה בחזרה, משנים ל$0$ וממשיכים, אם באנו ממקום שממשיך לשבור את האיזון, מבצעים את אחד האיזונים הנ״ל ויוצאים מהלולאה. 

```ad-Code
```cpp

// An AVL tree node
class Node
{
	public:
	int key;
	Node *left;
	Node *right;
	int height;
};

// A utility function to get the
// height of the tree
int height(Node *N)
{
	if (N == NULL)
		return 0;
	return N->height;
}

/* Helper function that allocates a
new node with the given key and
NULL left and right pointers. */
Node* newNode(int key)
{
	Node* node = new Node();
	node->key = key;
	node->left = NULL;
	node->right = NULL;
	node->height = 1; // new node is initially
					// added at leaf
	return(node);
}

// A utility function to right
// rotate subtree rooted with y
Node *rightRotate(Node *y)
{
	Node *x = y->left;
	Node *T2 = x->right;

	// Perform rotation
	x->right = y;
	y->left = T2;

	// Update heights
	y->height = max(height(y->left),
					height(y->right)) + 1;
	x->height = max(height(x->left),
					height(x->right)) + 1;

	// Return new root
	return x;
}

// A utility function to left
// rotate subtree rooted with x
Node *leftRotate(Node *x)
{
	Node *y = x->right;
	Node *T2 = y->left;

	// Perform rotation
	y->left = x;
	x->right = T2;

	// Update heights
	x->height = max(height(x->left),
					height(x->right)) + 1;
	y->height = max(height(y->left),
					height(y->right)) + 1;

	// Return new root
	return y;
}

// Get Balance factor of node N
int getBalance(Node *N)
{
	if (N == NULL)
		return 0;
	return height(N->left) - height(N->right);
}

// Recursive function to insert a key
// in the subtree rooted with node and
// returns the new root of the subtree.
Node* insert(Node* node, int key)
{
	/* 1. Perform the normal BST insertion */
	if (node == NULL)
		return(newNode(key));

	if (key < node->key)
		node->left = insert(node->left, key);
	else if (key > node->key)
		node->right = insert(node->right, key);
	else // Equal keys are not allowed in BST
		return node;

	/* 2. Update height of this ancestor node */
	node->height = 1 + max(height(node->left),
						height(node->right));

	/* 3. Get the balance factor of this ancestor
		node to check whether this node became
		unbalanced */
	int balance = getBalance(node);

	// If this node becomes unbalanced, then
	// there are 4 cases

	// Left Left Case
	if (balance > 1 && key < node->left->key)
		return rightRotate(node);

	// Right Right Case
	if (balance < -1 && key > node->right->key)
		return leftRotate(node);

	// Left Right Case
	if (balance > 1 && key > node->left->key)
	{
		node->left = leftRotate(node->left);
		return rightRotate(node);
	}

	// Right Left Case
	if (balance < -1 && key < node->right->key)
	{
		node->right = rightRotate(node->right);
		return leftRotate(node);
	}

	/* return the (unchanged) node pointer */
	return node;
}



```


__סיבוכיות__ הכנסה חסומה בגובה העץ שבמקרה הזה הוא חסום בלוג של מספר האיברים, כמו כן הפעולות היו נשמעות מורכבות אבל אפשר לראות בקוד שאלו פעולות הנעשות בזמן ריצה __קבוע__ . לכן סך הכל פעולת ההכנסה חסומה ב $O(logn)$ (גם אם נעשה את כל המסלול פעמיים זה עדיין יהיה פעמיים $logn$.)


### מחיקה 
כמו שדיברנו על [[#מחיקה]] בעץ חיפוש, זאת לא בהכרח פעולה סימטרית להכנסה כשמדובר בעץ. הכנסה תמיד מכניסה עלה אבל לא תמיד נרצה למחוק עלה. 
נניח שנרצה למחוק קודקוד $v_{x}$. נמחק אותו כפי שהיינו מוחקים אותו אם היינו עובדים בעץ חיפוש בינארי. 
כעת צריך לבדוק את המאזן בכל קודקוד במסלול ממנו באנו ולעדכן בהתאם, לא אפרט פה את הליך הבדיקה כי הוא זהה לנ״ל. ההבדל הוא שיש מקרים שמחיקת איברים תשנה את תהפוך עץ ממצב לא מאוזן תקין למצב מאוזן תקין , דבר שיגרום לגובה העץ לקטון ב 1 ולכן במצב זה צריך לבדוק גם את הקודקוד הבא ולא לעצור כמו שהיינו עושים בהכנסה. 

זה סך הכל ההבדל אך בדיקת מקדם האיזון וביצוע הרוטציות יהיה בידיוק אותו דבר. מבחינת פתרון ריקורסיבי זה סך הכל להוסיף עוד 2 שורות לאחר פעולת המחיקה .

לסיכום קצר, העקרון של הוצאה דומה להכנסה במקרה הזה, בדיקה המסלול מלמטה למעלה, אך תנאי העצירה מעט שונים , אם הקטנו את גובה העץ ב$1$ כתוצאה מהמחיקה מה שגרם לעץ במצב לא מאוזן להיות מאוזן יש צורך להמשיך לעלות בעץ עד למצב שבו , בכל מצב אחר כלומר מצב שבו מחקנו והפכנו עץ מאוזן לעץ לא מאוזן תקין או מצב שהעץ לא מאוזן ודורש תיקונים, ניתן לעצור את העלייה בעץ.
![[Screen Shot 2022-06-26 at 14.14.23.png]]

__הפתרון הריקורסיבי קצת פחות יעיל , למרות שחסומים באותו דבר, נבצע עוד פעולות במצב הריקורסיבי כי אין את תנאי העצירה שדיברתי עליהם, עם זאת, לפעמים עדיף קוד קריא מאשר קוד יעיל, בטח ובטח כשהפעולות חסומות באותו big O .__

__גם זמן הריצה של מחיקה הוא $O(logn)$
 
### תרגילים עצי AVL 
![[Pasted image 20220626142052.png]]

__מיותר לפרט פה את כל התהליך אבל התוצאה הסופית נראת כך__ 

![[Pasted image 20220626142439.png]]

הרוטציות : 
* בהכנסת 15 רוטציית $RR$ 
* הכנסת 6 רוטציית $LR$ 
* הכנת 35 רוטציית $RR$ 


![[Pasted image 20220626142852.png]]

נוכל להשתמש בעבודה הזאת כדי לקבוע ש 
$$\displaylines{
N(k-1)+N(k-2)>2N(k-2)>4N(k-4)>\dots2^{i}N(k-2{i})\\=2^\frac{k}{2}=\sqrt{2}^{k}=1.414^{k}
}$$
הסבר למעבר האחרון ,  מדובר במעין נוסחת נסיגה עד שנגיד לעץ עם קודקוד יחיד, כל פעם נוריד 2 עד שנגיע ל $N(0)$ ולכן סך הכל נבצע זאת $k/2$ פעמים.

![[Pasted image 20220626145156.png]]
_a_ : ההוכחה תהיה די זהה להוכחה הרגילה רק צריך להבין איך $N(k)$ משתנה במצב הזה.

את השוני מתחילים להרגיל כבר ב $k=2$ שעבור התנאי החדש יתקיים $N(2)=3$ (בהוכחה הקודמת זה היה 4) ו $N(3)=5$.
באופן כללי יתקיים : 
$$N(k)=N(k-1)+(k-1)$$
![[Pasted image 20220626152322.png]]

נבנה נוסחת נסיגה ונקבל 
$$\displaylines{
N(k)=N(k-1)+(k-1)=N(k-1)+N(k-3)+1>2N(k-3)\\
\updownarrow\\
N(k)>2N(k-3)=2^{k/3}\\
\updownarrow\\
k<log_{3}(N(k))
}$$
האי שיוויון האחרון נובע מאותו הסבר של התרגיל הקודם 

וכיוון ש מספר הקודקודים גדול או שווה ל $N(k)$ אז גובה העץ חסום מלמעלה בלוג בסיס 3 של $n$ מעבר בין בסיסים לוגריתמיים הוא קבוע ולכן חסום מלמעלה של $logn$.  $k\in{O(logn)}$

   __b__ . היתרון של עץ מהסוג הזה הוא שאנחנו נצטרך לעשות פחות תיקונים במעלה העץ , החסרון המשמעותי הוא שבמבנה כמו העצים המינימליים מלמעלה, ניתן לבנות מבנה שמשמעותית בצד אחד תהייה יותר עבודה בישביל לחפש מהצד השני. זה קורה בגלל שההגבלה על הפרשי הגובה לא הדוקה כמו בעץ $AVL$ רגיל ולכן מותר לפרוש את העץ בצורה שיותר מתקרבת למקרה הלא טוב של עץ חיפוש בינארי.
   
![[Pasted image 20220626160303.png]]

__a__ . בלי הגבלת הכלליות נניח שנרצה לעבור מ $T_{1}$ ל $T_{2}$ ,  נזכיר שהרוטציות שהראנו שומרות על תכונות של עצי חיפוש ולכן אין מה לדאוג נוכל להשמש בכמה רוטציות שנרצה כדי להביא ערך לנקודה מסויימת. 
נמצא את השורש של $T_2$ ב $T_1$ ונעלה אותו למעלה עם רוטציות. כעת הוא השורש גם ב $T_{1}$ . 
כעת נלך לתת העץ הימני והשמאלי של $T_{1}$ , נפעיל את האותו אלגוריתם בצורה ריקורסיבית על שניהם, כלומר , עבור תת העץ הימני ניקח את השורש של תת העץ הימני ב $T_2$ ונפעיל עליו רוטציות כך שהוא יעלה להיות שורש תת העץ הימני גם ב $T_{1}$ , נבצע את אותה הריקורסיה גם על תת העץ השמאלי.

__b__. כל איטרציה נבצע $n-i$ פעולות כאשר $i$ מייצג את הרמה שאנחנו נמצאים בה בעץ, סך הכל הוכחנו כבר שסדרה חשבונית מהסוג הזה חסומה ב $O(n^{2})$ __כדרוש__ . 


![[Pasted image 20220626161419.png]]

__a__ . __הפרכה__ 
![[Pasted image 20220626161626.png]]

העקרון הוא לבנות עץ בינארי שלשורש יש תת עץ אחד נורא נמוך ביחס לתת העץ השני.

__b__ . נניח בשלילה שהטענה לא נכונה על $AVL$ כלומר אין מסלול באורך $D$ שעובר בשורש, כלומר הוא מסלול השייך לתת עץ מסויים של השורש ונניח שזה מסלול של תת העץ השמאלי בלי הגבלת הכלליות. 
נסמן $D_r$ את המרחק המקסימלי בין עלה מתת העץ הימני של השורש לעלה בתת העץ השמאלי.

לפני ההנחה בשלילה יתקיים , 
$D_{r}<D$
כלומר , $D-D_{r}\geq1$ ,  אבל אנחנו יודעים שההפרש בין תת העץ הימני לשמאלי הוא לכל היותר 1 בערך מוחלט. נחלק למקרים: 

* $BF(T)=0$ זה סתירה לכך שהמרחק של $D$ גדול יותר כי הגובה של תת העץ הימני שווה לשמאלי ושניהם קטנים ב 1 מהגובה של תת העץ המקורי ולכן אני יכול לבנות מסלול $D_{r}$ שבהכרח יהיה יותר גדול ב $1$ מ $D$. 
* $BF(T)=1$ זה סתירה לכך שתת העץ השמאלי מכיל בכלל את $D$ כי תת העץ הימני גבוה ממנו ב$1$ לכן אוכל לבנות מסלול מקסימלי בתת העץ השני.
* $BF(T)=-1$ תת העץ השמאלי הוא הגבוה יותר אבל עדיין בהפרש של $1$ בלבד מתת העץ הימני לכן נוכל לבנות מסלול שלוקח את גובה תת העץ הימני + השורש + הגובה של תת העץ השמאלי ולקבל את $D$ . (אין עוררין לכך ש $D$ מכיל בחישובו את הגובה של העץ עליו ועוד המרחק השני הגבוה ביותר).

__סך הכל הגדרה זו תואמת לעצי $AVL$__

```ad-Code
```cpp

int diameter(struct node* tree)
{

	if (tree == NULL)
		return 0;


	int lheight = height(tree->left);
	int rheight = height(tree->right);


	int ldiameter = diameter(tree->left);
	int rdiameter = diameter(tree->right);

	// Return max of following three
	// 1) Diameter of left subtree
	// 2) Diameter of right subtree
	// 3) Height of left subtree + height of right subtree + 1
	return max(lheight + rheight + 1,
			max(ldiameter, rdiameter));
}

```
![[Pasted image 20220626164051.png]]
![[Pasted image 20220626164103.png]]

__a__ 
$$ \bigl(\begin{smallmatrix}
f_{n} \\ f_{n-1} 
\end{smallmatrix} \bigr)=A\cdot \bigl(\begin{smallmatrix}
f_{n-1} \\ f_{n-2} 
\end{smallmatrix} \bigr)=A^{2}\cdot \bigl(\begin{smallmatrix}
f_{n-2} \\ f_{n-3} 
\end{smallmatrix} \bigr)=\dots=A^{n-1}\cdot \bigl(\begin{smallmatrix}
1 \\ 0
\end{smallmatrix} \bigr)$$
__b__ $$A^{16}=(A^{8})^{2}$$
העלאה בחזקה ריבועית זאת פעולה קבועה, כיוון שיש לנו את $A^{8}$ פשוט צריך להכפיל אותו בעצמו שזו פעולה קבועה.

__c__
כיוון שיש לנו את $A$ נתון והחזקה היא ריבועית נוכל פשוט להעלות בחזקת 2 את $A$ 3 פעמים כדי לקבל את $A^{8}$ ובאופן כללי 
$$A^{k}=(A^{2})^{logk}$$
בהינתן ש $k\in\,\mathbb{N}$ .

__d__ 
האלגוריתם למציאת $k$ כללי הוא ככה, כל מספר $k$ ניתן לבנות מחיבור של 2 בחזקת מספרים מסויימים, הדרך לעשות את זה היא להמיר את המספר לבינארי, ולרוץ על הספרות איפה שיש 1, להחליף ב 2 בחזקת המיקום של אותו 1 למשל אם ה1 היה ממש בהתחלה אז יהיה 2 בחזקת 0....
(בפועל בקוד אפשר לפתור את זה בלי להמיר את המספר לבינארי מצורף פתרון למטה). 

```ad-Code 
```java

static void block(long x)
{
	ArrayList<Integer> v = new ArrayList<Integer>();
	
	while (x > 0)
	{
		v.add((int)x % 2);
		x = x / 2;
	}
	for(int i = 0 ; i<v.size();i++){
		if(v[i]==1){
		  //2^i is part of the solution
		}
}

```
האלגוריתם הזה הוא פשוט האלגוריתם שלמדנו במבוא למדעי המחשב ל[המרת מספר בבסיס 10 לבסיס 2](https://www.cuemath.com/numbers/decimal-to-binary/) שזה לוגריתמי לגודל המספר (מספר החלוקות ב2 שנצטרך לעשות ל $k$ עד שיגיע ל1 זה $logk$). כמו כן גם v.size יהיה בגודל $logk$ מאותה סיבה. 

__e__ אם ה מספר $k$ ניתן לבטא כחזקה של 2 אז זמן הריצה יהיה $logk$ . הטכניקה הזאת נקראת [repeated squaring](https://en.wikipedia.org/wiki/Exponentiation_by_squaring) אחרת נוכל לבצע את האלגוריתם הנ״ל שהוא גם חסום ב $O(logk)$ 

![[Pasted image 20220626175201.png]]

דוגמה לעץ כזה: 
![[Pasted image 20220626175251.png]]

ובכללי , על כל $N(k)$ שנבחר נבטא אותו כ נצטרך לעשות במקרה הגרוע $k-2$ רוטציות.

__תרגיל בונוס__ מציאת האיבר ה$k$ בגודלו בתוך עץ $AVL$ .

הרעיון היא לרוץ על העץ בצורת $inorder$ כדי להגיע , נוכל לרוץ פחות פעמים אם נשמור את מספר הקודקודים בכל תת עץ , מבחינת הקוד אפתור בלי השמירה הזאת, אבל אם נשמור לכל תת עץ את מספר הקודקודים נוכל לדעת לאיזה תת עץ ללכת אם למשל, מספר הקודקודים בתת העץ השמאלי קטן מ $k$ אין שום סיבה להכנס אליו. אז בסופו של דבר יש שני דרכים לגשת לפתרון , 

הראשון : להכנס לעץ לפי הפרמטר של הגודל , לפי מספר הקודקודים בתתי העץ להחליט לאיזה תת עץ להכנס ולהפעיל את זה ריקורסיבית , ככה שכל קריאה ריקוריסבית שנכנס __לעץ הימני__ נקטין את $k$ הדרוש במספר העצים שפסחנו עליהם, זה ייראה כך - 

```ad-Code
```psudo
select(root,k)
	if k>root.size
	  error
	if root.left.size == k-1
	  return root
	else if root.left.size > k-1
	   return select(root.left,k)
	else if root.left.size <k-1   
	  return elect(root.right,k- leftSize -1)    
```

הפתרון השני והיותר חביב, הוא לרוץ על העץ בצורת $inorder$ חלקית, כלומר אנחנו נצמצם אפשרויות מלמטה למעלה ולא מלמעלה למטה, סך הכל שתי המתודות חסומות בגובה העץ שזה $O(logn)$
```ad-Code
```java
public static Node kthSmallest(Node root, int k)  
{  
    // base case  
    if (root == null)  
        return null;  
  
    // search in left subtree  
    Node left = kthSmallest(root.left, k);  
  
    // if k'th smallest is found in left subtree, return it  
    if (left != null)  
        return left;  
  
    // if current element is k'th smallest, return it  
    count++;  
    if (count == k)  
        return root;  
  
    // else search in right subtree  
    return kthSmallest(root.right, k);  
}
```
 

__משהו חשוב לפני שממשיכים לנושא הבא, נשים לב שעץ בינארי מלא הוא בעצם מקרה פרטי של עץ avl והרבה אלגוריתמים שעשינו בפתרונות שם מתאימים גם לפה, למשל אלגוריתם המעבר ממערך ממויין לעץ בינארי מלא זה שקול ללעשות את זה עבור עץ $AVL$. באופן דומה גם אלגוריתם המיזוג שדיברנו עליו למעלה יעבוד גם פה.__


## עצי B 
### עצי חיפוש מסדר גבוה
אם נרצה, נוכל להכליל את כל המונחים שדיברנו עליהם עד עכשיו בהקשר של עצי חיפוש בינאריים, נוכל להגדיר עץ חיפוש מדרגה $m$ כאשר $m\geq 2$ אשר כל קודקוד בעץ הזה יקיים שיש לו לכל היותר $m$ ילדים ויכול להכיל לכל היותר $m-1$ מספרים בתוכו.

עצי חיפוש בינאריים הם מקרה פרטי של ההגדרה הזאת שכן $m=2$ . כלומר הם עצי חיפוש מסדר $2$ . ולכן יש להם גם רק ילד אחד בכל קודקוד.

__הגדרה__ סדר= דרגת קודקוד= מספר הבנים שיש לאותו קודקוד.

* אם דרגת הקודקוד היא $k$ אז לקודקוד יהיו $k-1$ ערכים פנימיים ו $k$ מצביעים.

הגדרת ההכנסה לעץ כזה תהיה הכללה  להכנסה לעץ בינארי :

יהי שורש $v_{x_{i}:i\in[k-1]}$  שערכיו $x_{i}:i\in[k-1]$ ו $k\leq{m}$
* תת העץ השמאלי  יכיל את הערכים שקטנים מ $x_{1}$
* תת העץ ה $i$   $2\leq{i}<k$  יכיל רק אלמנטים שגדולים מ $x_{i-1}$ 
* תת העץ הימני ביותר (ה $k$-י) יכיל רק את האיברים שגדולים מ $x_{k-1}$

למשל עץ חיפוש מסדר 4:
__שימו לב שמותר להצביע לילד שהוא null בעץ חיפוש מסדר m כללי__
![[Pasted image 20220626195919.png]]

שיטת החיפוש זהה לגמרי למה שאנחנו מכירים מהמקרה הפרטי של עץ חיפוש בינארי, עבור ערך $y$  נבדוק אם הוא שייך לסדרת המספרים בקודקוד , אם הוא לא אז בודקים באיזה טווח הוא ובהתאם לזה נכנסים לפוינטר המתאים.

__לא נתעמק ממש על הכנסה ומחיקה בעצי חיפוש מסדר גבוה כי כמו עצי חיפוש בינאריים הם חסומים ב $\Omega(n)$ .__ 
אבל!! ראינו [[#עצי AVL]]  ואיך הם עוזרים לנו להקטין את החסם על הפעולות על ידי הקטנת גובה העץ. וכעת, נדבר על האלטרנטיבה לעצי חיפוש מסדר גבוה שנותנת לנו בידיוק את הכוח הזה.

### הגדרה של עצי B 
עץ $B$ הוא עץ מסדר $m$ כאשר $m>2$ המקיים את התנאים הבאים : 
* כל קודקוד חוץ מהשורש מכיל __לפחות__ $\lceil{\frac{m}{2}}\rceil-1$ ערכים . השורש מכיל לפחות ערך אחד.
* רק לקודקודים ברמה הנמוכה ביותר יכול להיות ילד ריק.

מתנאי 2 ניתן להסיר שכל העלים בעצי $B$ הם באותה הרמה. 
מהתנאי הראשון ביחד עם ההגדרה של עצי חיפוש מסדר $m$ מגביל את מספר הילדים של קודקוד פנימי (ללא השורש) בעצי $B$ להיות בין 
$$\lceil{\frac{m}{2}}\rceil...m$$ ולכל קודקוד פנימי שהוא לא שורש , כתוצאה מכך, מספר הערכים הפנימיים הוא בין 
$$\lceil{\frac{m}{2}}\rceil-1\dots m-1$$
דוגמה לעץ חיפוש מסדר $5$
![[Pasted image 20220627120604.png]]

#### עומק של עץ $B$ מסדר m 
באופן כללי יתקיים עבור עץ $B$ מסדר $m$ המכיל $N$ ערכים :
$$N>2\big(\frac{m}{2}\big)^t$$
כאשר $t$ מייצג רמה מסויימת בעץ.  
מכאן אפשר להסיק ש 
$$t<\log_{m/2}\frac{N}{2}=\frac{\log_{2}N-1}{\log_{2}m -1}\in{O(\log_{m}(N))}$$
בשביל להמחיש את היעילות של זה, עבור עץ מדרגה $256$ הרמה הכי נמוכה שנגיע אליה תהיה $4$  . זאת אומרת שלמבנה שהמטרה שלו היא להכיל אובייקט בעל כמות אדירה של מידע הוא יחסית שטוח מאוד.
לפיכך, כדאי שנראה גם איך שומרים על התכונות האלה בהכנסה והוצאה .

#### הכנסה 
השלב הראשון הוא חיפוש , שלב החיפוש זהה לשלב החיפוש בעץ חיפוש מסדר m רגיל.

כעת לשם ההכנסה נחלק למקרים בהינתן שנרצה להכניס את הערך $y$
* הגענו לקודקוד $v_{x_{i}:i\in[k-1]}$ המקיים $k-1<m-1$ וגם הערך $y$ יכול להכנס באינדקס $j\in[k-1]$ , במצב זה נכניס אותו פשוט לרשימה במקום המתאים . 
*  הקודקוד שאליו נרצה להכניס כבר בתפוסה מלאה, הכנסה של הערך $y$ תשבור את התנאים של עצי $B$ . (למשל הכנסת 55 לעץ למעלה).
במצב זה, נעשה מספר פעולות:
1) נכניס את הערך הרצוי ל קודקוד המתאים תוך כדי התעלמות ממצב ה $overflow$ שיצרנו.

![[Pasted image 20220627124108.png]]

2) בשלב השני נצטרך לתקן את החוסר איזון שיצרנו, (בהכרח חוסר איזון יהיה כשבקודקוד יש $m$ ערכים, לא יהיה יותר).

נסמן את האיברים בקודקוד $S=r_{i}:i\in[m]$ ונפצל אותו לתתי מערכים הבאים 
$$SL=r_{i}:i\in[\lceil{m/2}\rceil-1]$$
$$SR=r_{i}:i\in \{ \lceil{m/2}\rceil+1,\dots,m\}$$
החדים בינינו ישימו לב ש$r_{m/2}$ לא נמצא באף אחת מהקבוצות, תיכך נדבר עליו.

כעת נעשה את הדבר הפשוט הבא : נפצל את הקודקוד שהכיל את $S$ לשני קודקודים המכילים בהתאמה את הערכים שב $SL$ ו $SR$ .
שני הקודקודים החדשים יהיו ילדים ישירים של האבא  ושכנים אחד של השני(נדבר מה יכול לקרות בהמשך), כמו כן הערך שלא נכנס לרשימה ייכנס באופן ריקורסיבי לאבא שמעליו מהסיבה שכעת הוספנו עוד ילד לאבא ולכן מהגדרת העץ צריך להוסיף עוד ערך (יש הפרש של 1 בין השניים) (אם גם באבא יש $overflow$ התהליך ממשיך באופן זהה).

התוצאה על העץ הנ״ל תהיה : 
![[Pasted image 20220627131447.png]]



__בוא נראה מה קורה אם נכניס עכשיו את הערך 3 לפי השלבים הנ״ל :__ 
שלב ראשון : 
![[Pasted image 20220627131552.png]]

והשלב השני:

![[Pasted image 20220627131628.png]]

__אופס!__ קיבלנו $overflow$ גם בשורש, ובמצב זה סוף סוף העץ גדל בגובהו , בניגוד ל $AVL$ שבהכנסה ניצור עלה חדש ואז נאזן את הכל, כלומר בנייה מלמעלה למטה, כאן הבנייה היא __מלמטה למעלה__ ולכן לא צריך שום טיפול מיוחד כדי לדאוג שכל העלים יהיו באותה רמה (מדהים לא?)

מה שיקרה בדוגמה שלנו בשלב הזה היא שנמשיך כרגיל אבל הפעם בגלל שהגענו ל $overflow$ בשורש אין לנו למי לחבר את שני הקודקודים המפוצלים שיצרנו , לכן ניצור שורש חדש שערכו יהיה $r_{m/2}$ שנוצר מהפיצול.

![[Pasted image 20220627132315.png]]

__במקרה הגרוע אנחנו נבצע פיצולים כאלה כגובה העץ, המקרה הזה יהיה די נדיר ולכן המבנה הזה כל כך טוב__ .

מבחינת יעילות, כמו חיפוש הפעולה חסומה באופן הדוק בגובה העץ $\Theta(\log_m (n))$

נשים לב לנקודה נוספת, מבחינת הבנייה של המבנה  עבור $n$ ערכים. 
מפתה להגיד שפשוט מבצעים את פעולה ההכנסה $n$ פעמים ולכן זה חסום ב $O(n\log_{m}(n))$ אבל זה לא המצב, כיוון שהעץ ריק ואנחנו יודעים שבכל קודקוד פרט לשורש יכולים להיות לפחות מספר הסדר $m$ חלקי 2 ערכים פנימיים , לכן עבור $n$ ערכים יהיה לכל היותר בקירוב $2n/m$ קודקודים. שזה בעצם $O(n/m)$ פיצולים. 

#### מחיקה 
כמו בעצי חיפוש בינאריים הכי קל לנו יהיה למחוק ערכים מעלים, ואם נרצה למחוק מערכים שאינם כאלה נמצא לו יורש בתוך העץ שיחליף אותו (ב $AVL$ זה יהיה עלה אחר). גם בעצי $B$ המצב יהיה דומה , אלגוריתם המחיקה ייראה כך 

ה״יורש״ להחלפה במקרה של מחיקת קודקוד שאינו עלה יימצא באופן הבא
* מציאת הקודקוד $v$ שבוא נמצא ערך המחיקה $x$ , בררגע שמצאנו יציאה מיידית לפוינטר הימני
* אם הקודקוד אינו עלה, יש לצאת מיד לפוינטר השמאלי ביותר ולהמשיך ככה עד להגעה לעלה
* הערך השמאלי ביותר בעלה שנגיע אליו הוא היורש.

(מאוד דומה למציאת הערך הבא בהדפסת inorder של עץ בינארי).

הבעיה עם מחיקה זה שיכול להיות מצב של $underflow$ , אם אין מצב כזה בקודקוד שבו רוצים למחוק את הערך , פשוט נמחק אותו. 

כעת, נניח שנרצה למחוק את הערך $60$ בעץ למעלה, הוא הערך בשורש ולכן מחיקתו תוביל לכך שאין ערכים בקודקוד, במצב זה ובמצב זה $underflow$ בקודקודים פנימיים, מיד נשלים על ידי ה״יורש״ שהגדרנו למעלה (במקרה הזה 100). 

![[Pasted image 20220627145855.png]]

על פניו נשמע מצויין , עם זאת , ניתן לראות שעלול להווצר מצב שבו בעלה יש מספר מועט מדי של ערכים, מה שלא מתאים להגדרה של עצי $B$ (במקרה שלנו יש דרישה למינימום 2 ערכים).

נשמע כאילו הפתרון יהיה למזג? כמו שעשינו פיצול בהכנסה, עם זאת זה לא המצב, כי בעוד שפיצול קודקוד זה אך ורק לפי ערכי הקודקוד , מיזוג לא בהכרח יהיה אפשרי בגלל שיש תלוי בערכי האבא. למשל אם נמזג את 110 עם הקודקוד מימינו , לא רק שנצטרך להוריד ערך אחד מהאבא אלא גם שהמצביעים לא יתאימו לערכים כלומר המצביע השמאלי לקודקוד (150,700) יכיל ערכים שקטנים וגדולים מ 150 וזה לא טוב.

בכל מקרה , נקטין את מספר הילדים ולכן קודקוד אב יצטרך להוריד ערך אחד. אבל נעשה את זה במהלך שנקרא $balancing$ 

המהלך הזה יתבצע בצורה הבאה : 
* אם השכן __המידי__ של קודקוד $v$ שהוא במצב $underflow$ מכיל מספר שיותר גבוה ממספר המינימום המותר של ערכים (כלומר שהסרת ערך אחד לא תפגע) . ניקח את הערך שהכי קרוב לקודקוד שממנו מוחקים בשכן המיידי (נסמן $x_l$) , ואת הערך שמפריד בין שני הילדים באבא נסמן $t$. נשים את $t$ בקודקוד שמצב $underflow$ במקום המתאים, ואת $x_l$ נשים במיקום של $t$ למשל עבור העץ הנ״ל ניקח את 150 , נשים אותו בקודקוד 110 מצד ימין, ואת 200 נשים במקום 150, באופן הבא :

![[Pasted image 20220627151357.png]]
__נשים לב, שכן מידי = שכן ימני אם קיים ואם לא אז שכן שמאלי__ 
* המצב השני יתרחש כאשר הורדת ערך מהשכן המידי לא מתאפשרת בגלל שגם לו יהיה $underflow$ , (למשל אם נרצה למחוק את 600) לא נוכל להשאיל את 704 . במצב זה נצטרך להשלים את הערך המתאים מהאבא ואם יש יותר מדי ילדים לאבא, יתקיים  מיזוג של הקודקוד עם שכנו הימני. בגלל המצב של underflow אנחנו יודעים שניתן לעשות מיזוג כזה אחרי שהוספנו ערך מהאבא . 
  
המיזוג ייראה כך (על מחיקת הערך 600)

![[Pasted image 20220627152113.png]]

__גם כאן יש בעיה__ מחיקת הערך 700 מהאבא יצרה $underflow$ אצלו. לכן המחיקה במצב זה המחיקה תהיה __ריקורסיבית__ כלומר שאם יש $underflow$ ,נצטרך גם פה לעשות $balancing$ . האיזון יהיה זהה למה שעשינו במחיקה מהעלה, אם אפשר להשלים מהשכן המידי , נשלים, רק שהפעם בגלל שאנחנו לא משלימים על עלה נסדר את הילדים בהתאם. למשל בדוגמה שלנו : 
![[Pasted image 20220627162213.png]]

המקרה השני , הוא מצב לא גם באבא לא ניתן לאזן מהשכן המיידי ולכן נמזג ונשלים מהאבא שמעליו (ופה נכנסת הריקורסיה המדוברת) למשל,  אם נמחק את 55 זה ייראה כך : 
![[Pasted image 20220627162821.png]]
![[Pasted image 20220627162831.png]]
וככה נמשיך באופן ריקורסיבי עד הגעה לשורש.

__גם פעולת המחיקה חסומה בגובה העץ כמו פעולה ההכנסה__. 


#### וריאנטים לעצי $B$ 
ישנם וריאנטים מכל מיני סוגים שמיועדים לייעל טיפה את המימוש הנ״ל או לתאר מקרים ספציפיים למשל עצי $B+$ שמכילים בתוכם עוד כמה אפשרויות לרוטציות או עצי $B*$ שמכילים את כל המידע בילדים וכך ניתן לבצע סריקה על כל הילדים לפי הסדר. אני רוצה לפרט בקצרה על מקרה פרטי ,

##### עץ 2-3
זה עץ $B$ המקיים ש $m=3$ באופן כללי כל קודקוד יכיל ערך אחד או שני ערכים , קודקוד עם ערך אחד יכיל 2 ילדים וקודקוד עם שני ערכים יכיל 3 ילדים. 

הסיבה שאני מדבר עליו היא שאני רוצה להדגים באופן ספציפי (אך ניתן לממש את זה באופן כללי) אלגוריתם בנייה של עץ כזה ממערך ממויין בזמן ליניארי. 


האלגוריתם יעבוד בצורה הבאה: 
* אם המערך מכיל 2-3 ערכים , סיימנו , נקבל שורש יחיד
* אחרת נחלק את המערך לשלישיות, כל שלישייה תהיה עלה בעץ , ואת הערך הגדול מבין השלושה נפעפע למעלה ונבנה קודקוד אבא לכולם, אם הוא מכיל 2-3 ילדים, סיימנו, אחרת נבצע את אותו התהליך ריקורסיבי על תת המערך שהוא הערכים בקודקוד האב (בעצם זה הפרס ומשול קלאסי כשתנאי העצירה הוא הסעיף הראשון של האלגוריתם). __חשוב, כשמחלקים ל3 השארית תמיד תהיה איבר אחד או שניים, עלינו לדאוג שהם תמיד יהיו האיברים האחרונים במערך בחלוקה שלנו , באופן זה הם אוטומטית יהיו העלה הכי ימני בעץ__. 

דוגמה:
![[Pasted image 20220627164603.png]]


### תרגילים עצי $B$ 
![[Pasted image 20220627164711.png]]
__a__ לא בהכרח, נסתכל על זה באופן תיאורטי, כמובן שאם ההכנסה לא תגרום לפיצול אז גם ההוצאה לא תגרום למיזוג כי בתור הקודקוד הערכים עדיין מתאימים, עם זאת, אם נכניס ערך ונגרום לפיצול הקודקוד , לאו דווקא שמחיקה תגרום למיזוג , ניתן יהיה פשוט לבצע השלמה עם שכן מיידי ובזה ייגמר הסיפור והשורש שירד לעלה יישאר בעלה. 

__b__ גם כן לא, מסיבה פשוטה עוד יותר, הכנסה תמיד מגיעה לעלה בעוד שמחיקה לא, אז אם נמחק ערך שהוא אינו עלה ונכניס אותו שוב, אותו ערך יהיה עלה באופן מיידי.


![[Pasted image 20220627165658.png]]

ניקח את האיבר המקסימלי ב $A$ או האיבר המינימלי של $B$ ונסמנו $s$ .הוא ישמש אותנו כמתווך בין שני העצים.  
כעת ניקח את השורשים של שני העצים , $r_A$ $r_B$ נחלק למקרים : 

* אם שני העצים באותו גובה , נגדיר $R$ שיכיל בתוכו את $s$ וילדים יהיו $r_A$ ו $r_B$ . כעת בגלל שהם כבר לא שורשים, יכול להיות שנצטרך לבצע עליהם איזון , תלוי בדרגה, נדע כיצד יש לבצע את האיזון.
* אם $B$ נמוך יותר מ $A$ (מהנתון על a,b אנחנו יודעים שאו שהם באותו גובה או ש A גבוה יותר). ניקח את הקודקוד הכי ימני ב $A$ ברמה שהיא הפרש הגבהים בינהם. ניקח את $s$ ונשים אותו באבא של הקודקוד הנ״ל, הוא כמובן יהיה בצד הכי ימני, ונגדיר שאותו קודקוד שמכיל את $s$ יצביע ל$r_{b}$ . הצעד האחרון יהיה לבצע איזון וסיימנו.  __הסיבה שחילקנו למקרים האלה היא שאנחנו צריכים לדאוג שבמיזוג הזה כל העלים יהיו באותה רמה__ . (נשים לב שבאפשרות השנייה עדיף ש $s$ יהיה האיבר המינימלי ב $B$ ולא המקסימלי ב $A$ כי אז נצטרך לבצע איזונים עוד לפני שבכלל ביצענו את המיזוג).
![[Pasted image 20220627182449.png]]

__a__. נוריד את 40 , כעת נסתכל על השכן השמאלי, נראה כי אי אפשר להשאיל ממנו בלי למזג, לכן נצטרך למזג ולבצע איזון ריקורסיבי, בעת המיזוג נהיו לנו 3 ילדים ולכן באבא צריך שיהיו רק 2 ערכים , ניקח את הערך המתאים ונכניס לתוך הילד ונקבל 

![[Pasted image 20220627182751.png]]

__b__. באותו אופן נקבל

![[Pasted image 20220627182840.png]]

__c__.
נרצה למזג את שלושת העלים השמאליים לשני קודקודים, העץ הוא מדרגה 5 ולכן מותר 4 ילדים בכול קודקוד פנימי לפחות, אם נסיר 40 ונמזג אותם יהיה 5 ילדים אבל בגלל שבאבא יש 3, נוכל להוריד את 52 ולשים את 24 במקומו וזה ייראה כך 
![[Pasted image 20220627193316.png]]

__d__ מבקש באיזון שאנחנו לא מכירים ולכן לא אתעמק בו.

__e__ אם הסדר היה 4 לא הייתה בעיה להסיר בכלל את 40 . 



![[Pasted image 20220627193857.png]]

104: ייכנס רגיל
![[Pasted image 20220627194318.png]]

105- ייכנס רגיל
![[Pasted image 20220627194640.png]]
106- overflow נפצל ו 104 יעלה למעלה

![[Pasted image 20220627194734.png]]
107- ייכנס רגיל
![[Pasted image 20220627194829.png]]
108- גם כן ייכנס רגיל
![[Pasted image 20220627194934.png]]
109- overflow יגרום ל107 לעלות למעלה ולכן יהיה overflow בשורש ולכן גם הוא יתפצל לשניים ו104 יהיה השורש החדש.
![[Pasted image 20220627195053.png]]
140- ייכנס רגיל בלי שינוי
![[Pasted image 20220627195122.png]]
150- overflow יגרום ל140 לעלות למעלה
![[Pasted image 20220627195159.png]]
160- ייכנס רגיל
![[Pasted image 20220627195222.png]]

![[Pasted image 20220627183229.png]]

__a__  נשים לב שעל טווח הערכים הזה נוסיף 1 כדי לקבל את ההגבלה על מספר הבנים שמותר שיהיה לקודקוד פנימי שאינו השורש. 
המטרה שלנו היא לאפשר כמה שיותר מידע שיאוכלס בשורש לפני שנצטרך לפצל לשני קודקודים נוספים, אם כך נרצה שמבחינת ערכים השורש שלנו ברגע שנגיע ל  __פעמיים מספר הבנים המינימלי של קודקוד פנימי פחות 1__ כלומר $\frac{6m}{4}-1$ יהיה פיצול של השורש לשני בנים פלוס שורש חדש שהוא הערך האמצעי.  כלומר מקסימום ערכים בשורש יהיו $\frac{6m}{4}-2$ וברגע שנגיע למספר הערכים הזה נוכל לפצל לשני בנים שבכל אחד מהם יש $3/4m-1$  ערכים וגם קודקוד השורש.

מבחינת מספר הילדים פשוט נוסיף $1$ בהתאם להגדרת עצי$B$ ונקבל, בין 2 ל$1.5m-1$. 

__b__  
__הכנסה__ : 
ההבדל בין המקרה הזה לבין המקרה של עץ b רגיל, הוא שהפעם אם נגיע לoverflow , לא יעזור לנו לפצל ל2 כי נקבל שהקודקודים הפנימיים שפיצלנו יהיו ב underflow (יהיו חצי מ m) . על מנת להתמודד עם זה. אם ננסה למזג עם שכן מיידי ולפצל ל2 גם נתקל בבעיה כי יכול להיות מצב שבו נחבר קודקוד עם $m$ (זה שיש בו עודף), לקודקוד עם $3/4m$  ערכים ואז אחרי שנפצל עדיין יהיה underflow. 
לכן ההכנסה תהיה כך : 
* נחבר את הקודקוד עם overflow עם שני שכניו ונפצל אותם ל $4$ (מבחינה מתמטית זה המצב היחיד שיאפשר לדעת בוודאות שכל קודקוד עומד בתנאי הסף ולא עובר את הקיבולת) כעת יש ילד אחד עודף לאבא של השכנים האלו, נעלה את הערך האמצעי למעלה כדי לאזן ונעשה זאת באופן ריקורסיבי. 

באופן כללי נשים לב אם היחס הוא $x/y$ אז במצב $overflow$ ניקח $x$ קודקודים ונפצל אותם ל $y$ קודקודים חדשים (בהינתן שהיחס הזה קטן מ $1$).

נשים לב למקרה קצה שבו יש לי רק שכן אחד, במצב הזה נאחד אותם מיידית עם האבא ונפצל ל 4 ונאזן כרגיל. 

__מחיקה__ 
על מנת למחוק ערך , אם לא נקבל underflow ממשיכים כרגיל, אם מקבלים underflow ואפשר להשלים מאחד השכנים המיידיים עושים את זה ומסדרים עם השכנים, במצב אחר נתאחד עם השכן נסדר את המצביעים על ידי הכנסת ערכים מהאבא למטה, אבל שוב יכול להיות מצב של overflow בילד הזה . נאזן על ידי פיצול והעלאה לאבא כמו בהכנסה.

__סך הכל היתרון של לשנות את התנאי הזה הוא שנקבל הרבה יותר ניצול של השטח שלנו בשמירה של הערכים בפנימיים (75 אחוז), עם זאת החסרון המשמעותי הוא שנצטרך לעבוד הרבה יותר קשה כדי לשמור על האיזון בעיקר במחיקת ערכים__ . 



## ערימות 
### תורי עדיפות priority queue
אחד ממבני הנתונים הראשונים שדיברנו עליהם בפרק של [[#מבני נתונים ליניאריים]] היה [[#תור]] . תור תומך ב$FIFO$ אך הרבה פעמים נרצה לתאר (גם בחיים האמיתיים) מצב שבו הסדר לא בהכרח יהיה לפי סדר הכניסה למבנה אלא לפי נתונים שבאים מתוך ה $record$ . למשל בבית חולים אם מצב המטופל חמור הוא ייכנס קודם לחדר הניתוח לפני מישהו ששבר את הרגל גם אם הבחור ששבר את הרגל הגיע לפניו. 
מבחינה מתמטית אנחנו מתאים את המבנה הזה עם [priority queue](https://www.geeksforgeeks.org/priority-queue-set-1-introduction/). תור עדיפויות הוא מבנה נתונים מופשט כמו [[#מחסנית]] או [[#תור]] , כלומר שהוא מייצר איזשהם תכונות שעבורם כל מימוש שניתן עם התוכנות האלה ייקרא ״תור עדיפויות״. בתור עדיפויות כל ערך יחזיק מידע שיתאר את העדיפות שלו באופן מתמטי. כמו כן, נרצה לתמוך בהוצאה והכנסה מהמבנה ושינוי עדיפות בזמן יעיל. כמו כן, נרצה שליפה מהירה לאובייקטים בעדיפות גבוהה. 
אחד הפתרונות אולי, יכול להיות מערך ממויין בסדר יורד כך שהעדיפות הגבוהה ביותר נמצאת במקום ה $0$ אבל יהיה לנו בעיה בעדכונים.
פתרון נוסף יכול להיות עץ חיפוש שלוקח $\Omega{(nlogn)}$ בבנייה אבל עדכונים לוקחים $O(logn)$.

המימוש שאנחנו נתמקד בו בפרק זה נקרא ערימה, והוא סוג מיוחד של עץ בינארי המאפשר לנו לעדכן ב $O(logn)$ , לגשת לעדיפות הגבוהה ביותר ב $O(1)$ ובנייה שלו ב $O(n)$ .
השם ערימה נובע מהעובדה שבמבט ראשוני, הכל נראה די מבולגן ולא ברור.
![[Pasted image 20220627213122.png]]

אבל ברגע שמבינים את הסדר של הדברים , מקבלים הרבה כוח עליו נדבר מיד. 

### הגדרת ערימה ועדכוני ערכים 
__הגדרה__ ערימה היא עץ בינארי שהערך בכל קודקוד גדול יותר או שווה לזה של ילדיו אם הם קיימים. 

מסקנה מיידית מהגדרה זו היא שהערך הגדול ביותר של ערימה תמיד יהיה בשורש שלה, כמו בערימה שלמעלה. מה שכן חשוב לשים לב זה שאין משמעות לסדר בכל קומה בעץ מבחינת ההגדרה הזאת . 

אם נרצה למחוק את הערך המקסימלי למשל, נמחק את הערך מהשורש, אבל הפעם אין שום צורך לבדוק כמה ילדים יש או לחפש את האיבר בהדפסת inorder, פשוט מאוד מחליפים את ערך הקודקוד בערך המקסימלי של אחד מילדיו. התהליך הזה מתבצע באופן ריקורסיבי עד להגעה לעלה. אותו נוכל להסיר בלי לדאוג.

אם נרצה להכניס אלמנט חדש אם כן , נרצה להכניס אותו כעלה בזמן $O(1)$ __(עלול להדליק לנו כמה נורות אדומות, למשל איך מכניסים עלה ב זמן קבוע לעץ בינארי, נדבר על זה בהמשך).__ לאחר שמכניסים בזמן קבוע לתחתית הערימה מתחילים סדרה השוואות מלמטה למעלה כדי למצוא  את המיקום האמיתי המתאים . 

למשל אם נרצה להכניס 52 לערימה מעל (אחרי שמחקנו את 83).
![[Pasted image 20220627221113.png]]


כמו בעץ בינארי גם פה פעולות ההכנסה וההוצאה חסומות בגובה העץ, שבמקרים מסויימים יכול להיות $\Omega(n)$ . לפיכך, נרצה להוסיף אילוץ על אופן הבנייה שלנו ולהגדיר את הערימה כ [[#עץ בינארי כמעט מלא כמעט שלם]].  לדוגמא: 

![[Pasted image 20220627223423.png]]
### ערימה כעץ בינארי כמעט שלם
__הכנסה__ 
המטרה של ההגדרה הזאת היא להגביל את חופש התנועה בהחלטה היכן למקם ערך חדש שנכנס. כעת הגבלנו את האופצייה הזאת. כעת אופן ההכנסה של ערכים עדיין יהיה מלמטה למעלה, רק שהפעם את העלה נכניס במטרה למלא את הקומה ה$h$ בעלים, לכן נכניס למקום הראשון משמאל שבו אין עלים בקומה הנמוכה יותר (זה תואר להגדרה שנתנו לעץ בינארי כמעט מלא). __נוכל לראות בתמונה למעלה את ההכנסה של 15 ולאן ייכנס האיבר הבא בתור שם__. אם נגמר המקום בקומה, ניצור קומה חדשה והאיבר ייכנס כילד שמאלי של הקודקוד השמאלי הנמוך ביותר בערימה. 

__גם אם הכנסנו ערך שלא מתאים, פשוט נבצע החלפות כמו מקודם.__

__הוצאה__ 
כדי להדגים מה לעשות בהליך הוצאה נסתכל על הערימה הבאה 
![[Pasted image 20220627225046.png]]

לא משנה איזה איבר נרצה להוציא , כל אחד מהם פרט ל $4$ ישבור את מבנה העץ הכמעט מלא. לכן, נגדיר שעבור מחיקה, של קודקוד מסויים , בשלב הראשון של התהליך, נחליף את הערך היחיד שאפשר למחוק, בערך הקודקוד שנרצה להוציא. 
למשל , אם נרצה להוציא את 41, נשים את $4$ במקומו. (באופן כללי מחיקה תמיד תתחיל מהאיבר הכי ימני ונמוך בעץ).

* השלב השני הוא לבצע כמה תיקונים. נשים לב מה קורה במצב הבא 
* ![[Pasted image 20220627225525.png]]
שמנו את $4$ במקום 41 וכעת אין לנו ערימה יותר, עם זאת, נשים לב שכל תתי העצים הם כן ערימה ולפיכך סך הכל נצטרך לפעפע את הערך למטה אם בכלל יש בכך צורך , לכיוון של הילד הגדול יותר מבין השניים ככה עד שנגיע לקודקוד שהילדים שלו יהיו יותר קטנים מ 4 או שנגיע לעלה.

![[Pasted image 20220627225752.png]]

__כעת הובלנו לכך שגובה העץ יהיה חסום ב logn וכל הפעולות עדיין חסומות בגובה העץ ולכן פעולות ההכנסה וההוצאה יהיו $O(nlogn)$__ .

### ערימות מינימום ומקסימום 
אומנם  דיברתי במונח הכולל של ערימה אבל חשוב לציין שיש שני סוגים של ערימות שנוכל לבנות (את שניהם נבנה בידיוק באותו האופן עם הבדל אחד קטן שתיכף אסביר אותו). 

##### ערימת מקסימום 
זאת הערימה שאיתה עבדנו עד כה, ערימה שבה לקודקוד עם ערך מסויים, אם יש ילדים אז הם יותר קטנים מהקודקוד. כל הפעולות הנ״ל אלה הפעולות שדיברנו עליהם למעלה. 

##### ערימת מינימום 
הערימה הזאת עובדת אותו הדבר ההבדל היחיד זה שלכל קודקוד עם ערך מסויים , אם יש לו ילדים, אז ערכיהם יותר גדולים ממנו למשל: 
![[Pasted image 20220627230150.png]]

##### ההבדלים בין השניים 
שני הבדלים עיקריים , הראשון , ששליפת הערך ב$O(1)$ בערימת מקסימום יהיה הערך עם העדיפות הכי גדולה ובערימת מינימום זה העדיפות הכי קטנה. 
ההבדל השני הוא שכל פעולות ההחלפה בערימת מקסימום מבוצעות על יחס הסדר ״גדול או שווה״. בערימת מינימום פעולות ההחלפה יבוצעו בהתאם ליחס הסדר ״קטן שווה״.

### מימוש ערימה 
עד כה דיברנו על ערימה כעץ בינארי כמעט מלא. אבל גם ציינו שיש כמה נקודות בעייתיות שצריך לעלות. למשל , איך אני מכניס איבר לתחתית העץ ב $O(1)$ או איך אני יכול להסתובב בחופשיות ברחבי העץ מלמטה למעלה כשאנחנו יודעים שבעץ יש רק יכול לרדת למטה. 
נוכל לנצל את המגבלה ששמנו על ערימה, כדי לממש את הערימה בלי מצביעים בכלל, אם יש $n$ קודקודים לערימה שלנו נוכל לממש באמצעות מערך בגודל $n$ .

#### בניית המערך 
כמו שאמרנו , עבור $n$ ערכים נבנה (או נקבל כקלט) מערך בגודל $n$ . נתבונן בעץ הבא :
![[Pasted image 20220628004505.png]]
האיברים במערך יהיו לפי הקומות משמאל לימין (ככה גם הגדרנו את ה״הירכייה״ בעץ בינארי כמעט מלא). סך הכל המערך יהיה ככה: 

![[Pasted image 20220628004613.png]]

במינוח מתמטי , לכל $v(i)$ שזה הקודקוד המייצג את האינדקס $i$ במערך יתקיים שהילד השמאלי שלו יהיה באינדקס $2i$ והילד הימני שלו יהיה באינדקס $2i+1$ .

![[Pasted image 20220628004819.png]]

כמו כן עבור $v_j$ הקודקוד אבא שלו תמיד יהיה $v_{\lfloor{j/2}\rfloor}$ .
__חשוב לשים לב שמהסיבה הזאת האינדקס מתחיל ב1__ לכן ניתן לזוז בחופשיות במערך כדי להשיג את הערכים המבוקשים. 

__אנקדוטה__ : המרה של מספר לכפולות של 2. כבר פתרנו תרגיל כזה ב[[#תרגילים עצי AVL]] אבל נסביר פה בקצרה שוב, 
על כל מספר $i$ ניתן להמיר אותו לצורתו הבינארית על ידי האלגוריתם המוכר ממבוא למדעי המחשב (לקחת את השארית עם 2 ולחלק ועד שמגיעים ל0 ובסוף לוקחים את המספר בסדר הפוך). נסמן את הייצוג הבינארי כ $b_{k}\dots{b_{2}b_{1}b_{0}}:b_{j}\in{\{0,1\}}$ וכעת $i$ יהיה $\sum\limits_{j=0}^{k}{b_{j}2^{j}}$ .
הסיבה שאני מזכיר את זה פה כי בצורה הבינארית אפילו יותר קל לגשת לאינדקסים של הילדים בערימה עבור הקודקוד באינדקס $i$ הנ״ל למשל 
$$\text{right child: }b_{k}\dots{b_{2}b_{1}b_{0}1}$$
$$\text{left child: }b_{k}\dots{b_{2}b_{1}b_{0}0}$$
ואם נרצה לעלות ברמה ולהגיע לאינדקס של קודקוד האבא של $i$ :
$$\text{father node: }b_{k}\dots{b_{2}b_{1}}$$
מורידים פשוט את הספרה האחרונה.

אם נרצה למחוק איבר אנחנו יודעים איפה נמצא האיבר האחרון שאפשר למחוק באופן תקין (בסוף המערך) ונוכל פשווט להחליף בין הערכים בזמן קבוע, לזוז ולבצע החלפות כמו שהגדרנו בזמן לוגריתמי.

__נקודה חשובה, המחיר שאנחנו משלמים על הבנייה הזאת של ערימה, היא חיפוש, בניגוד לעץ חיפוש בינארי, כאן לא מוגדר באמת יחס סדר על האיברים ולכן נצטרך לחפש איבר בזמן ליניארי בתוך המערך, רק לאחר מציאת האינדקס שלו נוכל לבצע את שאר הפעולות__ . ההערה הזאת חשובה, כי בעצם אם המבנה שלנו נועד למחוק ולחפש איברים בתוכו אולי ערימה היא לא המצב המתאים, ערימה נועדה לממש באופן האידיאלי את התור עדיפויות שהגדנו, ומטרתו העיקרית היא הסרה של הראש וזמן לוגריתמי ומשיכתו בזמן קבוע.

### בנייה של ערימה
לכאורה, נוכל לבנות את הערימה על ידי הכנסה של האיברים למערך ריק או עץ ריק וזה ייקח לנו בדומה למימוש של עץ בינארי $\Omega(n\log n)$ . אבל בתחילת הפרק אמרנו שאנחנו יכולים לבנות ערימה בזמן ליניארי לכמות האיברים. 
לשם הבנייה של הערימה ב $O(n)$ נגדיר פונקצייה הנקראת Heapify(i,j) . שעובדת על תת המערך שבאינדקסים הללו. באופן מדוייק יותר מה שהיא תעשה היא תעבוד על תת העץ של תת המערך הזה כאשר השורש הוא $v_i$ אבל תתעלם מכל הקודקודים שהם גדולים (או קטנים, תלוי בסוג הערימה). הכוונה היא, שכאשר אנחנו מתייחס לתת המערך $A[i\dots{j}]$ אנחנו לא באמת עובדים על כל תת המערך הזה אלא רק אל אלה שמתייחסים לתת העץ ששורשו הוא $v_i$ למשל עבור heapify(2,10) האיברים באפור הם אלה שנתמודד איתם.
![[Pasted image 20220628014204.png]]

בסופו של דבר, המטרה היא להפוך את הערכים של האינדקסים האפורים (אלה שהם חלק מתת העץ של תת המערך שנתנו בקלט) לערימה תקינה.

לשם הנוחות שבהגדרת הפעולה הזאת, נניח שכל תתי העצים של ששורשם הם הילדים של $v_i$ כלומר : $v_{2i}$ ו $v_{2i+1}$ הם ערימות בעצמם : 
![[Pasted image 20220628014559.png]]
כעת הפעולה תעבוד באופן הבא 

* $\text{check if: }A[i]\geq A[2i]\ \ \text{and, }A[i]\geq A[2i+1]$ 
אם תנאי זה מתקיים תת העץ שאנחנו עובדים עליו הוא כבר ערימה. 
* אחרת, נבצע החלפה של $A[i]$ עם הילד הגדול מבין השניים. נשמע טוב, אך כעת יש סיכוי ששברנו את תת העץ של אותו קודקוד שהחלפנו. במצב זה פשוט נבצע תיקון ריקורסיבי. 

בפסודו קוד: 
![[Pasted image 20220628015711.png]]
המשתנה maxing מחזיק בתוכו את האינדקס של השורש המקורי של תת העץ איתו אנחנו עובדים (גם אם הוא משתנה כתוצאה מהחלפה). 

__אנקדוטה__ החלפת משתנים: 
אנחנו מכירים את השיטת הקלאסית להחלפת ערכים משתנים באמצעות משתנה עזר 
![[Pasted image 20220628015916.png]]
אך ניתן לעשות את זה בלי משתנה עזר על ידי האופרטור הבינארי $XOR$ באופן הבא 
![[Pasted image 20220628015938.png]]

```ad-Code
```js
function swapWithXOR (a, b) {
    a = a^b;
    b = a^b;
    a=a^b;
    console.log("result => a: " + a + ", b: " + b)
}
```
(להסבר נוסף על [אופרטורים בינאריים](https://en.wikipedia.org/wiki/Bitwise_operation#XOR) לחצו על הלינק).

הוכחה של הטענה:
בשורה השנייה אנחנו מבצעים את זה 
![[Pasted image 20220628020442.png]]

ובשורה השלילית 
![[Pasted image 20220628020452.png]]

#### חישוב זמן הריצה של הבנייה
נבין רגע איך בונים את הערימה באופן כללי על ידי הפסודו קוד הבא
![[Pasted image 20220628020709.png]]

אנחנו בונים את הערימה __מלמטה למעלה__ ויש לזה חשיבות רבה. אנחנו יודעים מ [[#הוכחות בעצים]] שיש לעץ כמעט מלא $\frac{n}{2}$ (עם עיגול כלפי מעלה) עלים. וכל עלה הוא כמובן ערימה בפני עצמו. הבנייה מלמטה למעלה נבנת בצורה כזאת שמספר ההחלפות שנצטרך לעשות כל פעם חסום בגובה שטוח יותר מהגובה של כל הערימה במלואה. רק בקריאה האחרונה נגיע לעץ בעומק המלא. 
באופן מתמטי, אם עומק העץ המלא הוא $k$ יש $2^{1+k}-1$ קודקודים (בגלל שהשלב הראשון בעץ מתחיל מ 0 צריך להוסיף 1 לשלב האחרון כדי לקבל את גובה העץ האמיתי) אבל כל איטרציה אנחנו עובדים עם עץ נמוך יותר ולכם נקבל 
$$\sum\limits_{i=0}^{k-1}2^{i}(k-i)<n$$
אני לא אפרט למה זה נכון, בגדול מדובר פשוט בסכום של סדרה חשבונית ונקבל 
$$2^{k+1}-2-k=2^{k+1}-1-1-k=n-1-k<n$$
ולכן פעולה הבנייה שייכת ל $O(n)$ __כמו שרצינו__.


### HeapSort 
אנחנו עוד נדבר על סוגי מיונים חשובים בהמשך, אבל הייתי רוצה לדבר על המיון הזה בפרק המתאים לו כיוון שהקונספט עוד ברור לכל מי שקרא עד כה.
נניח שיש לנו מערך עם $n$ איברים. אנחנו יודעים שבבניית הערימה (בלי הגבלת הכלליות נניח שזה ערימת מקסימום) הערך הכי גבוה יהיה למעלה. נוכל לשלוף אותו ולשים אותו בסוף המערך, ולבצע שוב heapify על על תת המערך בלי האיבר האחרון. באופן זה נוכל למיין את הערימה בלי שום מקום נוסף.
![[Pasted image 20220628092923.png]]

__סיבוכיות__ אחרי כל בניית הערימה והחלפת האיבר הראשון אנחנו יודעים בוודאות שכל תתי העצים לאחר החלפה בין השורש לבין האיבר האחרון הם ערימות בעצמם, ולכן התיקון יהיה חסום במספר האיטרציות שביצענו  כלומר 
$$\sum\limits_{j=1}^{n}\log j<\sum\limits_{j=1}^{n}\log n=O(n\log n)$$
### תרגילים בערימות 
![[Pasted image 20220628095738.png]]

עבור $A$ אנחנו יודעים שמספר האיברים בו שווה ל $m=2^{k}-1$ ואנחנו יודעים ש ערימה כעץ בינארי היא עץ בינארי כמעט מלא ולכן יתקיים $k=h+1$ כלומר 
$h=k-1$. 

עבור $B$ אנחנו יודעם את הטווח מספרים שבוא $n$ נמצא שזה $\{\frac{m}{2}+1,\dots{,m}\}$  יתרה מכן אנחנו יודעים שמספר העלים בעץ בינארי שלם הוא מספר האיברים חלקי 2 מעוגל כלפי מעלה כלומר שבוודאות בגלל שגם $B$ עץ בינארי כמעט מלא אזי גם הוא יגיע לאותה קומה כמו $A$ כלומר $h-1$ 

עבור $C$ הגובה יהיה $k$ כי נבנה אותו באופן הבא:  (בלי הגבלת הכלליות נניח שעובדים עם ערימת מקסימום).
ניקח את האיבר הימני והתחתום ביותר ב $B$ (סתם בחרתי $B$ כי ביקשו $A\cup B$ אז בראש שלי אני ממיין את $B$ כתת העץ הימני), לקיחתו לא תשבור את המבנה כמו שאנחנו כבר יודעים. נמקם אותו כשורש של עץ בינארי חדש שילדיו יהיו $R_{A},R_{B}$ כלומר השורשים של שני העלים האחרים. 
כל מה שמתחת לשורש החדש הוא ערימה, רק נשאר לעשות heapify וסיימנו. סך הכל $O(\log n)$

![[Pasted image 20220628101624.png]]

__a__ מה שיקרה בגלל שערימה בנוייה כעץ בינארי שלם במהות שלה, זה יהיה מיותר לעשות heapify על החצי השני של המערך. הסיבה לכך היא שמעצם איך שהסדר בתוך המערך מוגדר החצי השני של המערך הם בכלל הילדים והמטרה שלנו היא למצוא את ההורים שלהם. לרוץ על זה מ $n$ יוביל לכך ש $n/2$ איטרציות לא נעשה כלום (כי אלה הם העלים).

__b__  הפעולה heapify לא תעבוד כיוון עבור הקלט $[5,4,3,7]$ נקבל ערימה לא תקינה. נתחיל מכך ש 5 יותר גדול מהאיברים במקום 2,3 ולכן ילדיו הם 4,3 באיטרצייה הבעיה נגיע לאיבר 4 ונגלה שהאיבר $7$ יותר גדול ממנו נכניס את האינדקס שלו ל maxind כלומר נבנה את המערך $[5,7,3,4]$  וכבר פה אפשר לראות שהערימה תצא לא תקינה כי 7 יהיה ילד של 5 בסתירה.

![[Pasted image 20220628103137.png]]
__a__
נוכל באופן כללי להכליל את הערימה שלנו למשהו שנקרא [k-ary heap](https://www.geeksforgeeks.org/k-ary-heap/) שזה ערימה מסדר $k$ במקרה שלנו ערימה מסדר 3 . 
ההבדל יהיה בבניית המערך ונגדיר את זה ככה:
יהי אינדקס $i$ השייך ל $[n]$ וקודקוד $v_i$ :
* האבא של קודקוד זה יהיה באינדקס $\lfloor\frac{i}{3}\rfloor$ .
* הילדים יהיו באינדקסים $3i,3i+1,3i+2$

(אם רוצים את הניסוח הכללי פשוט מחליפים את זה ב $k$) .

__b__ 
באופן דומה אנחנו נשים את הילד הימני ביותר בשורש ונמחק אותו מהעלה (האיבר האחרון במערך, נשים כאיבר הראשון). שלב זה לוקח $O(1)$
 לאחר מכן אנחנו נזוז בקפיצות של 3 ונבדוק את שלושת הילדים האפשריים כלומר 
 $\log_{3}(n)$ פעולות, סך הכל חסום בגובה העץ (מעבר בין בסיסים הוא קבוע ולכן) $O(\log n )$ .
 
__c__
אנחנו מקבלים מבנה הרבה יותר שטוח אבל ככל שמעלים את מספר הילדים, ככה נצטרך לעשות יותר השוואות ותיקונים במידת הצורך וגם הסיכון לשגיאות של קפיצה מהזכרון גם עולות.

![[Pasted image 20220628104827.png]]

__a__ הרעיון הוא לבנות קודם כל את הערימה במחשבה על המבנה של ערימה ותוך כדי לסדר את הערכים לפי היחס הסדר על $s$ .
__חשוב מאוד, אנחנו לא חייבים במימוש פה לתת ערימה המקיימת את ההגבלות שנתנו, הראנו שניתן לממש ערימה גם בלי קשר להגבלות האלה__

ערימת חיפוש מינימום : 
![[Pasted image 20220628105247.png]]

ערימת חיפוש מקסימום : 
![[Pasted image 20220628105358.png]]

__c,b__ 
האלגוריתם יהיה ריקורסיבי ומה שנעשה יהיה כך :
נמצא את הערך המינימלי של הערימה באוסף שלנו לפי ערכי $h$ ונסמן את השורש $(s_{0},h_{0})$ וזה יהיה השורש. לאחר מכך נבנה שני תתי מערכים תת מערך אחד עם כל האיברים הגדולים מ $s_{0}$ והשני עם מי שקטן יותר, נפעיל את האלגוריתם הריקורסיבי. מהאלגוריתם ניתן לראות שיש ערך יחיד כזה.

![[Pasted image 20220628110536.png]]
כלומר במילים פשוטות מבקשים מאיתנו מעין מיזוג של שני ערימות עבור אותה קבוצת ערכים. 

יש כמה דרכים לבנות את זה, אפרט אותן כאשר אחת היא דרך יותר תיאורטית והשנייה יותר תכנותית 

__דרך ראשונה__ 
נבנה פשוט שני ערימות , מקסימום ומינימום כאשר כל איבר מחזיק מצביע לאותו איבר בערימת המקסימום . 
באופן זה נוכל לקבל את כל היכולות של הכנסה לערימה, (פשוט מכניסים בשני ערימות במקביל) וזה כמובן חסום בגובה העץ שהוא לוגריתמי במספר האיברים.

שליפת המקסימום והמינימום בזמן קבוע כי כל אחד מהם יהיה בראש של ערימה המתאימה לו.
אם נרצה למחוק את איבר המקסימום, נמחק אותו באופן סטנדרטי מערימת המקסימום ולפני שנמחק, נשתמש במצביע שלו כדי להגיע למיקום שלו בערימת המינימום , ולמחוק אותו גם כן (בערימת המינימום לא נעבוד קשה מידי כי הוא יהיה עלה אז זה רק להחליף עם העלה הימני ביותר ולמחוק). 
כנ״ל לגבי המקסימום. 
מבחינת בנייה: זה פשוט פעמיים buildHeap לפי יחס סדר שונה שזה חסום ב $2n$ שזה כמובן זמן ליניארי $O(n)$.

__דרך שנייה (יותר הגיונית תכנותית)__ 
נבנה את הערימה באופן הבא אם הקומה היא אי זוגית אז כל האיברים מתחת לקודקודים בקומה זו יהיו יותר גדולים. אם הקומה היא זוגית אז כל האיברים מתחת לקודקודים בקומה זו יהיו יותר קטנים, למשל : 

![[Pasted image 20220628111555.png]]

באופן זה נוכל לשלוף את איבר המינימום והמקסימום ב $O(1)$ כיוון שהמקסימום תמיד יהיה בקומה שנייה והוא יהיה המקסימלי בין שני ילדים, והמינימום תמיד יהיה בקומה הראשונה. 

מבחינת הכנסה והוצאה פשוט נעשה את הבדיקות של ערימת מינימום אם אנחנו בקומה זוגית וערימת מקסימום אם אנחנו בקומה אי זוגית אלה פעולות השוואה קבועות ולכן זה לא חשוב מה נעשה שם אנחנו עדיין נהיה חסומים בגובה העץ. 

מבחינת בנייה: 
נשתמש ב buildHeap פשוט עם שני תנאים שונים בהתאם לאיזה קומה אנחנו (נוכל לבדוק על אינדקס במערך באיזה קומה הוא כיוון שאנחנו עובדים עם עץ בינארי שלם נחלק פשוט ב 2 עם עיגול כלפי כל פעם עד שנגיע ל1 או 0 וזה הגובה)ובהתאם לקומה נבחר באיזה יחס סדר להשתמש סך הכל חסום גם כן על ידי מספר האיברים.


![[Pasted image 20220628112914.png]]

__a__ במערך ממויין מסדר עולה אין צורך לבצע שום פעולות כי תמיד ה heapify יחזיר שהמערך מסודר בצורה שמתאימה לערימה.  מה שיקרה זה שנרוץ על מתודה הבנייה $n/2$ פעמים, ואז במתודה המיון נבצע עוד $n$ איטרציות כדי לבדוק שהכל תקין. סך הכל חסום ב $O(n)$ ומבחינת מספר מדוייק נעשה $1.5n$ פעולות.
   
__b__ סדר יורד זה המקרה הלא טוב של האלגוריתם כי כל איטרצייה אנחנו קודם כל נכנס לשני ההשוואות באלגוריתם , ולאחר מכן נפעיל את זה ריקורסיבי עד לגובה עץ למטה, בגלל שהסדר הפוך אנחנו במצב כזה שכל מי שאמור להיות עלה בעצם נמצא בשורשים ולכן אנחנו נעשה את heapify $n/2$ פעמים כשבכל איטרצייה אנחנו נרד לעומק הנמוך ביותר בעץ. לאחר מכן נכנס למתודה ההשוואה ששם נצטרך לבצע heapify על כל רוטצייה שנעשה כדי למיין מחדש כלומר $O(nlogn)$ גם עבור הבנייה וגם עבור המיון.


## שיטות מיון וחסמים תחתונים 
דיברנו על מספר שיטות מיון במהלך הפרקים של הספר [[#מיון מיזוג]] וגם [[#HeapSort]]בפרק זה נדבר על מספר שיטות מיון נוספות ונראה טענה מעניינת על חסם תחתון למיון בהמשך .

כמו כן נגדיר מיון יציב - כמיון שאם באוסף המקורי יש שני איברים זהים , לאחר מיון הם יהיו מסודרים לפי האינדקס שלהם ככה שזה שהיה לפני במערך המקורי יהיה לפני גם במערך החדש. 
__כל שיטת מיון אפשר להפוך למיון יציב, אדבר על כך בהמשך__ . 

נתחיל ממיונים מבוססי השוואה- כלומר הדבר היחיד שיודעים על המידע זה יחס סדר כלשהו. 

הסיבה שנרצה בכלל למיין היא שהדבר מאפשר לנו שיטות חיפוש נורא יעילות בזמן לוגריתמי כמו 
[חיפוש בינארי](https://www.geeksforgeeks.org/binary-search/?ref=lbp)
[חיפוש אקספוננציאלי](https://www.geeksforgeeks.org/exponential-search/)
בניגוד לחיפוש ליניארי שהוא חסום בגודל האיברים. 

### insertion sort
אדגים על מערך דוגמה באופן ויזואלי ונתאר בקוד 

![[Pasted image 20220628171459.png]]

כל איבר נשווה עם האיבר שמשמאלו , אם האיבר שמשמאלו קטן יותר נסמן שהאיבר שלנו נמצא במיקום שלו ונעבור לאינדקס הבא, אם האיבר שמשמאלו גדול יותר, נחליף בינהם ונמשיך להשוות אחורה עד שנגיע למצב הראשון.

על המערך שלנו זה ייראה ככה: 
* נעבור על 2 ועל 8 כי כל אחד מהם גדול מהמספר שמשמאלו.
*  נגיע ל5 והוא קטן יותר מהמספר שמשמאלו ולכן נחליף עם 8 , הוא יותר גדול מ 2 אז נא נחליף יותר ונעבור לאיבר הבא
* 3 יותר קטן מ8 ולכן נחליף עם 8 וכנל לגבי 5 
![[Pasted image 20220628172150.png]]
* ממשיכים מעל 8 ו 9, נשארנו עם 4 ומזיזים אותו על לפני האינדקס של 5 ונקבל 
$2,3,4,5,8,9$ .

__סיבוכיות הזמן היא $O(n^2)$ (זה סדרה חשבונית שמתחילה ב 1 ונגמרת ב N). עם זאת, אם המערך ממויין זה יהיה $O(n)$__ כמו כן, זהו מיון יציב


```ad-Code
```java

class InsertionSort {

	void sort(int arr[])
	{
		int n = arr.length;
		for (int i = 1; i < n; ++i) {
			int key = arr[i];
			int j = i - 1;

			while (j >= 0 && arr[j] > key) {
				arr[j + 1] = arr[j];
				j = j - 1;
			}
			arr[j + 1] = key;
		}
	}
```

### bubble sort
האלגוריתם הכי פשוט ונאיבי, 
רצים בלולאה כפולה, ועל כל איבר מקדמים אותו למיקומו המתאים באוסף, האלגוריתם לא מתאים לאוסף גדול של מידע כי הוא חסום ב $\Omega(n^2)$ . גם אם המערך ממויין. כמו כן זה מיון יציב.
__אופטימיזציה__ ניתן להוסיף flag שעוצר את הלולאה אם לא עשינו החלפה אחת .

```ad-Code
```java
	static void bubbleSort(int arr[], int n)
	{
		int i, j, temp;
		boolean swapped;
		for (i = 0; i < n - 1; i++)
		{
			swapped = false;
			for (j = 0; j < n - i - 1; j++)
			{
				if (arr[j] > arr[j + 1])
				{
					// swap arr[j] and arr[j+1]
					temp = arr[j];
					arr[j] = arr[j + 1];
					arr[j + 1] = temp;
					swapped = true;
				}
			}

			// IF no two elements were
			// swapped by inner loop, then break
			if (swapped == false)
				break;
		}
	}
```

### selection sort
המטרה של מיון זה היא להכניס כל איבר לאינדקס המתאים לו , כלומר בכל איטרציה אנחנו נמצא את האיבר המינימלי ביותר עבור המערך ונכניס אותו למיקום המתאים. כל פעם עובדים על מערך קטן ביותר כלומר באיטרציה הראשונה נרוץ כל המערך ונמצא את איבר המינימום המתאים למקום ה0 , באיטרציה השנייה נרוץ על תת המערך ללא האינדקס הזה , וכן הלאה... 
__המיון הזה אינו יציב__ 

```ad-Code
```java

class SelectionSort
{
	void sort(int arr[])
	{
		int n = arr.length;

		// One by one move boundary of unsorted subarray
		for (int i = 0; i < n-1; i++)
		{
			// Find the minimum element in unsorted array
			int min_idx = i;
			for (int j = i+1; j < n; j++)
				if (arr[j] < arr[min_idx])
					min_idx = j;

			// Swap the found minimum element with the first
			// element
			int temp = arr[min_idx];
			arr[min_idx] = arr[i];
			arr[i] = temp;
		}
	}

```

### quick sort
זה מיון בשיטת [[#הפרד ומשול]] , בוחרים pivot שזה איבר עוגן כזה שנרצה למיין את כל האיברים שגדולים ממנו אחריו ואת כל הקטנים ממנו לפניו. מסדרים אותם בשני תתי קבוצות , ומפעילים את אותו אלגוריתם עליהם בצורה ריקורסיבית . 
בחירת הpivot יכולה להיות אקראית , לרוב מומלץ לבחור את האיבר האמצעי או האחרון כ pivot . 
__איך מסדרים את איבר ה pivot במקום המתאים לו?__ 
![[Pasted image 20220628181144.png]]

בישביל זה יש מתודה שנקראת partition שלוקחת את הpivot ומוצאת את האיבר המתאים לו הדרך הקלאסים היא להחזיק מצביע שנע לאורך המערך ומצביע שמתקדם רק כאשר איברים שקטנים יותר מהpivot נכנסים מאחורים על ידי המצביע הנע. בסוף האיטרצייה המצביע השני אמור להיות במקום המדוייק ש האיבר אמור להיות בו . 

סך הכל נקבל :
```ad-Code
```java

static int partition(int[] arr, int low, int high)
{
	int pivot = arr[high];
	int i = (low - 1);

	for(int j = low; j <= high - 1; j++)
	{

		if (arr[j] < pivot)
		{

			i++;
			swap(arr, i, j);
		}
	}
	swap(arr, i + 1, high);
	return (i + 1);
}

static void quickSort(int[] arr, int low, int high)
{
	if (low < high)
	{
		
		// pi is partitioning index, arr[p]
		// is now at right place
		int pi = partition(arr, low, high);

		// Separately sort elements before
		// partition and after partition
		quickSort(arr, low, pi - 1);
		quickSort(arr, pi + 1, high);
	}
}

```

זמן ריצה: המקרה הגרוע הוא שהpivot תמיד יהיה האיבר הגדול ביותר או הקטן ביותר בכל איטרציה ואז נקבל נוסחה ריקורסיבת שצד אחד של הריקורסייה לא עובד בכלל והצד השני עובד על כל האוסף, כלומר יעשה $n^{2}$ פעולות 
במקרה הטוב תמיד נבחר את האיבר האמצעי בגודלו בכל תת מערך ואז נקבל $nlogn$. 

המיון אינו יציב. 
__נשים לב quick sort הוא מיון די מיוחד כיוון שהאלגוריתם אינו דטרמינסטי, הוא מבוסס על מידה מסויימת של אקראיות, על זה נלמד בקורס באלגוריתמיקה__.

### avl sort
שיטת המיון הפשוטה ביותר , פשוט להכניס את האיברים לעץ $AVL$ ונכניס למערך בצורה inorder. נקבל מיון ב $On\log n$ .עם זאת המיון לא יהיה inplace כלומר מיון שמסדר את האוסף ששלחנו בקלט. 

### המרה ממיון לא יציב למיון יציב
בגדול אלה הן שיטות המיון המוכרות כאשר אנחנו יודעים רק את יחס הסדר על האיברים. 
בגדול לא כל מיון הוא יציב אבל אם נרצה נוכל להמיר לכזה על ידי עבודה עם זוג סדור של האינדקס המקורי במערך ושל הrecord המקורי שעבדנו איתו. ונשנה קצת את יחס הסדר להגדיר שאם ביחס המקורי שמוגדר על הrecord יצא שיוויון, תקבע שיחס הסדר < על האינדקסים יהיה זה שיקבע.

### חסם תחתון למיונים מבוססי השוואה 
נרצה להוכיח שהמקרה הכי טוב שנוכל למיין מיון מבוסס השוואה הוא $\Omega(n\log n)$.
באופן כללי , __חסם תחתון__ לבעיה $P$ בגודל $n$ היא פונקצייה $B(n)$ המקיימת שאין אלגוריתם המאפשר לפתור את $P$ בזמן הנמוך יותר מ $B(n)$ . 
לא לכל הבעיות הצלחנו למצוא פתרונות המגיעות ל $B(n)$ הזה. עם זאת, מיון היא אחת הבעיות שכן הצלחנו להגיע. נראה עכשיו איך אפשר להוכיח שהחסם התחתון הוא אכן $\Omega(n\log n)$ , כמו כן אנחנו מנהלים את הדיון רק למיונים מבוססים השוואה (בינם לבין עצמם בלבד). ישנם מיונם שבהם יש חסם על ערך האיברים ואז ניתן להשתמש בטכניקות אחרות שנדבר עליהן בהמשך (count sort and radix sort) . 

בישביל להוכיח נבנה משהו שנקרא __עץ החלטות__ 
בשיביל להתחיל לבנות אותו נרצה קודם כל להגדיר אלגוריתם מיון על ידי __כלל ההשוואות שאפשר לבצע על האיברים בתוכו__ נסמן $i:j$ את ההשוואה של האוסף באינדקס $i$ עם האינדקס $j$ . אוסף ההשוואות מכל מיון ייראה מהצורה 

![[Pasted image 20220628185652.png]]

עץ ההחלטות של מיון הוא עץ בינארי המכיל את אפשרויות המיון שנקבל עבור רצף השוואות מסויים. כאשר שורש העץ מכיל את כל הסידורים האפשריים לאוסף זה, 
למשל זה יהיה עץ החלטות עבור אוסף המכיל את האיברים $a_{1},a_{2},a_{3}$ עם סדר המיון 
![[Pasted image 20220628190141.png]]

![[Pasted image 20220628190200.png]]
הרמה ה $i$ בעץ יתאר את המידע שיש לנו אחרי וכל קודקוד יכיל את המידע המתאים להשוואה שבחרנו. 

השורש תמיד יכיל $n!$ אפשרויות. כיוון ש מדובר בשתי תוצאות אפשרויות לכל השוואה בהכרח יהיו שני ילדים לכל קודקוד. 
אבל איך מכלילים את כל הסיפור הזה כי עד עכשיו דיברנו על סדר השוואות ספציפי וסדר השוואות מאוד מסויים . לשם כך נשתמש בתכונות העצים הבינאריים. אנחנו יודעים שתמיד יהיו $n!$ אפשרויות סדר התחלתי לאיברים ושהאופצייה הנכונה תמיד תהיה באחד העלים.

אנחנו יודעים בעץ בינארי יש לכל היותר $2^h$ עלים. על מנת שכל אפשרויות הסידור יהיו בעלים צריך שיתקיים 
$$2^{h}\geq n!\leftrightarrow h\geq\log_{2}n!$$
כלומר אם הגובה לא הגיע למספר הזה בוודאות יש עלים שמכילים יותר מצירוף אחד אחרי השווה , למעל לא נצליח למיין מערך עם 5 איברים ב 6 השוואות  כי $2^6=64$ אבל $5!=120$ כלומר אחרי 6 השוואות יהיו רק 64 עלים אז אין סיכוי להשיג את התוצאה הרצוייה .  וזה לא תלוי בכלל באיך נבחר לעשות את ההשוואות. נוכל להדגים על דוגמה אחת ובגלל שמה שמעניין זה מספר העלים אנחנו נקבל תוצאה גורפת. עכשיו כשאנחנו יודעים שזה נכון באופן כללי, נמשיך לעבוד על הביטוי ונקבל : 

$$\log(n!)=\log(\pi_{i=2}^{n}(i))<\log(n\cdot n\cdot n\dots n)=\log(n^{n})=n\log n$$
וזה החסם מלמעלה, אם נרצה חסם תחתון : 

$$\displaylines{
\log(n!)=\log(\pi_{i=2}^{n}(i))>\log\bigg((\frac{n}{2}+1)\cdot(\frac{n}{2}+2)\dots(n-1)n\bigg)\\
>\log((\frac{n}{2})^{\frac{n}{2}})=\frac{n}{2}\log \frac{n}{2}
}$$
וסה״כ ניסנו להוכיח חסם תחתום אבל הוכחנו חסם הדוק על מיון מבוסס השוואה שאומר שמספר ההשוואות הזקוקות כדי למיין $n$ איברים , חסום הדוק ב $\Theta(n\log n)$ ולכן כל אלגוריתם שממיין בזמן זה הוא אופטימלי.


## מיונים אחרים 
דיברנו על מיונים מבוססי השוואה בלבד אבל הרבה פעמים אנחנו נדע עוד מידע על הrecord ושאיתו אנחנו עובדים. נוכל לנצל את המידע הזה כדי למיין בזמן יעיל יותר מהחסם שהראנו למעלה. בפרק זה נתמקד במיון ה $Count sort$ ו $RadixSort$ שהוא המשך ישיר של הקודם.

### count sort
מיון מנייה כשם הוא מתבסס על כך שאפשר למנות את מספר הערכים שאותו ערך נמצא ולאחר מכן ניקח את הrecord שהופיע הכי הרבה פעמים . בישביל שזה יוכל לעבוד צריך שיהיה טווח לערכי ה record שיכולים להופיע. אנחנו נדגים את זה על מספרים שלמים אבל אפשר לקחת את זה למחוזות נוספים כמו תווים וכו.

יהי $A[n]$ מערך בגודל n כך שערכיו שייכים לקטע הסגור $[0,R]$ כאשר הקטע מכיל רק מספרים טבעיים.

__השיטה__ 
* יצירת מערך חדש בגודל $R$ כך שהתא ה $i$ ישמש למספר הפעמים שהאיבר $i$ הופיע במערך $A$ . לדוגמה:  
![[Pasted image 20220628201717.png]]

רצים על המערך וכל ערך שנתקל בו נוסיף מנייה לאינדקס המתאים לו, סך הכל נקבל : 

![[Pasted image 20220628201820.png]]

כעת, אנחנו יודעים כמה פעמים כל איבר , נרצה לסדר את האיברים במערך המקורי לפי סדר הופעת במיון יציב.

כעת כדי לדעת איפה כל איבר $i$ נמצא במערך $A$ נחשב את סכומי הרישות של האינדקס $i$ במערך $C$ .

![[Pasted image 20220628203601.png]]
(לדוגמה באינדקס 2 חישבנו את 0 + 2 כי זה מה שיש באינדקסים 0 ,1) 
עכשיו כל איבר ב $c$ מייצג את המיקומים שאותו $i$ מופיע במערך המקורי בצורה הממויינת (למשל 2 יהיה במיקום השלישי במערך החדש, כי 4 מייצג את המיקום אם הסדרה הייתה מתחילה מ 1 אבל מערך מתחיל מ 0).

סה״כ רצים על איברי המערך $A$ שוב פעם, על כל ערך נלך למערך $C$ באינדקס הערך, המיקום במערך החדש יהיה $C[i]-1$  (נשמור את הערך הזה במערך $C$ כי פעם הבאה שנתקל שוב בערך $i$ ב $A$ נדע מייד איפה למקום פשוט נעשה את אותו הדבר שוב, באופן זה נקבל מיון יציב גם עבור מופעים שמופיעים כמה פעמים).

פלט:
![[Pasted image 20220628204534.png]]

__סיבוכיות__ 
![[Pasted image 20220628204608.png]]

```ad-Code
```cpp

void countingSort(int array[], int size) {
  int output[10];

  // Find the largest element of the array
  int max = array[0];
  for (int i = 1; i < size; i++) {
    if (array[i] > max)
      max = array[i];
  }

  int count[10];

  // Initialize count array with all zeros.
  for (int i = 0; i <= max; ++i) {
    count[i] = 0;
  }

  // Store the count of each element
  for (int i = 0; i < size; i++) {
    count[array[i]]++;
  }

  // Store the cummulative count of each array
  for (int i = 1; i <= max; i++) {
    count[i] += count[i - 1];
  }

  for (int i = size - 1; i >= 0; i--) {
    output[count[array[i]] - 1] = array[i];
    count[array[i]]--;
  }

  // Copy the sorted elements into original array
  for (int i = 0; i < size; i++) {
    array[i] = output[i];
  }
}


```

### radix sort 
מיון radix נועד לפתור את הבעיה הבעיה, שלפעמים אנחנו נקבל טווח נורא גדול של ערכים על קבוצה קטנה של מספרים. למשל עבור קבוצה $S$ של $n$ מספרים שטווחם יהיה $[n^{c}]$  להשתמש ב select sort יהיה לא יעיל. 
הרעיון כאן הוא שבמצב שאנחנו עובדים עם מספרים , נוכל למיין לפי ספרות המספר ולא לפי הטווח שהוא נמצא בו.  (בישביל זמן יעילות אופטמילי צריך להמיר לבסיס שהוא $n$ כלומר אם הטווח הוא $10^6$ למשל, נרצה שכל המספרים יהיו בבסיס 10). (המרה בין בסיסים היא קבועה מבחינתנו).

__נוכל למיין לפי ה $msb$ ולקבל מיון גס, נוכל לרדת בספרות כל פעם כדי לקבל מיון מדוייק יותר__ 
 דוגמה ויזואלית 
![[Pasted image 20220628224316.png]]

הקלט יהיה המערך $A$ והספרה המקסימלית האפשרית (כלומר נמצא את המספר המקסימלי במערך בזמן ליניארי) $d$ , כעת נמיין במיון מנייה[[#count sort]] לפי הספרה ה $i$.
```ad-Code
```java

class RadixSort {

  void countingSort(int array[], int size, int place) {
    int[] output = new int[size + 1];
    int max = array[0];
    for (int i = 1; i < size; i++) {
      if (array[i] > max)
        max = array[i];
    }
    int[] count = new int[max + 1];

    for (int i = 0; i < max; ++i)
      count[i] = 0;

    // Calculate count of elements
    for (int i = 0; i < size; i++)
      count[(array[i] / place) % 10]++;

    // Calculate cumulative count
    for (int i = 1; i < 10; i++)
      count[i] += count[i - 1];

    // Place the elements in sorted order
    for (int i = size - 1; i >= 0; i--) {
      output[count[(array[i] / place) % 10] - 1] = array[i];
      count[(array[i] / place) % 10]--;
    }

    for (int i = 0; i < size; i++)
      array[i] = output[i];
  }

  void radixSort(int array[], int size) {
    // Get maximum element
    int max = getMax(array, size);

    for (int place = 1; max / place > 0; place *= 10)
      countingSort(array, size, place);
  }

}
```

סיבכויות :
![[Pasted image 20220628225138.png]]
כאשר $k$ זה המספר החד ספרתי הגבוה ביותר בבסיס איתו אנחנו עובדים. (נשים לב שבפועל עושים $d$ פעמים $n+k$ אבל $d$ הוא קבוע כי לכל מספר יש אורך סופי).


## מציאת האיבר ה $k$ בגודלו 
הרבה פעמים נרצה למצוא את איבר החציון באוסף מסויים (אפילו פתרנו תרגיל כזה ב[[#תרגילים הפרד ומשול]]) . על פניו נשמע שכדאי לנו למיין וככה נוכל למצוא כל איבר שנרצה אבל לפעמים נרצה איבר במיקום ספציפי או רק את איבר החציון (האיבר האמצעי באוסף שלנו אם הוא היה ממויין) ואין סיבה למיין את כל האוסף בישביל זה כי הוכחנו בפרק הקודם שיש חסום הדוק על מיון מבוסס השוואה והוא לא חסם כזה טוב. במונח מקצועי זה יהיה $overkill$.

הרמז שלנו לתחילת הרעיון לפתרון מציאת החציון, יהיה להסתכל על [[#quick sort]]. הבעיה בגישה של quick sort לפתרון של מציאת איבר באינדקס מסויים בפרט האיבר האמצעי תהיה שיש סיכוי גבוה שחלק מסויים בריקוסיה לא יעשה כלום (אם בחרנו pivot באופן כזה שלאחר סידור תת המערך הימני או השמאלי לא יכילו את $n/2$ אז אין מה לעשות על החלק הזה partition בכלל בריקורסיה הבאה) אבל קוד ריקורסיבי מתבסס על חלוקה לתתי בעיות שפתרונן יוביל לבעיה גדולה, איך זה מתיישב עם העובדה שיש לנו עכשיו תת בעיה שהיא לא רלוונטית בכלל? 

הרבה פעמים הכללה של הבעיה שלכאורה תיראה קשה יותר, תהיה בעצם קלה יותר לפתרון. במקום לפתח אלגוריתם שמחזיר את החציון , נכליל את הבעיה למציאת אינדקס מסויים $k$ . בהינתן מערך ואינדקס נחזיר את האיבר באינדקס הזה אם המערך היה ממויין. (האיבר ה k בגודלו).

![[Pasted image 20220628231652.png]]


וכעת נוכל לבחור ![[Pasted image 20220628231708.png]]

הגמישות שקיבלנו על ידי הכנסת אינדקס מאפשר לנו לדעת יותר טוב עם איזה תת מערך כדאי לנו לעבוד אחרי ה partition. 

מבחינת סיבוכיות עדיין נקבל שבמקרה הגרוע כמו ב [[#quick sort]] נקבל $\Omega(n^2)$ , אבל במקרה הטוב, שהpivot תמיד נופל באמצע נקבל 
$$T(n)=n+T(\frac{n}{2})=O(n)$$
לפי נוסחת המאסטר.


נשאלת השאלה, האם נוכל לבנות אלגוריתם דיטרמינסטי , התשובה היא כן. גם פה אופן ההסתכלות יהיה למצוא קירוב של איבר החציון (כמו שבאלגוריתם הלא דטרמינסטי בחרנו להכליל על מנת שנוכל למצוא את החציון). אופן האלגוריתם ילך בצורה הבאה : 

* חלוקת המערך לחמישיות (תתי מערכים של 5 איברים בכל מערך) ובכל אחד כזה מציאת החציון (הראנו שאפשר לעשות זאת ב 8 צעדים ובהמשך נראה שאפשר גם ב7).
* נבנה מערך חדש המכיל את חציוני החמישיות שלנו
* מציאת חציון החציונים על ידי שימוש באותו אלגוריתם על המערך החדש.
* כעת יש לנו את איבר האמצע, ניקח את ערכו נסמנו $x$ 
* מאופן סידור החציונים אנחנו נקבל אחרי כל חציון שנמצא שהאיברים מימין יהיו הגדולים יותר והאיברים משמאל יהיו הקטנים יותר אבל לאו דווקא בסדר ממויין כלומר שיתקיים : 
![[Pasted image 20220628234534.png]]
אלה המיקומים שיהיו אם ה$k$ גדול יותר מהאמצע או קטן יותר מהאמצע. 
* נבצע חיפוש ליניארי בצד הרלוונטי עד שנגיע לאיבר. 

נבנה לזה נוסחת נסיגה (היא יכולה להיות קצת מורכבת) : 

![[Pasted image 20220628234715.png]]

לפיכך יתקיים כי :

$$T(n_{i})=T(\frac{n_{i}}{5})+T(n_{i+1})+O(n)$$
צריך לבטא את $n_{i+1}$ עם $n_i$ כאשר $n_{i+1}$ זה מספר האיברים שנשארו שעליהם נעשה חיפוש ליניארי.

לא אפרט את ההסבר המדוייק אבל $n_{i+1}$  יקיים שהוא יהיה לכל היותר $\frac{7}{10}n_{i}$ כלומר 
$$T(n_{i})=T(\frac{n_{i}}{5})+T(\frac{7}{10}n_{i})+O(n)$$

נוכיח על ידי שיטת ההצבה שזה שייך ל $O(n)$ . נניח ש $T(n)<cn$  ונוכיח באינדוקצייה. 

__בסיס__ : $T(1)=1$ ולכן בהכרח מתקיים הנ״ל 
__צעד__: נניח שהטענה מתקיים לכל $n_{0}<n$ ונוכיח עבור $n$ :
![[Pasted image 20220628235948.png]]
__האי שיוויון נובע מהנחת האינדקוצייה כמובן__ .

יתקיים שהביטוי שיצא לנו יהיה קטן מ $cn$  לכל $c\geq 10$. ולכן $T(n)\in{O(n)}$ __כדרוש__ 

### תרגילי מיונים וחסמים תחתונים 
![[Pasted image 20220629000302.png]]

נסמן את האלמנטים שלנו $a,b,c,d,e$ כל ההוכחה תהיה בלי הגבלת הכלליות כיוון שיש המון אפשרויות ואנחנו רוצים רק אפשרות אחת.

נניח $a>b$ וגם $c>d$  (בוצעו 2 השוואות). כעת נניח $a>c$ ויתקיים $a>c>d$  כעת יש לנו את האוסף $abc$ ונכניס את $e$ למקום המתאים על ידי השוואה שלו עם $c$ ולאחר מכן בהתאם לתוצאה השוואה נוספת עם $a$ או $b$  (סך הכל עוד 2 השוואות, עד כה 5 השוואות) . כעת יש לנו 4 מיקומים אפשריים ל $e$ ואנחנו כבר יודעים ש $b$ קטן יותר מ $a$ ונוכל גם את $b$ לדעת לאן להכניס על ידי השוואה עם $c$ או $e$ או $d$ (תלוי איפה הכנסו את $e$ כלומר באיזה אפשרות מהאופציות אנחנו נמצאים).

![[Pasted image 20220629002554.png]]
__a__ לכל שקילה יש 3 אפשרויות , ומספר התשובות הוא 24 כי לכל כדור שנבחר אם הוא התשובה יכול להיות לו עוד שני אפשרויות כלומר 12 כפול 2 אופציות (כדור כבד יותר או קל יותר). 

כלומר במקרה הטוב נקבל פתרון לוגריתמי (המקרה הזה אם כל כל שקילה שנעשה נקבל את התוצאה גדול או קטן וככה כל פעם נפסול חצי מערך) כלומר $\lceil\log_{3}(24)\rceil=3$ 

__b__ נחלק את 12 הכדורים ל3 קבוצות של 4 ונשקול כל אחת מהן נסמנן $a_{1},a_{2},a_{3}$ 
נשווה את $a_1$ עם $a_2$ ונחלק למקרים 

 $a_{1}=a_{2}$ : אז הקבוצה עם הכדור החריג היא $a_3$  , נוציא כדור שרירותי מהקבוצה הזאת וכדור שרירותי מאחת הקבוצות האחרות ונשווה בינהם , אם הן שוות אז הכדור שהוצאנו מ $a_3$  הוא החריג ורק נשווה אותו עם הכדור החריג השני כדי לדעת את המאזן. 
 אם שלושת הכדורים שנשארו כבדים או קלים יותר (זה בהכרח האופצייה השנייה) קודם כל אנחנו מקבלים את המאזן בשלב הזה, כעת, ניקח משם שני כדורים ונשווה בינהם. אם הם שווים אז הכדור השלישי הוא החריג עם המאזן שקיבלנו למעלה, אחרת אנחנו יודעים בוודאות מי הכדור (אלה ששמנו אל המאזניים) ומה המאזן שלו. 
__האלגוריתם חוזר על עצמו גם במצבים אחרים אז לא אפרט__ .

__c__ $\lceil\log_{3}(26)\rceil=3$ 

__d__ אם נשווה בין קבוצות של 4 ונקבל שהם שווים נקבל 5 כדורים לפחות שיש לעבוד איתם על 2 השוואות. אין לנו איך להשוות בין החמישה ולדעת בפעם אחת מי הוא הכדור כיוון שיש 10 אפשרויות גם אם נחלק ל2 ונגלה שהם שווים  עדיין לא נדע מה המאזן של הכדור השלישי.

![[Pasted image 20220629012059.png]]
נניח שההתסברות עבור אוסף כלשהו בגודל $n$ כדי לקבל את המערך במצב ממויין הוא $1-\frac{1}{n\log n}$. עבור הסיכוי שנקבל את התוצאה הזאת , עדיף לנו לעשות בדיקה ליניארית כדי לבדוק שהמערך ממויין ואם לא, לבצע מיון כמו $mergesort$ החסום ב $O(nlogn)$ . בהינתן שנקבל את האפשרות הזאת  יתקיים 
$$(1-\frac{1}{n\log n})\cdot O(n)+\frac{1}{n\log n}\cdot O(n\log n)=O(n)-\frac{1}{\log n}+1\in O(n)$$
![[Pasted image 20220629014932.png]]
נניח בשלילה שהכנסה לעץ בינארי לוקחת פחות מ $\Omega(n\log n)$ פעולות . הדפסת $inorder$ תמיד לוקחת $O(n)$ פעולות כלומר זמן, לכן חיבור הפעולות אמור לקחת פחות מ  $\Omega(n\log n)$ __בסתירה__ לחסם תחתון למיון על בסיס השוואה.

![[Pasted image 20220629015629.png]]

נניח $k=2^i$ נחלק את המערך ל $k$ תתי מערכים ונבצע את אלגוריתם מציאת חציון החציונים סך הכל הכל זה ייקח $O(n\log k )$ .
אחרת נעגלת למעלה את $logk$ ונגדיר ונוסיף איברי דמה שערכים יהיה אינסוף  לאוסף שלנו כדי שיהיה אפשר לחלק את האוסף שלנו לתתי קבוצות ולחפש את חציון החציונים על ידי חלוקה לתתי מערכים בזמן לוגריתמי ל $k$ (ההפרש בין הקבוצות זה קבוע ולכן עדיין תלוי ב $k$).

![[Pasted image 20220629020820.png]]

כעת כשאנחנו מקבלים את אופן החלוקה (לא נחלק יותר ל 5) נוסחת הנסיגה תהיה מהצורה : 
$$T(n)=T(\frac{n}{2})+T(\frac{7}{10}n)+cn$$
במצב זה לא נצליח להוכיח שזמן הריצה הוא ליניארי. 

__למה בעצם זה לא יהיה זמן ליניארי?__ לא ממש דיברנו על התרחיש הזה אבל משהו שהוכחנו בספר הוא שבהינתן 
$$T(n)\leq T(\alpha_1n)+T(\alpha_2n)+T(\alpha_3n)+\dots+T(\alpha_in)+cn$$
אז יתקיים 

![[Pasted image 20220629021330.png]]


