__סער אזערי__

במהלך הסיכום יעלו הרבה טענות הנשענות על [[#נושאי עזר]] הנמצאים בסוף הסיכום, מומלץ לעבור עליהם בסוף או אם לא הבנתם משהו במהלך הקריאה.

# הפרד ומשול
בהגדרה - הפרד ומשול זוהי פרדיגמה לתכנון אלגוריתם המשתמשת בריקורסיה על מנת להפוך בעייה קלה לבעיות קלות יותר , זאת באה עם היתרונות והחסרונות שלה , למשל אנחנו עלולים לחשב מספר ערכים , מספר רב של פעמים כפי שנראה בפרק של [[#תכנון דינאמי]]. 
הרעיון מאחורי הפרדיגמה של הפרד ומשול היא פשוטה ואומרת : 
* תפריד את הבעיה לבעיות קטנות יותר (__הפרד__). 
* תפתור את הבעיות הקטנות יותר(__משול__).
* מזג את התוצאות.

![[Pasted image 20220621181444.png|400]]

היכולת הזאת לפשט את הבעיה מאפשרת לנו לפתור בעיות ביעילות ריצה שלא היינו מגיעים אליה בתכנות לא רקורסיבי. 

כעת נראה מספר בעיות הניתנות לפתרון בעזרת ריקורסייה.

### מינימום ומקסימום 
##### מינימום
נניח שיש לנו מערך $A[n]$ (האלמנטים יכולים להיות מכל סוג כל עוד יכולת ההשוואה מוגדרת על אותו הסוג). ננסה למצוא את איבר המינימום  של המערך הזה 

$$\text{min index m} :\forall{i\in[n]}:\ \  A[m]\leq{A[i]}$$

 הפתרון הטריוויאלי העולה בראש של כל מתכנת, היא להחזיר משתנה מקומי $min$ ולשמור אליו את הערך המינימלי תוך כדי ריצה על המערך. או בתיאור פסודו:
  
 ![[Pasted image 20220621182038.png]]


עם זאת אנחנו נאלץ לבצע $n-1$ השוואות ונרוץ על כל המערך, לא נשמע כזה נורא אך ניתן לפתור את זה אחרת . 

נוכל אולי לבטא את $n$ כביטוי בחזקת $2$ למשל $2^{m}$ ונוכל לחלק את המערך שלנו לזוגות (אולי יישאר איבר בודד אבל זה לא משנה),  נשווה כל זוג והמנצח ממשיך לשלב הבא ככה עד שנשאר איבר אחר (מעין טורניר בודוקאי). 

בפסודו: 
![[Pasted image 20220621182524.png]]
__נשים לב שאנחנו רוצים לזוז כל פעם בקפיצות ביחס לקומה בה אנחנו נמצאים ככל ש i מתקדם ככה יש פחות ופחות איברים במערך , על מנת שלא נקצה עוד זכרון נרוץ בקפיצות המתוארות למעלה__.

באופן ויזואלי : 
![[Pasted image 20220621182639.png]]


האם שיפרנו משהו? עבדנו קצת קשה אבל סך הכל נראה ש נקבל 

$$\frac{n}{2}+\frac{n}{4}+\dots+2+1=n-1$$


נשאלת השאלה, האם הדבר במקרה? 

לכל שיטה בה נבחר אנחנו תמיד נצטרך לעבור על $n$ האיברים במערך כדי לדעת האם האיבר עליו אנחנו עומדים הוא המינימום או לא. כלומר אנחנו תמיד נמצא את עצמנו בונים מעין עץ בינארי שלם  לכל השוואה שנבחר וכפי שנדבר בהמשך , 

__לכל עץ בינארי עם $n$ עלים, יש בידיוק $n-1$ קודקודים פנימיים__. 
לכן על מנת למצוא את המינימום נצטרך לעשות $n-1$ השוואות, לא ניתן לייעול.

##### מקסימום 
נשמע שזאת אותה הבעיה לא? פשוט להחליף את הסימן (להחליף $\leq$ ב $\geq$ ).
המעבר בין בעיה א׳ לבעיה ב׳ הוא אלגוריתם בפני עצמו הנקרא [reduction](https://en.wikipedia.org/wiki/Reduction_(complexity)) , זהו כלי בסיסי אך אפשר לדבר עליו רבות.

במקרה הזה המעבר די פשוט והוא עוזר לנו גם לדעת שנדרשת $n-1$ פעולות על מנת למצוא את המקסימום.


##### מינימום ומקסימום ביחד 
נוכל פשוט לחבר את שתי התוכנות לפעולה אחת ולקבל את התוצאה ב $2n-2$ שהיא חסומה ב $O(n-1)$ כמו השיטות הקודמות .

![[Pasted image 20220621185317.png]]

אבל בואו ננסה לייעל את השיטה הזאת , 
  דרך אחת תהיהי להוסיף $else$ בין שני ההשוואות כי כמובן שאם אחת מתקיימת השנייה לא. במערך עולה ממויין עם זאת, עדיין נקבל $2n-2$ פעולות. לא רע במיוחד אבל נוכל לייעל .

כעת, סוף סוף נוכל לדבר ולהראות איך נשתמש ב __הפרד ומשול__ כדי לפתור בעיות,

הפעולה תחזיר $(M,m)$ אחד מייצג את המקסימום ואחד את המינימום (לתוהים ששואלים איך אפשר להחזיר דבר כזה בתכנות, פשוט בונים struct , class או tuple). 

__הפרד__ - נחלק את המערך לחצי כל פעם - תנאי העצירה יהיה כאשר גודל תת המערך הוא 2 ואז נוכל להחזיר השוואה רגילה .

__משול__ - על כל תת מערך שמאלי וימני נפעיל רקורסיבית את הפעולה שוב פעם.

__מזג__ - נחזיר את המקסימום בין $M_{1,2}$ כאשר $1$ זה תת המערך השמאלי ו $2$ זה תת המערך הימני.  באופן דומה נחזיר את המינימום בין $m_{1},m_{2}$ .

```ad-Code
``` psudo
Algorithm: Max - Min(x, y)
if y – x ≤ 1 then
return (max(numbers[x], numbers[y]), min((numbers[x], numbers[y]))
else
(max1, min1):= maxmin(x, ⌊((x + y)/2)⌋)
(max2, min2):= maxmin(⌊((x + y)/2) + 1)⌋,y)
return (max(max1, max2), min(min1, min2))
```

 נחשב את זמן הריצה : 
 עבור $n$ שקטן או שווה ל$2$ אז זמן הריצה זהו זמן ריצה קבוע , לכן מה שמעניין זה כאשר $n>2$ .

$$T(n)=2\cdot T(\frac{n}{2})+2=\dots=1.5n-2\in O(n)$$

צמצמנו את זמן הריצה אבל זה לא ממש נחשב שיפור, וזה בלי לקחת בחשבון את העובדה שהריקורסייה תופסת יותר זכרון ואולי בכלל עדיף את הקוד הליניארי והשימוש בלולאה כמו מקודם... אבל עדיין זאת דרך לעבוד עם הפרד ומשול. 


### מיון מיזוג 
הצורך להחזיק אוסף מסוייף בסדר כלשהו הוא צורך תמידי הניכר בכל תחומי חיינו, גם בתכנות הרבה מאוד פעמים נרצה את המידע שלנו בסדר כלשהו. השיטה הטירוויאלית שכולם מכירים bubble sort היא המוכרת מכולם והפשוטה מכולם אך היא לוקחת $\Omega(n^{2})$ השוואות. 

באלגוריתם מיון המיזוג נשתמש בהפרד ומשול כדי לייעל את זמן המיזוג שלנו:

__הפרד__ - כל פעם נחלק את המערך לשני חצאים. 

__משול__ - ברגע שנגיע למערך בגודל 2 נחליף את סדר האיברים בהתאם לגודלם 

__מיזוג__ - לאחר שסידרנו כל תת מערך נחבר את החלקים למערך אחד גדול וממויין.

קוד המיזוג יהיה מאוד נאיבי כמובן שצריך לדעת באיזה אופן למזג וזה לא מספיק סתם לחבר בין שני המערכים, ישנם מספר דרכים למזג בין מערכים לא אפרט את כל התהליך כי זה לא רלוונטי , חשוב לדעת שכולן בסך הכל לוקחות $O(n)$ מבחינת זמן ריצה
 מצרף פה כמה אימפלמנטציות אפשריות : 

##### TOP - DOWN 
```ad-Code
``` cpp 

// Split A[] into 2 runs, sort both runs into B[], merge both runs from B[] to A[]
// iBegin is inclusive; iEnd is exclusive (A[iEnd] is not in the set).
void TopDownSplitMerge(B[], iBegin, iEnd, A[])
{
    if (iEnd - iBegin <= 1)                    // if run size == 1
        return;                              // consider it sorted
    // split the run longer than 1 item into halves
    iMiddle = (iEnd + iBegin) / 2;          // iMiddle = mid point
    // recursively sort both runs from array A[] into B[]
    TopDownSplitMerge(A, iBegin,  iMiddle, B);  // sort the left  run
    TopDownSplitMerge(A, iMiddle,    iEnd, B);  // sort the right run
    // merge the resulting runs from array B[] into A[]
    TopDownMerge(B, iBegin, iMiddle, iEnd, A);
}

//  Left source half is A[ iBegin:iMiddle-1].
// Right source half is A[iMiddle:iEnd-1   ].
// Result is            B[ iBegin:iEnd-1   ].
void TopDownMerge(A[], iBegin, iMiddle, iEnd, B[])
{
    i = iBegin, j = iMiddle;
 
    // While there are elements in the left or right runs...
    for (k = iBegin; k < iEnd; k++) {
    // If left run head exists and is <= existing right run head.
        if (i < iMiddle && (j >= iEnd || A[i] <= A[j])) {
            B[k] = A[i];
            i = i + 1;
        } else {
            B[k] = A[j];
            j = j + 1;
        }
    }
}
```

##### BOTTOM - UP 

``` ad-Code
```cpp
//  Left run is A[iLeft :iRight-1].
// Right run is A[iRight:iEnd-1  ].
void BottomUpMerge(A[], iLeft, iRight, iEnd, B[])
{
    i = iLeft, j = iRight;
    // While there are elements in the left or right runs...
    for (k = iLeft; k < iEnd; k++) {
   // If left run head exists and is <= existing right run head.
        if (i < iRight && (j >= iEnd || A[i] <= A[j])) {
            B[k] = A[i];
            i = i + 1;
        } else {
            B[k] = A[j];
            j = j + 1;    
        }
    } 
}
```

סך הכל הפסודו קוד יהיה מהצורה של אלגוריתם המיון יהיה מהצורה 

![[Pasted image 20220621202353.png]]

ננתח את הסיבכויות זמן ריצה לפי שיטת המאסטר 
$$T(n)=2T(\frac{n}{2})+n$$
לפי שיטת המאסטר נקבל שמספר הפעולות הריקורסיבי שווה למספר הפעולות הלא ריקורסיביות ולכן 
$$T(n)\in\Theta(n\cdot\log_{2}(n))$$
(הבסיס הדיפולטי בסיכום זה יהיה 2 תמיד, רשמתי את זה פה רק כדי שיהיה ברור).


__אנקדוטה__ - כל אלגוריתם מיון על מידע שכל מה שידוע עליו הוא יחס הסדר תמיד יהיה חסום ב $O(nlogn)$. 

### כפל של מספרים גדולים
על פניו נשמע כמו כותרת מוזרה כי תכנותית אנחנו רושמים פשוט
$\text{return }x\cdot{y}$ 

אז מה זה אומר בכלל ? נסתכל על הבעיה באופן תיאורטי ונניח שגודל המספר יכול להיות אין סופי , למרות שבמעבדי 64 ביטים הייצוג המקסימלי של מספר מספיק לרוב הבעיות שאנחנו מתמודדים איתם, נרצה להבין תיאורטית איך ניתן לייעל כפל כזה בהינתן שאנחנו מקבלים קלטים בגדלים לא ידועים השואפים למספר אינסופי.

יהי $X ,Y$ שני מספרים ששניהם באורך $n$ ביטים (כלומר בייצוג הבינארי שלהם). נניח את אורך הביטים בלי הגבלת הכלליות כיוון שאם נרצה להקטין מספר פשוט נשים כמה 0 שצריך מה msb .

אז איך בכלל מתחילים לחשב זמן ריצה של דבר כזה? שלא לדבר על איך משתמשים בהפרד ומשול כדי לחשב את זה ... לפי החוקים של כפל אנחנו בעצם נבצע $n^{2}$ פעולות כפל וחיבור באלגוריתם הנאיבי ולכן חסום ב $\Theta(n^2)$ . 

![[Pasted image 20220622101259.png]]

זה בשיטה הנאיבית. ננסה לראות כמה יצא לנו על ידי שימוש בהפרד ומשול 
נגדיר $X=x_{1}x_{2}x_{3}\dots x_{n}$  וגם $Y=y_{1}y_{2}y_{3}\dots{y_{n}}$.  כאשר כל ספרה שייכת לקבוצה הבינארית וכל ספרה היא ביט.

נחלק באמצע את מספר הספרות באופן הבא 

![[Pasted image 20220622102015.png]]

כעת כמו שניתן לפרק מספר לספרות בבסיס 10 נעשה זאת על המספרים שלנו באופן הבא 
$$\displaylines{
X=X_{1}2^{\frac{n}{2}}+X_{2}\\
Y=Y_{1}2^{\frac{n}{2}}+Y_{2}
}$$

הכפל בינהם יהיה 

$$XY=X_{1}Y_{1}2^{n}+(X_{1}Y_{2}+X_{2}Y_{1})2^{n/2}+X_{2}Y_{2}$$
וכאן בעצם יש לנו איזשהי זהות ריקורסיבית וזהות זאת תהיה המשול שלנו, על כל תתי מספרים בינאריים ניקח את החצאים וננחשב רקורסיבית את הביטוי המתמטי הזה.

בפסודו קוד זה ייראה ככה : 

![[Pasted image 20220622103239.png]]

ומבחינת סיבוכיות זמן ריצה נקבל 

$$T(n)=4T(\frac{n}{2})+cn$$
כאשר $cn$ מייצג את כל הפעולות הלא ריקורסיביות כמו העלאת חזקה וכל פעולות החיבור שנעשה.
לפי שיטת המאסטר נקבל שהסיבוכיות הזאת היא גם כן $\Theta(n^{2})$ וזה לא עזר. נוכל לייעל את הזמן ריצה הזה אך לא בהרבה על ידי כך שנשים לב שמתקיים 

$$E=(X_{1}+X_{2})(Y_{1}+Y_{2})=X_{1}Y_{1}+X_{1}Y_{2}+X_2Y_{1}+X_{2}Y_2$$
נסמן $A=X_{1}Y_{1}$  ו $B=X_{2}Y_{2}$ 

כלומר באמצע החישוב של $A,B$ נוכל לייצר תלות עם הביטוי האמצעי ולחסור פעולה ריקורסיבית אחת, נקבל זמן ריצה קצת יותר יעיל של $n^{1.5}$ .

המסקנה היא שצריך לדעת מתי להשתמש בהפרד ומשול כי לא בהכרח שזה יהיה שווה את זה.


__אנדקוטה , פעולת העלאה בחזקת n של מספר בשיטת הפרד ומשול היא לוגריתמית ביחס ל n__ (לא נוכיח את זה בסיכום הזה).

#### תרגילים הפרד ומשול 
![[Pasted image 20220622105923.png]]

על מנת נפתור את הבעיה באותה סיבוכיות בצורה לא ריקורסיבית פשוט נבין מה עשינו בשיטה הריקורסיבית ב [[#מינימום ומקסימום ]]. בעצם עשינו שיטת טורניר, כל פעם קפצנו בקפיצות זוגיות והשוונו בין הערכים. כלומר עלינו לשמר את היכול להשוות איברים בזוגות ולקפוץ בקפיצות זוגיות .

סך הכל הפתרון יהיה מהצורה 
``` ad-Code 
```cpp

struct Pair
{
	int min;
	int max;
};

struct Pair getMinMax(int arr[], int n)
{
	struct Pair minmax;	
	int i;
	
	// If array has even number of elements
	// then initialize the first two elements
	// as minimum and maximum
	if (n % 2 == 0)
	{
		if (arr[0] > arr[1])	
		{
			minmax.max = arr[0];
			minmax.min = arr[1];
		}
		else
		{
			minmax.min = arr[0];
			minmax.max = arr[1];
		}
		
		// Set the starting index for loop
		i = 2;
	}
	
	// If array has odd number of elements
	// then initialize the first element as
	// minimum and maximum
	else
	{
		minmax.min = arr[0];
		minmax.max = arr[0];
		
		// Set the starting index for loop
		i = 1;
	}
	
	// In the while loop, pick elements in
	// pair and compare the pair with max
	// and min so far
	while (i < n - 1)
	{		
		if (arr[i] > arr[i + 1])		
		{
			if(arr[i] > minmax.max)	
				minmax.max = arr[i];
				
			if(arr[i + 1] < minmax.min)		
				minmax.min = arr[i + 1];	
		}
		else	
		{
			if (arr[i + 1] > minmax.max)	
				minmax.max = arr[i + 1];
				
			if (arr[i] < minmax.min)		
				minmax.min = arr[i];	
		}
		
		// Increment the index by 2 as
		// two elements are processed in loop
		i += 2;
	}		
	return minmax;
}

```

הקוד קצת ארוך אבל סך הכל, רצנו על האיברים בזוגות במקום לרוץ על כל איברים המערך, באופן זה חסכנו את מספר האיטרציות.

![[Pasted image 20220622124229.png]]

הבעיה היא שהביטוי הפנימי נותן את $X+X_{2}$ ולכן זה בעצם יוצא שאנחנו עושים את הקריאה הריקורסיבית פעמיים כדי לחלק את המספר לשתי חצאים , כלומר אנחנו שוב נעשה 4 פעמים פעולות ריקורסיביות וזה לא מייעל את הזמן ריצה אנחנו נקבל $\Theta(n^{2})$ שוב.

![[Pasted image 20220622152007.png]]

נסתכל על הבעיה בצורה הנאיבית שלה, נרוץ על שתי לולאות הלולאה החיצונית תחזיק אינדקס והלולאה הפנימית תחשב את המינימום עבור אינדקס זה, ככה נעשה עבור כל האינדקסים האפשריים (נשים לב שאין טעם לחזור אחורה כיוון שסכום הוא חילופי ולכן כבר חישבנו. את המקסימום כשזזים אחורה).

כעת שיש לנו אינטואצייה על האלגוריתם הנאיבי נבין מה יש לנו כאן, 

* הסכום הכי קטן יכול להיות בחציו השמאלי של המערך , בחציו הימני או בשילוב של שניהם
* מתוך ההבנה הזאת נחלק את המערך ל2 בצורה ריקורסיבית 
* ניקח מקסימום בכל אחד מהחצאים
* בהינתן נקודה שמאלית , נקודה ימנית  ואמצע. נחשב את המקסימום כולל האמצע על ידי חישוב המקסימום בין הסכום מאמצע לנקודה שמאלית , בין אמצע לנקודה ימנית ובין החיבור שלהם.

```ad-Code
```cpp

int minCrossingSum(int arr[], int l, int m, int h)
{
	// Include elements on left of mid.
	int sum = 0;
	int left_sum = INT_MAX;
	for (int i = m; i >= l; i--) {
		sum = sum + arr[i];
		if (sum < left_sum)
			left_sum = sum;
	}

	// Include elements on right of mid
	sum = 0;
	int right_sum = INT_MAX;
	for (int i = m + 1; i <= h; i++) {
		sum = sum + arr[i];
		if (sum < right_sum)
			right_sum = sum;
	}

	// Return sum of elements on left and right of mid
	return min(left_sum + right_sum, left_sum, right_sum);
}

// Returns sum of maximum sum subarray in aa[l..h]
int minSubArraySum(int arr[], int l, int h)
{
	// Base Case: Only one element
	if (l == h)
		return arr[l];

	// Find middle point
	int m = (l + h) / 2;

	return min(minSubArraySum(arr, l, m),
			minSubArraySum(arr, m + 1, h),
			minCrossingSum(arr, l, m, h));
}

```

זמן הריצה של זה יהיה 
$$T(n)=2T(\frac{n}{2})+\Theta(n)$$
לפי שיטת המאסטר נקבל שזמן הריצה הוא $\Theta(n\log(n))$ __כנדרש__. 


![[Pasted image 20220622190534.png]]

אם נפתח את $T(n)$ נקבל מעין עץ שהחלוקה של מספר הילדים לכל קודקוד תלוייה ב $s$ 

![[Pasted image 20220622194355.png]]

וכעת אנחנו יודעים בוודאות שמספר הפעולות הריקורסיביות הוא לכל היותר גובה העץ $\log_{s}(n)$ .
באופן כללי העבודה שתבוצע ברמה ה$i$ תהיה : 
$$O(n^{d})\cdot{\frac{m^{i}}{s^{di}}}$$
והעבודה התבוצע סך הכל תהיה 

$$\sum\limits_{i=0}^{\log_{b}(n)}O(n^{d})\cdot{\frac{m^{i}}{s^{di}}}=O(n^{d})\sum\limits_{i=0}^{\log_{b}(n)}(\frac{m}{s^{d}})^{i}$$

נשים לב שקיבלנו בעצם סדרה הנדסית כאשר $q=\frac{m}{s^{d}}$ ו $O(n^{d})$ הוא קבוע 
כעת נחלק למקרים :  
* $\frac{m}{s^{d}}<1$ 
אז הטור מתכנס לקבוע ולכן $T(n)$ שייך ל $O(n^{d})$ 
* $\frac{m}{s^{d}}=1$ 
אז נקבל $O(n^{d})\log_{s}(n)\in{O(n^{d}logn)}$ כי מעבר בין בסיסים תלוי בקבוע ולכן זה לא משנה.
* $\frac{m}{s^{d}}>1$ 
נקבל שהאיבר החשוב בסכום הוא האיבר האחרון  כי הוא הגדול ביותר התלוי ב$n$ נקבל : 
$$O(n^{d})\cdot (\frac{m}{s^{d}})^{log_{s}(n)}=O(n^{d}\cdot \frac{m^{log_{s}(n)}}{s^{d\cdot log_{s}(n)}})=O(n^{d}\frac{n^{log_{s}(m)}}{n^{d\cdot{log_{s}(s)}}})=O(n^{d}\frac{n^{log_{s}(m)}}{n^{d}})$$
וסה״כ נקבל $O(n^{log_{s}(m)})$ __כנדרש__ .


![[Pasted image 20220622230551.png]]

__1__ . במערך ממויין איבר החציון יהיה האיבר האמצעי במערך. לכן נרצה להוכיח שהאלגוריתם אכן מביא את איבר זה בהינתן מערך לא ממויין . 

האלגוריתם הפרד ומשול פה , מפצל את המערך לשתי חלקים ומפעיל את האלגוריתם על איבר החציון על כל אחד מתתי המערכים , ככה האלגוריתם הרקורסיבי ימשיך עד שיגיע לשתי תתי מערכים בגודל 5 ויחשב ישירות את החציון בזמן קבוע עבור $A_{1,2}$ . לכן באופן ריקורסיבי האלגוריתם אמור לעבוד עד לנקודה זו. 
החלק המעניין של ההוכחה הוא בהגדרת הקבוצה $C$  נבנה מערך שמכיל את כל האיבר הגדולים מ $m_1$ כולל  ואת כל האיברים הקטנים ממש מ $A_{2}$ (בלי הגבלת הכלליות $m_{1}<m_{2}$) נשים לב שיכול להיות ש $m_{2}$ נמצא במערך הזה בכל מקרה כי הוא גדול מ $m_{1}$ ויש סיכוי שהוא היה גם ב $A_{1}$. בכל מקרה משהו חשוב נוסף הוא שמספר האיברים הגדולים מ $m_{1}$ יהיו שווים למספר האיברים הקטנים מ $m_{2}$ במערך הזה כיוון ששניהם החציונים. 

במילים אחרות $m_{1}$ ו$m_2$ הם רבעונים של המערך $A$ ואנחנו לוקחים את כל מה שבינהם . (לפי יחס הסדר המוגדר על האיברים ולא לפי אינדקסים במערך) לכן החציון של המערך המקורי בהכרח יהיה בפנים __כדרוש__ . 


__2__ . גודל $C$  בכל איטרציה ריקורסיבית יהיה תלוי ב $n$ גודלו יהיה $n/2$ מהסיבה של הוא מורכב מהחצי הגדול של האיברים בתת המערך השמאלי שזה $n/4$ וכנ״ל לגבי החצי הקטן של האיברים של תת המערך הימני שזה $n/4$. 

__3__. זמן הריצה פה יהיה על כל תת מערך במקרה הגרוע מבצעים שוב פעם את מציאת החציון על מערך חדש לכן נוסחת הנסיגה תהיה מהצורה 
$$T(n)=3T(\frac{n}{2})+O(1)\in \Theta(nlogn)$$
לפי שיטת המאסטר. הסיבה שהאלגוריתם מיותר זה כי יכלנו פשוט למיין עם $merge sort$ ולהשיג את אותה התוצאה וגם את המערך ממויין .


# מבני נתונים ליניאריים 
## שמירת מידע וניהולו 
לפעמים כמתכנתים נרצה יכולות מתקדמות לשמירה וניהול המידע איתו נרצה לבצע כל מיני פעולות , כאן נכנסים לתמונה מבני הנתונים שהם הנושא של הקורס הזה. כשמדברים ניהול מידע באוסף אנחנו מדברים על ניהול של יישות הנקראת record שהיא יכולה להכיל מספר רב של שדות (למשל סטודנט : שם, שם משפחה , מזהה , כתובת , תחום לימוד , ציונים וכו....). נרצה יכולת לנהל את הrecords בצורה שמתאימה לתוכנית שלנו בצורה היעילה ביותר. אין באמת תשובה נכונה לאיזה מבנה נתונים צריך להשתמש כי כל תוכנית וצרכיה שלה. לכל מבנה יהיו היתרונות והחסרונות שלו וצריך לבחור אותו בהתאם לשאילתות שנרצה לבצע על המידע.

## רשימה 
אחד הפתרונות המוכרים ביותר היא לעבור עם  [sequential allocation](http://www.xpode.com/ShowArticle.aspx?Articleid=282)
שמאפשר לשמור את המידע בזכרון בסדר מסויים של הכתובות ובקפיצה לפי גודל הrecord שאותו אנחנו שומרים (למשל רשימה בגודל 10 של מספרים שהאיבר הראשון שמור בכתובת 0, גודל כל מספר הוא 4 בייטים ולכן האיבר האחרון יהיה בכתובת 40).
היכולת הזאת טובה מאוד להכנסות והוצאות של איברים אך גרועה לחיפוש . __הפתרון__ שמירה של האוסף בצורה ממויינת ומיון על ידי [[binary search]].

## רשימה מקושרת 
אחת הבעיות של רשימה היא החסרון שלה בעדכון איברים , כיוון שהרבה פעמים נרצה להכניס איברים תוך כדי שמירה על יחס הסדר המוגדר בין ה records יכולה להיווצר בעיה בשימוש בהקצאה רציפה כיוון שהדבר ידרוש מאיתנו לשנות ולהזיז את האיברים בישביל לפנות מקום לאיבר שנרצה להכניסץ נוכל לפתור את הבעיה הזאת על ידי שימוש ב [linked allocation](http://www.xpode.com/ShowArticle.aspx?Articleid=282) , שזה בעצם אומר שנוכל להקצות מקומות שהם לא בהכרח בסדר רציף, באופן זה נוכל ליצור רשימה מקושרת שמחוברת על ידי מצביעים לכתובות האלו וכשנרצה להכניס כתובת חדשה זה יהיה מאוד פשוט. הבעיה כעת היא שחיפוש הוא לא כזה פשוט יותר כמו ברשימה רגילה שבה כאשר האוסף ממויין נוכל לבצע חיפוש בינארי יעיל לפי אינדקסי החציון.  עכשיו , גם אם האוסף ממויין לגשת לאיבר באינדקס כלשהו לוקח $O(n)$ פעולות. נלמד מבני נתונים שעוזרים לנו להתמודד עם הבעיות האלו בהמשך .

![[Pasted image 20220623113056.png]]
## תור
אחד הדרכים היותר טבעיות לארגן את המידע בסדר מסויים הנקרא תור (queue). התור מאפשר לשמור את הנתונים לפי סדר הכנסתם על מנת להוציאם אותו הסדר (FIFO-first in first out). לתור יש את היכולת להכניס איברים לתחילתו ולהוציא מסופו באופן מיידי שלא כולל סריקה, עושים זאת על ידי החזקת שני מצביעים לקידמת התור ולסופו. ניתן לשמור את האיברים ברשימה מקושרת או בהקצאה רציפה כאשר השימוש בהקצאה רציפה דורש מאיתנו לדעת בערך את מספר האיברים איתם נרצה להתעסק אחרת קיים הסיכון ל overflow. 

פעולות ההכנסה וההוצאה נקראות enqueue ו dequeue .
![[Pasted image 20220623123201.png]]

#### __מימושים לתור :__ 

* _מערך_

```ad-Code
```cpp

struct Queue {
	int front, rear, capacity;
	int* queue;
	
	Queue(int c)
	{
		front = rear = 0;
		capacity = c;
		queue = new int;
	}

	~Queue() { delete[] queue; }

	// function to insert an element
	// at the rear of the queue
	void queueEnqueue(int data)
	{
		// check queue is full or not
		if (capacity == rear) {
			return;
		}

		// insert element at the rear
		else {
			queue[rear] = data;
			rear++;
		}
		return;
	}

	// function to delete an element
	// from the front of the queue
	void queueDequeue()
	{
		// if queue is empty
		if (front == rear) {
			printf("\nQueue is empty\n");
			return;
		}

		// shift all the elements from index 2 till rear
		// to the left by one
		else {
			for (int i = 0; i < rear - 1; i++) {
				queue[i] = queue[i + 1];
			}

			// decrement rear
			rear--;
		}
		return;
	}


```

נבין מה קורה פה - כמו שאמרנו כשעובדים עם מערך צריך שיהיה capacity כל שהוא (מומלץ לפחות) מתודת ההכנסה היא די פשוטה ולוקחת $O(1)$ בהינתן שלא חרגנו מה מכנסה. מתודת ההוצאה דורשת ההעתקה של כל האיברים אחורה וההקטנה איבר ה rear ב1 ולכן זה חסום ב$O(n)$ .

* _רשימה מקושרת_
```ad-Code
```cpp
struct QNode {
	int data;
	QNode* next;
	QNode(int d)
	{
		data = d;
		next = NULL;
	}
};

struct Queue {
	QNode *front, *rear;
	Queue()
	{
		front = rear = NULL;
	}

	void enQueue(int x)
	{

		// Create a new LL node
		QNode* temp = new QNode(x);

		// If queue is empty, then
		// new node is front and rear both
		if (rear == NULL) {
			front = rear = temp;
			return;
		}

		// Add the new node at
		// the end of queue and change rear
		rear->next = temp;
		rear = temp;
	}

	// Function to remove
	// a key from given queue q
	void deQueue()
	{
		// If queue is empty, return NULL.
		if (front == NULL)
			return;

		// Store previous front and
		// move front one node ahead
		QNode* temp = front;
		front = front->next;

		// If front becomes NULL, then
		// change rear also as NULL
		if (front == NULL)
			rear = NULL;

		delete (temp);
	}
};
```
שיטה זאת היא העדיפה כמובן כיוון שבמקרה זה אנחנו לא צריכים להעתיק שום דבר בהסרה והוצאה מהתור ולכן כל הפעולות הן ב $O(1)$ .


#### דוגמאות לשימוש בתור -  optimal prefix code 
 [prefix code](https://www.cs.princeton.edu/courses/archive/spr01/cs126/assignments/prefix.html) זה איזשהו פרמטר שניתן לתת לאובייקט בישביל לזהות אותו בצורה יותר מהירה. 
 נניח שיש קבוצה של מספרים בעלת עוצמה $n$ , נסמנן $a_{i}:i\in[n]$ . נרצה באופן מתמשך להוריד את שני האיברים הקטנים ביותר מהסדרה ולהוסיף את סכומם כאיבר חדש בקבוצה , כך עד שיישאר איבר אחד, זהו חלק מפתרון של מציאת ה optimal prefix code (לא נגע בפתרון כולו) לפרמטר כלשהו. ברור לנו שאם הקבוצה לא ממויינת נצטרך $n^{2}$ השוואות. 
 נוכל למיין ב $nlogn$ ואז לשמור ברישמה מקושרת מה שיאפשר הוצאה , סכימה והכנסה מחדש בזמן קבוע , ונבצע זאת $n-1$ פעמים ולכן עדיין נהיה חסומים ב $nlogn$ פעולות. 

נוכל לבצע את המטלה הזאת בזמן זהה אם נשתמש בשני תורים $Q_{1}$ $Q_{2}$ . בראשון נשמור את איברי הקבוצה המקוריים בסדר לא יורד (עולה שווה). את השני נחזיק ריק והוא יכיל רק את האיברים שנוצרים על ידי האלגוריתם כלומר סכום של שני איברים מינימליים מהקבוצה . כעת נחפש את המינימום בשני התורים אך שהפעם לא צריך להסתבך לאן מכניסים את הסכום החדש. פשוט ייכנס למאחורי $Q_{2}$ .  אם המערך ממויין זמן העבודה הוא ליניארי 

![[Pasted image 20220623155501.png]]

## מחסנית 
המקבילה של FIFO של המסנית היא LIFO (last in first out). בגלל זה למבנה נתונים קוראים מחסנית, הקליע האחרון שנכניס למחסנית הוא הראשון שיצא בלחיצה על ההדק. 

כמו [[#תור]] גם מחסנית ניתן לממש על ידי הקצאות רציפות והקצאות מקושרות. בניגוד לתור אנחנו לא מתעסקים עם תחתית המחסנית אלא רק עם מי שנמצא למעלה שהוא ה $top$ .  באופן סכמתי זה יראה כך :
![[Pasted image 20220623161246.png]]

כיוון שהמימושים נורא זהים על מערך ורשימה מקושרת ארשום פה רק את הפסודו קוד של כל אחד מהם 
![[Pasted image 20220623162759.png]]

בשני המקרים הוצאה והכנסה היא ב $O(1)$ אבל נורא קשה לבצע פעולות סריקה וכו...

#### דוגמאות לשימוש במחסנית -  ביטויים אריתמטיים 
נסתכל על ביטוי מתמטי שאנחנו נתקלנו בו ביסודי 
$$4+3 \times5$$
בעוד שהמחשבוני כיס הפשוטים יתרגמו את זה כ35, אנחנו עוד משהיינו ילדים הבנו שיש פה עדיפות לפעולת הכפל לפני פעולת החיבור והתשובה האמיתית היא 19 . ומה אם היה את הביטוי הבא 
$$(4+3)\times 5$$
סגנון הכתיבה הזה כנראה מגיע מסיבות היסטוריות שכן , כיום כשאנחנו מפעילים פונקצייה על משתנה מסויים אנחנו רושמים $f(x)$ ואם זה שני משתנים אז $f(x,y)$ ולא $xfy$ . באופן דומה היינו צריכים לרשום את הביטוי שלנו באופן הבא $add(4,multiply(3,5))$ על מנת שזה יהיה דומה לאופן שבוא רושמים פונקציות.

סגנון הכתיבה הזה נקרא [Polish notation](https://en.wikipedia.org/wiki/Polish_notation) . 
בסגנון הכתיבה הזה נרשום את הביטוי באופן הבא 
$$+4\times 3\ \ 5\ \ \ \ \ \text{ or}\ \ \ \ \times+\ 4\ \ 3\ \  5$$
באופן דומה. יש סגנון כתיבה הנקרא [Reverse Polish notation](https://en.wikipedia.org/wiki/Reverse_Polish_notation).
בשיטה זאת נרשום קודם את המספרים ולאחר מכן את הביטוי המתמטי שנרצה לבצע. זה יראה כך 
$$4\ \  3\ +\ 5\ \times \ \ \ \ \text{ or}\ \ \ \ \ 4\ \ 3\ \  5\ \times+$$

