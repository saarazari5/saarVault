__סער אזערי__

במהלך הסיכום יעלו הרבה טענות הנשענות על [[#נושאי עזר]] הנמצאים בסוף הסיכום, מומלץ לעבור עליהם בסוף או אם לא הבנתם משהו במהלך הקריאה.

# הפרד ומשול
בהגדרה - הפרד ומשול זוהי פרדיגמה לתכנון אלגוריתם המשתמשת בריקורסיה על מנת להפוך בעייה קלה לבעיות קלות יותר , זאת באה עם היתרונות והחסרונות שלה , למשל אנחנו עלולים לחשב מספר ערכים , מספר רב של פעמים כפי שנראה בפרק של [[#תכנון דינאמי]]. 
הרעיון מאחורי הפרדיגמה של הפרד ומשול היא פשוטה ואומרת : 
* תפריד את הבעיה לבעיות קטנות יותר (__הפרד__). 
* תפתור את הבעיות הקטנות יותר(__משול__).
* מזג את התוצאות.

![[Pasted image 20220621181444.png|400]]

היכולת הזאת לפשט את הבעיה מאפשרת לנו לפתור בעיות ביעילות ריצה שלא היינו מגיעים אליה בתכנות לא רקורסיבי. 

כעת נראה מספר בעיות הניתנות לפתרון בעזרת ריקורסייה.

### מינימום ומקסימום 
##### מינימום
נניח שיש לנו מערך $A[n]$ (האלמנטים יכולים להיות מכל סוג כל עוד יכולת ההשוואה מוגדרת על אותו הסוג). ננסה למצוא את איבר המינימום  של המערך הזה 

$$\text{min index m} :\forall{i\in[n]}:\ \  A[m]\leq{A[i]}$$

 הפתרון הטריוויאלי העולה בראש של כל מתכנת, היא להחזיר משתנה מקומי $min$ ולשמור אליו את הערך המינימלי תוך כדי ריצה על המערך. או בתיאור פסודו:
  
 ![[Pasted image 20220621182038.png]]


עם זאת אנחנו נאלץ לבצע $n-1$ השוואות ונרוץ על כל המערך, לא נשמע כזה נורא אך ניתן לפתור את זה אחרת . 

נוכל אולי לבטא את $n$ כביטוי בחזקת $2$ למשל $2^{m}$ ונוכל לחלק את המערך שלנו לזוגות (אולי יישאר איבר בודד אבל זה לא משנה),  נשווה כל זוג והמנצח ממשיך לשלב הבא ככה עד שנשאר איבר אחר (מעין טורניר בודוקאי). 

בפסודו: 
![[Pasted image 20220621182524.png]]
__נשים לב שאנחנו רוצים לזוז כל פעם בקפיצות ביחס לקומה בה אנחנו נמצאים ככל ש i מתקדם ככה יש פחות ופחות איברים במערך , על מנת שלא נקצה עוד זכרון נרוץ בקפיצות המתוארות למעלה__.

באופן ויזואלי : 
![[Pasted image 20220621182639.png]]


האם שיפרנו משהו? עבדנו קצת קשה אבל סך הכל נראה ש נקבל 

$$\frac{n}{2}+\frac{n}{4}+\dots+2+1=n-1$$


נשאלת השאלה, האם הדבר במקרה? 

לכל שיטה בה נבחר אנחנו תמיד נצטרך לעבור על $n$ האיברים במערך כדי לדעת האם האיבר עליו אנחנו עומדים הוא המינימום או לא. כלומר אנחנו תמיד נמצא את עצמנו בונים מעין עץ בינארי שלם  לכל השוואה שנבחר וכפי שנדבר בהמשך , 

__לכל עץ בינארי עם $n$ עלים, יש בידיוק $n-1$ קודקודים פנימיים__. 
לכן על מנת למצוא את המינימום נצטרך לעשות $n-1$ השוואות, לא ניתן לייעול.

##### מקסימום 
נשמע שזאת אותה הבעיה לא? פשוט להחליף את הסימן (להחליף $\leq$ ב $\geq$ ).
המעבר בין בעיה א׳ לבעיה ב׳ הוא אלגוריתם בפני עצמו הנקרא [reduction](https://en.wikipedia.org/wiki/Reduction_(complexity)) , זהו כלי בסיסי אך אפשר לדבר עליו רבות.

במקרה הזה המעבר די פשוט והוא עוזר לנו גם לדעת שנדרשת $n-1$ פעולות על מנת למצוא את המקסימום.


##### מינימום ומקסימום ביחד 
נוכל פשוט לחבר את שתי התוכנות לפעולה אחת ולקבל את התוצאה ב $2n-2$ שהיא חסומה ב $O(n-1)$ כמו השיטות הקודמות .

![[Pasted image 20220621185317.png]]

אבל בואו ננסה לייעל את השיטה הזאת , 
  דרך אחת תהיהי להוסיף $else$ בין שני ההשוואות כי כמובן שאם אחת מתקיימת השנייה לא. במערך עולה ממויין עם זאת, עדיין נקבל $2n-2$ פעולות. לא רע במיוחד אבל נוכל לייעל .

כעת, סוף סוף נוכל לדבר ולהראות איך נשתמש ב __הפרד ומשול__ כדי לפתור בעיות,

הפעולה תחזיר $(M,m)$ אחד מייצג את המקסימום ואחד את המינימום (לתוהים ששואלים איך אפשר להחזיר דבר כזה בתכנות, פשוט בונים struct , class או tuple). 

__הפרד__ - נחלק את המערך לחצי כל פעם - תנאי העצירה יהיה כאשר גודל תת המערך הוא 2 ואז נוכל להחזיר השוואה רגילה .

__משול__ - על כל תת מערך שמאלי וימני נפעיל רקורסיבית את הפעולה שוב פעם.

__מזג__ - נחזיר את המקסימום בין $M_{1,2}$ כאשר $1$ זה תת המערך השמאלי ו $2$ זה תת המערך הימני.  באופן דומה נחזיר את המינימום בין $m_{1},m_{2}$ .

```ad-Code
``` psudo
Algorithm: Max - Min(x, y)
if y – x ≤ 1 then
return (max(numbers[x], numbers[y]), min((numbers[x], numbers[y]))
else
(max1, min1):= maxmin(x, ⌊((x + y)/2)⌋)
(max2, min2):= maxmin(⌊((x + y)/2) + 1)⌋,y)
return (max(max1, max2), min(min1, min2))
```

 נחשב את זמן הריצה : 
 עבור $n$ שקטן או שווה ל$2$ אז זמן הריצה זהו זמן ריצה קבוע , לכן מה שמעניין זה כאשר $n>2$ .

$$T(n)=2\cdot T(\frac{n}{2})+2=\dots=1.5n-2\in O(n)$$

צמצמנו את זמן הריצה אבל זה לא ממש נחשב שיפור, וזה בלי לקחת בחשבון את העובדה שהריקורסייה תופסת יותר זכרון ואולי בכלל עדיף את הקוד הליניארי והשימוש בלולאה כמו מקודם... אבל עדיין זאת דרך לעבוד עם הפרד ומשול. 


### מיון מיזוג 
הצורך להחזיק אוסף מסוייף בסדר כלשהו הוא צורך תמידי הניכר בכל תחומי חיינו, גם בתכנות הרבה מאוד פעמים נרצה את המידע שלנו בסדר כלשהו. השיטה הטירוויאלית שכולם מכירים bubble sort היא המוכרת מכולם והפשוטה מכולם אך היא לוקחת $\Omega(n^{2})$ השוואות. 

באלגוריתם מיון המיזוג נשתמש בהפרד ומשול כדי לייעל את זמן המיזוג שלנו:

__הפרד__ - כל פעם נחלק את המערך לשני חצאים. 

__משול__ - ברגע שנגיע למערך בגודל 2 נחליף את סדר האיברים בהתאם לגודלם 

__מיזוג__ - לאחר שסידרנו כל תת מערך נחבר את החלקים למערך אחד גדול וממויין.

קוד המיזוג יהיה מאוד נאיבי כמובן שצריך לדעת באיזה אופן למזג וזה לא מספיק סתם לחבר בין שני המערכים, ישנם מספר דרכים למזג בין מערכים לא אפרט את כל התהליך כי זה לא רלוונטי , חשוב לדעת שכולן בסך הכל לוקחות $O(n)$ מבחינת זמן ריצה
 מצרף פה כמה אימפלמנטציות אפשריות : 

##### TOP - DOWN 
```ad-Code
``` cpp 

// Split A[] into 2 runs, sort both runs into B[], merge both runs from B[] to A[]
// iBegin is inclusive; iEnd is exclusive (A[iEnd] is not in the set).
void TopDownSplitMerge(B[], iBegin, iEnd, A[])
{
    if (iEnd - iBegin <= 1)                    // if run size == 1
        return;                              // consider it sorted
    // split the run longer than 1 item into halves
    iMiddle = (iEnd + iBegin) / 2;          // iMiddle = mid point
    // recursively sort both runs from array A[] into B[]
    TopDownSplitMerge(A, iBegin,  iMiddle, B);  // sort the left  run
    TopDownSplitMerge(A, iMiddle,    iEnd, B);  // sort the right run
    // merge the resulting runs from array B[] into A[]
    TopDownMerge(B, iBegin, iMiddle, iEnd, A);
}

//  Left source half is A[ iBegin:iMiddle-1].
// Right source half is A[iMiddle:iEnd-1   ].
// Result is            B[ iBegin:iEnd-1   ].
void TopDownMerge(A[], iBegin, iMiddle, iEnd, B[])
{
    i = iBegin, j = iMiddle;
 
    // While there are elements in the left or right runs...
    for (k = iBegin; k < iEnd; k++) {
    // If left run head exists and is <= existing right run head.
        if (i < iMiddle && (j >= iEnd || A[i] <= A[j])) {
            B[k] = A[i];
            i = i + 1;
        } else {
            B[k] = A[j];
            j = j + 1;
        }
    }
}
```

##### BOTTOM - UP 

``` ad-Code
```cpp
//  Left run is A[iLeft :iRight-1].
// Right run is A[iRight:iEnd-1  ].
void BottomUpMerge(A[], iLeft, iRight, iEnd, B[])
{
    i = iLeft, j = iRight;
    // While there are elements in the left or right runs...
    for (k = iLeft; k < iEnd; k++) {
   // If left run head exists and is <= existing right run head.
        if (i < iRight && (j >= iEnd || A[i] <= A[j])) {
            B[k] = A[i];
            i = i + 1;
        } else {
            B[k] = A[j];
            j = j + 1;    
        }
    } 
}
```

סך הכל הפסודו קוד יהיה מהצורה של אלגוריתם המיון יהיה מהצורה 

![[Pasted image 20220621202353.png]]

ננתח את הסיבכויות זמן ריצה לפי שיטת המאסטר 
$$T(n)=2T(\frac{n}{2})+n$$
לפי שיטת המאסטר נקבל שמספר הפעולות הריקורסיבי שווה למספר הפעולות הלא ריקורסיביות ולכן 
$$T(n)\in\Theta(n\cdot\log_{2}(n))$$
(הבסיס הדיפולטי בסיכום זה יהיה 2 תמיד, רשמתי את זה פה רק כדי שיהיה ברור).


__אנקדוטה__ - כל אלגוריתם מיון על מידע שכל מה שידוע עליו הוא יחס הסדר תמיד יהיה חסום ב $O(nlogn)$. 

### כפל של מספרים גדולים
על פניו נשמע כמו כותרת מוזרה כי תכנותית אנחנו רושמים פשוט
$\text{return }x\cdot{y}$ 

אז מה זה אומר בכלל ? נסתכל על הבעיה באופן תיאורטי ונניח שגודל המספר יכול להיות אין סופי , למרות שבמעבדי 64 ביטים הייצוג המקסימלי של מספר מספיק לרוב הבעיות שאנחנו מתמודדים איתם, נרצה להבין תיאורטית איך ניתן לייעל כפל כזה בהינתן שאנחנו מקבלים קלטים בגדלים לא ידועים השואפים למספר אינסופי.

יהי $X ,Y$ שני מספרים ששניהם באורך $n$ ביטים (כלומר בייצוג הבינארי שלהם). נניח את אורך הביטים בלי הגבלת הכלליות כיוון שאם נרצה להקטין מספר פשוט נשים כמה 0 שצריך מה msb .

אז איך בכלל מתחילים לחשב זמן ריצה של דבר כזה? שלא לדבר על איך משתמשים בהפרד ומשול כדי לחשב את זה ... לפי החוקים של כפל אנחנו בעצם נבצע $n^{2}$ פעולות כפל וחיבור באלגוריתם הנאיבי ולכן חסום ב $\Theta(n^2)$ . 

![[Pasted image 20220622101259.png]]

זה בשיטה הנאיבית. ננסה לראות כמה יצא לנו על ידי שימוש בהפרד ומשול 
נגדיר $X=x_{1}x_{2}x_{3}\dots x_{n}$  וגם $Y=y_{1}y_{2}y_{3}\dots{y_{n}}$.  כאשר כל ספרה שייכת לקבוצה הבינארית וכל ספרה היא ביט.

נחלק באמצע את מספר הספרות באופן הבא 

![[Pasted image 20220622102015.png]]

כעת כמו שניתן לפרק מספר לספרות בבסיס 10 נעשה זאת על המספרים שלנו באופן הבא 
$$\displaylines{
X=X_{1}2^{\frac{n}{2}}+X_{2}\\
Y=Y_{1}2^{\frac{n}{2}}+Y_{2}
}$$

הכפל בינהם יהיה 

$$XY=X_{1}Y_{1}2^{n}+(X_{1}Y_{2}+X_{2}Y_{1})2^{n/2}+X_{2}Y_{2}$$
וכאן בעצם יש לנו איזשהי זהות ריקורסיבית וזהות זאת תהיה המשול שלנו, על כל תתי מספרים בינאריים ניקח את החצאים וננחשב רקורסיבית את הביטוי המתמטי הזה.

בפסודו קוד זה ייראה ככה : 

![[Pasted image 20220622103239.png]]

ומבחינת סיבוכיות זמן ריצה נקבל 

$$T(n)=4T(\frac{n}{2})+cn$$
כאשר $cn$ מייצג את כל הפעולות הלא ריקורסיביות כמו העלאת חזקה וכל פעולות החיבור שנעשה.
לפי שיטת המאסטר נקבל שהסיבוכיות הזאת היא גם כן $\Theta(n^{2})$ וזה לא עזר. נוכל לייעל את הזמן ריצה הזה אך לא בהרבה על ידי כך שנשים לב שמתקיים 

$$E=(X_{1}+X_{2})(Y_{1}+Y_{2})=X_{1}Y_{1}+X_{1}Y_{2}+X_2Y_{1}+X_{2}Y_2$$
נסמן $A=X_{1}Y_{1}$  ו $B=X_{2}Y_{2}$ 

כלומר באמצע החישוב של $A,B$ נוכל לייצר תלות עם הביטוי האמצעי ולחסור פעולה ריקורסיבית אחת, נקבל זמן ריצה קצת יותר יעיל של $n^{1.5}$ .

המסקנה היא שצריך לדעת מתי להשתמש בהפרד ומשול כי לא בהכרח שזה יהיה שווה את זה.


__אנדקוטה , פעולת העלאה בחזקת n של מספר בשיטת הפרד ומשול היא לוגריתמית ביחס ל n__ (לא נוכיח את זה בסיכום הזה).

#### תרגילים הפרד ומשול 
![[Pasted image 20220622105923.png]]

על מנת נפתור את הבעיה באותה סיבוכיות בצורה לא ריקורסיבית פשוט נבין מה עשינו בשיטה הריקורסיבית ב [[#מינימום ומקסימום ]]. בעצם עשינו שיטת טורניר, כל פעם קפצנו בקפיצות זוגיות והשוונו בין הערכים. כלומר עלינו לשמר את היכול להשוות איברים בזוגות ולקפוץ בקפיצות זוגיות .

סך הכל הפתרון יהיה מהצורה 
``` ad-Code 
```cpp

struct Pair
{
	int min;
	int max;
};

struct Pair getMinMax(int arr[], int n)
{
	struct Pair minmax;	
	int i;
	
	// If array has even number of elements
	// then initialize the first two elements
	// as minimum and maximum
	if (n % 2 == 0)
	{
		if (arr[0] > arr[1])	
		{
			minmax.max = arr[0];
			minmax.min = arr[1];
		}
		else
		{
			minmax.min = arr[0];
			minmax.max = arr[1];
		}
		
		// Set the starting index for loop
		i = 2;
	}
	
	// If array has odd number of elements
	// then initialize the first element as
	// minimum and maximum
	else
	{
		minmax.min = arr[0];
		minmax.max = arr[0];
		
		// Set the starting index for loop
		i = 1;
	}
	
	// In the while loop, pick elements in
	// pair and compare the pair with max
	// and min so far
	while (i < n - 1)
	{		
		if (arr[i] > arr[i + 1])		
		{
			if(arr[i] > minmax.max)	
				minmax.max = arr[i];
				
			if(arr[i + 1] < minmax.min)		
				minmax.min = arr[i + 1];	
		}
		else	
		{
			if (arr[i + 1] > minmax.max)	
				minmax.max = arr[i + 1];
				
			if (arr[i] < minmax.min)		
				minmax.min = arr[i];	
		}
		
		// Increment the index by 2 as
		// two elements are processed in loop
		i += 2;
	}		
	return minmax;
}

```

הקוד קצת ארוך אבל סך הכל, רצנו על האיברים בזוגות במקום לרוץ על כל איברים המערך, באופן זה חסכנו את מספר האיטרציות.

![[Pasted image 20220622124229.png]]

הבעיה היא שהביטוי הפנימי נותן את $X+X_{2}$ ולכן זה בעצם יוצא שאנחנו עושים את הקריאה הריקורסיבית פעמיים כדי לחלק את המספר לשתי חצאים , כלומר אנחנו שוב נעשה 4 פעמים פעולות ריקורסיביות וזה לא מייעל את הזמן ריצה אנחנו נקבל $\Theta(n^{2})$ שוב.

![[Pasted image 20220622152007.png]]

נסתכל על הבעיה בצורה הנאיבית שלה, נרוץ על שתי לולאות הלולאה החיצונית תחזיק אינדקס והלולאה הפנימית תחשב את המינימום עבור אינדקס זה, ככה נעשה עבור כל האינדקסים האפשריים (נשים לב שאין טעם לחזור אחורה כיוון שסכום הוא חילופי ולכן כבר חישבנו. את המקסימום כשזזים אחורה).

כעת שיש לנו אינטואצייה על האלגוריתם הנאיבי נבין מה יש לנו כאן, 

* הסכום הכי קטן יכול להיות בחציו השמאלי של המערך , בחציו הימני או בשילוב של שניהם
* מתוך ההבנה הזאת נחלק את המערך ל2 בצורה ריקורסיבית 
* ניקח מקסימום בכל אחד מהחצאים
* בהינתן נקודה שמאלית , נקודה ימנית  ואמצע. נחשב את המקסימום כולל האמצע על ידי חישוב המקסימום בין הסכום מאמצע לנקודה שמאלית , בין אמצע לנקודה ימנית ובין החיבור שלהם.

```ad-Code
```cpp

int minCrossingSum(int arr[], int l, int m, int h)
{
	// Include elements on left of mid.
	int sum = 0;
	int left_sum = INT_MAX;
	for (int i = m; i >= l; i--) {
		sum = sum + arr[i];
		if (sum < left_sum)
			left_sum = sum;
	}

	// Include elements on right of mid
	sum = 0;
	int right_sum = INT_MAX;
	for (int i = m + 1; i <= h; i++) {
		sum = sum + arr[i];
		if (sum < right_sum)
			right_sum = sum;
	}

	// Return sum of elements on left and right of mid
	return min(left_sum + right_sum, left_sum, right_sum);
}

// Returns sum of maximum sum subarray in aa[l..h]
int minSubArraySum(int arr[], int l, int h)
{
	// Base Case: Only one element
	if (l == h)
		return arr[l];

	// Find middle point
	int m = (l + h) / 2;

	return min(minSubArraySum(arr, l, m),
			minSubArraySum(arr, m + 1, h),
			minCrossingSum(arr, l, m, h));
}

```

זמן הריצה של זה יהיה 
$$T(n)=2T(\frac{n}{2})+\Theta(n)$$
לפי שיטת המאסטר נקבל שזמן הריצה הוא $\Theta(n\log(n))$ __כנדרש__. 


![[Pasted image 20220622190534.png]]

אם נפתח את $T(n)$ נקבל מעין עץ שהחלוקה של מספר הילדים לכל קודקוד תלוייה ב $s$ 

![[Pasted image 20220622194355.png]]

וכעת אנחנו יודעים בוודאות שמספר הפעולות הריקורסיביות הוא לכל היותר גובה העץ $\log_{s}(n)$ .
באופן כללי העבודה שתבוצע ברמה ה$i$ תהיה : 
$$O(n^{d})\cdot{\frac{m^{i}}{s^{di}}}$$
והעבודה התבוצע סך הכל תהיה 

$$\sum\limits_{i=0}^{\log_{b}(n)}O(n^{d})\cdot{\frac{m^{i}}{s^{di}}}=O(n^{d})\sum\limits_{i=0}^{\log_{b}(n)}(\frac{m}{s^{d}})^{i}$$

נשים לב שקיבלנו בעצם סדרה הנדסית כאשר $q=\frac{m}{s^{d}}$ ו $O(n^{d})$ הוא קבוע 
כעת נחלק למקרים :  
* $\frac{m}{s^{d}}<1$ 
אז הטור מתכנס לקבוע ולכן $T(n)$ שייך ל $O(n^{d})$ 
* $\frac{m}{s^{d}}=1$ 
אז נקבל $O(n^{d})\log_{s}(n)\in{O(n^{d}logn)}$ כי מעבר בין בסיסים תלוי בקבוע ולכן זה לא משנה.
* $\frac{m}{s^{d}}>1$ 
נקבל שהאיבר החשוב בסכום הוא האיבר האחרון  כי הוא הגדול ביותר התלוי ב$n$ נקבל : 
$$\displaylines{O(n^{d})\cdot (\frac{m}{s^{d}})^{log_{s}(n)}=\\O(n^{d}\cdot \frac{m^{log_{s}(n)}}{s^{d\cdot log_{s}(n)}})=O(n^{d}\frac{n^{log_{s}(m)}}{n^{d\cdot{log_{s}(s)}}})=O(n^{d}\frac{n^{log_{s}(m)}}{n^{d}})}$$
וסה״כ נקבל $O(n^{log_{s}(m)})$ __כנדרש__ .


![[Pasted image 20220622230551.png]]

__1__ . במערך ממויין איבר החציון יהיה האיבר האמצעי במערך. לכן נרצה להוכיח שהאלגוריתם אכן מביא את איבר זה בהינתן מערך לא ממויין . 

האלגוריתם הפרד ומשול פה , מפצל את המערך לשתי חלקים ומפעיל את האלגוריתם על איבר החציון על כל אחד מתתי המערכים , ככה האלגוריתם הרקורסיבי ימשיך עד שיגיע לשתי תתי מערכים בגודל 5 ויחשב ישירות את החציון בזמן קבוע עבור $A_{1,2}$ . לכן באופן ריקורסיבי האלגוריתם אמור לעבוד עד לנקודה זו. 
החלק המעניין של ההוכחה הוא בהגדרת הקבוצה $C$  נבנה מערך שמכיל את כל האיבר הגדולים מ $m_1$ כולל  ואת כל האיברים הקטנים ממש מ $A_{2}$ (בלי הגבלת הכלליות $m_{1}<m_{2}$) נשים לב שיכול להיות ש $m_{2}$ נמצא במערך הזה בכל מקרה כי הוא גדול מ $m_{1}$ ויש סיכוי שהוא היה גם ב $A_{1}$. בכל מקרה משהו חשוב נוסף הוא שמספר האיברים הגדולים מ $m_{1}$ יהיו שווים למספר האיברים הקטנים מ $m_{2}$ במערך הזה כיוון ששניהם החציונים. 

במילים אחרות $m_{1}$ ו$m_2$ הם רבעונים של המערך $A$ ואנחנו לוקחים את כל מה שבינהם . (לפי יחס הסדר המוגדר על האיברים ולא לפי אינדקסים במערך) לכן החציון של המערך המקורי בהכרח יהיה בפנים __כדרוש__ . 


__2__ . גודל $C$  בכל איטרציה ריקורסיבית יהיה תלוי ב $n$ גודלו יהיה $n/2$ מהסיבה של הוא מורכב מהחצי הגדול של האיברים בתת המערך השמאלי שזה $n/4$ וכנ״ל לגבי החצי הקטן של האיברים של תת המערך הימני שזה $n/4$. 

__3__. זמן הריצה פה יהיה על כל תת מערך במקרה הגרוע מבצעים שוב פעם את מציאת החציון על מערך חדש לכן נוסחת הנסיגה תהיה מהצורה 
$$T(n)=3T(\frac{n}{2})+O(n)\in \Theta(nlogn)$$

כאשר מתייחסים לזמן הבנייה של $C$. לפי שיטת המאסטר. הסיבה שהאלגוריתם מיותר זה כי יכלנו פשוט למיין עם $merge sort$ ולהשיג את אותה התוצאה וגם את המערך ממויין .


# מבני נתונים ליניאריים 
## שמירת מידע וניהולו 
לפעמים כמתכנתים נרצה יכולות מתקדמות לשמירה וניהול המידע איתו נרצה לבצע כל מיני פעולות , כאן נכנסים לתמונה מבני הנתונים שהם הנושא של הקורס הזה. כשמדברים ניהול מידע באוסף אנחנו מדברים על ניהול של יישות הנקראת record שהיא יכולה להכיל מספר רב של שדות (למשל סטודנט : שם, שם משפחה , מזהה , כתובת , תחום לימוד , ציונים וכו....). נרצה יכולת לנהל את הrecords בצורה שמתאימה לתוכנית שלנו בצורה היעילה ביותר. אין באמת תשובה נכונה לאיזה מבנה נתונים צריך להשתמש כי כל תוכנית וצרכיה שלה. לכל מבנה יהיו היתרונות והחסרונות שלו וצריך לבחור אותו בהתאם לשאילתות שנרצה לבצע על המידע.

## רשימה 
אחד הפתרונות המוכרים ביותר היא לעבור עם  [sequential allocation](http://www.xpode.com/ShowArticle.aspx?Articleid=282)
שמאפשר לשמור את המידע בזכרון בסדר מסויים של הכתובות ובקפיצה לפי גודל הrecord שאותו אנחנו שומרים (למשל רשימה בגודל 10 של מספרים שהאיבר הראשון שמור בכתובת 0, גודל כל מספר הוא 4 בייטים ולכן האיבר האחרון יהיה בכתובת 40).
היכולת הזאת טובה מאוד להכנסות והוצאות של איברים אך גרועה לחיפוש . __הפתרון__ שמירה של האוסף בצורה ממויינת ומיון על ידי [[binary search]].

## רשימה מקושרת 
אחת הבעיות של רשימה היא החסרון שלה בעדכון איברים , כיוון שהרבה פעמים נרצה להכניס איברים תוך כדי שמירה על יחס הסדר המוגדר בין ה records יכולה להיווצר בעיה בשימוש בהקצאה רציפה כיוון שהדבר ידרוש מאיתנו לשנות ולהזיז את האיברים בישביל לפנות מקום לאיבר שנרצה להכניסץ נוכל לפתור את הבעיה הזאת על ידי שימוש ב [linked allocation](http://www.xpode.com/ShowArticle.aspx?Articleid=282) , שזה בעצם אומר שנוכל להקצות מקומות שהם לא בהכרח בסדר רציף, באופן זה נוכל ליצור רשימה מקושרת שמחוברת על ידי מצביעים לכתובות האלו וכשנרצה להכניס כתובת חדשה זה יהיה מאוד פשוט. הבעיה כעת היא שחיפוש הוא לא כזה פשוט יותר כמו ברשימה רגילה שבה כאשר האוסף ממויין נוכל לבצע חיפוש בינארי יעיל לפי אינדקסי החציון.  עכשיו , גם אם האוסף ממויין לגשת לאיבר באינדקס כלשהו לוקח $O(n)$ פעולות. נלמד מבני נתונים שעוזרים לנו להתמודד עם הבעיות האלו בהמשך .

![[Pasted image 20220623113056.png]]
## תור
אחד הדרכים היותר טבעיות לארגן את המידע בסדר מסויים הנקרא תור (queue). התור מאפשר לשמור את הנתונים לפי סדר הכנסתם על מנת להוציאם אותו הסדר (FIFO-first in first out). לתור יש את היכולת להכניס איברים לתחילתו ולהוציא מסופו באופן מיידי שלא כולל סריקה, עושים זאת על ידי החזקת שני מצביעים לקידמת התור ולסופו. ניתן לשמור את האיברים ברשימה מקושרת או בהקצאה רציפה כאשר השימוש בהקצאה רציפה דורש מאיתנו לדעת בערך את מספר האיברים איתם נרצה להתעסק אחרת קיים הסיכון ל overflow. 

פעולות ההכנסה וההוצאה נקראות enqueue ו dequeue .
![[Pasted image 20220623123201.png]]

#### __מימושים לתור :__ 

* _מערך_

```ad-Code
```cpp

struct Queue {
	int front, rear, capacity;
	int* queue;
	
	Queue(int c)
	{
		front = rear = 0;
		capacity = c;
		queue = new int;
	}

	~Queue() { delete[] queue; }

	// function to insert an element
	// at the rear of the queue
	void queueEnqueue(int data)
	{
		// check queue is full or not
		if (capacity == rear) {
			return;
		}

		// insert element at the rear
		else {
			queue[rear] = data;
			rear++;
		}
		return;
	}

	// function to delete an element
	// from the front of the queue
	void queueDequeue()
	{
		// if queue is empty
		if (front == rear) {
			printf("\nQueue is empty\n");
			return;
		}

		// shift all the elements from index 2 till rear
		// to the left by one
		else {
			for (int i = 0; i < rear - 1; i++) {
				queue[i] = queue[i + 1];
			}

			// decrement rear
			rear--;
		}
		return;
	}


```

נבין מה קורה פה - כמו שאמרנו כשעובדים עם מערך צריך שיהיה capacity כל שהוא (מומלץ לפחות) מתודת ההכנסה היא די פשוטה ולוקחת $O(1)$ בהינתן שלא חרגנו מה מכנסה. מתודת ההוצאה דורשת ההעתקה של כל האיברים אחורה וההקטנה איבר ה rear ב1 ולכן זה חסום ב$O(n)$ .

* _רשימה מקושרת_
```ad-Code
```cpp
struct QNode {
	int data;
	QNode* next;
	QNode(int d)
	{
		data = d;
		next = NULL;
	}
};

struct Queue {
	QNode *front, *rear;
	Queue()
	{
		front = rear = NULL;
	}

	void enQueue(int x)
	{

		// Create a new LL node
		QNode* temp = new QNode(x);

		// If queue is empty, then
		// new node is front and rear both
		if (rear == NULL) {
			front = rear = temp;
			return;
		}

		// Add the new node at
		// the end of queue and change rear
		rear->next = temp;
		rear = temp;
	}

	// Function to remove
	// a key from given queue q
	void deQueue()
	{
		// If queue is empty, return NULL.
		if (front == NULL)
			return;

		// Store previous front and
		// move front one node ahead
		QNode* temp = front;
		front = front->next;

		// If front becomes NULL, then
		// change rear also as NULL
		if (front == NULL)
			rear = NULL;

		delete (temp);
	}
};
```
שיטה זאת היא העדיפה כמובן כיוון שבמקרה זה אנחנו לא צריכים להעתיק שום דבר בהסרה והוצאה מהתור ולכן כל הפעולות הן ב $O(1)$ .


#### דוגמאות לשימוש בתור -  optimal prefix code 
 [prefix code](https://www.cs.princeton.edu/courses/archive/spr01/cs126/assignments/prefix.html) זה איזשהו פרמטר שניתן לתת לאובייקט בישביל לזהות אותו בצורה יותר מהירה. 
 נניח שיש קבוצה של מספרים בעלת עוצמה $n$ , נסמנן $a_{i}:i\in[n]$ . נרצה באופן מתמשך להוריד את שני האיברים הקטנים ביותר מהסדרה ולהוסיף את סכומם כאיבר חדש בקבוצה , כך עד שיישאר איבר אחד, זהו חלק מפתרון של מציאת ה optimal prefix code (לא נגע בפתרון כולו) לפרמטר כלשהו. ברור לנו שאם הקבוצה לא ממויינת נצטרך $n^{2}$ השוואות. 
 נוכל למיין ב $nlogn$ ואז לשמור ברישמה מקושרת מה שיאפשר הוצאה , סכימה והכנסה מחדש בזמן קבוע , ונבצע זאת $n-1$ פעמים ולכן עדיין נהיה חסומים ב $nlogn$ פעולות. 

נוכל לבצע את המטלה הזאת בזמן זהה אם נשתמש בשני תורים $Q_{1}$ $Q_{2}$ . בראשון נשמור את איברי הקבוצה המקוריים בסדר לא יורד (עולה שווה). את השני נחזיק ריק והוא יכיל רק את האיברים שנוצרים על ידי האלגוריתם כלומר סכום של שני איברים מינימליים מהקבוצה . כעת נחפש את המינימום בשני התורים אך שהפעם לא צריך להסתבך לאן מכניסים את הסכום החדש. פשוט ייכנס למאחורי $Q_{2}$ .  אם המערך ממויין זמן העבודה הוא ליניארי 

![[Pasted image 20220623155501.png]]

## מחסנית 
המקבילה של FIFO של המסנית היא LIFO (last in first out). בגלל זה למבנה נתונים קוראים מחסנית, הקליע האחרון שנכניס למחסנית הוא הראשון שיצא בלחיצה על ההדק. 

כמו [[#תור]] גם מחסנית ניתן לממש על ידי הקצאות רציפות והקצאות מקושרות. בניגוד לתור אנחנו לא מתעסקים עם תחתית המחסנית אלא רק עם מי שנמצא למעלה שהוא ה $top$ .  באופן סכמתי זה יראה כך :
![[Pasted image 20220623161246.png]]

כיוון שהמימושים נורא זהים על מערך ורשימה מקושרת ארשום פה רק את הפסודו קוד של כל אחד מהם 
![[Pasted image 20220623162759.png]]

בשני המקרים הוצאה והכנסה היא ב $O(1)$ אבל נורא קשה לבצע פעולות סריקה וכו...

#### דוגמאות לשימוש במחסנית -  ביטויים אריתמטיים 
נסתכל על ביטוי מתמטי שאנחנו נתקלנו בו ביסודי 
$$4+3 \times5$$
בעוד שהמחשבוני כיס הפשוטים יתרגמו את זה כ35, אנחנו עוד משהיינו ילדים הבנו שיש פה עדיפות לפעולת הכפל לפני פעולת החיבור והתשובה האמיתית היא 19 . ומה אם היה את הביטוי הבא 
$$(4+3)\times 5$$
סגנון הכתיבה הזה כנראה מגיע מסיבות היסטוריות שכן , כיום כשאנחנו מפעילים פונקצייה על משתנה מסויים אנחנו רושמים $f(x)$ ואם זה שני משתנים אז $f(x,y)$ ולא $xfy$ . באופן דומה היינו צריכים לרשום את הביטוי שלנו באופן הבא $add(4,multiply(3,5))$ על מנת שזה יהיה דומה לאופן שבוא רושמים פונקציות.

סגנון הכתיבה הזה נקרא [Polish notation](https://en.wikipedia.org/wiki/Polish_notation) .(נקרא גם prefix notation)
בסגנון הכתיבה הזה נרשום את הביטוי באופן הבא 
$$+4\times 3\ \ 5\ \ \ \ \ \text{ or}\ \ \ \ \times+\ 4\ \ 3\ \  5$$
באופן דומה. יש סגנון כתיבה הנקרא [Reverse Polish notation](https://en.wikipedia.org/wiki/Reverse_Polish_notation). (נקרא גם  postfix notation).
בשיטה זאת נרשום קודם את המספרים ולאחר מכן את הביטוי המתמטי שנרצה לבצע. זה יראה כך 
$$4\ \  3\ +\ 5\ \times \ \ \ \ \text{ or}\ \ \ \ \ 4\ \ 3\ \  5\ \times+$$

הסטנדרט הנ״ל נקרא [Infix notation](https://en.wikipedia.org/wiki/Infix_notation). בשיטה הזאת למחשב יכולה להיות בעיה לדעת מהן סדרי העדיפויות אך בשיטת postfix למעשה הדבר נהיה די פשוט, סך הכל לבצע סריקה של המחסנית תהיה פשוטה מאוד על ידי סריקה של הביטוי עם מחסנית באופן הבא : 
מכניסים איברים למחסנית נניח שהשניים האחרונים שנכנסו הם $y,z$ ברגע שייכנס אופרטור $X$ מוציאים את שני האיברים הנ״ל מהמחסנית ומחזירים למחסנית את התוצאה המתקבלת מהפעלת האופרטור על איברים אלו. 

בפסודו - 

![[Pasted image 20220623181003.png]]

ובאופן ויזואלי  על הביטוי 
$$\displaylines{
\text{infix: }(4+3)\times(2\uparrow(14-8)/2)\\
\text{postfix: }4\ \ 3+2\ \ 14\ \ 8-2/\uparrow\times
}$$
![[Pasted image 20220623181559.png]]

דיברנו על איך להשתמש במחסנית בישביל לחשב בהנחה שהביטוי הגיע בצורת postfix. עם זאת אנחנו יודעים שבפועל אנחנו רושמים ביטוי בצורת infix. נשאלת השאלה איך מתבצעת ההמרה מביטוי אריתמטי רגיל לביטוי בצורת postfix שעליו ניתן לבצע חישובים? לא אפרט כאן את ההסבר אך גם לשימוש הזה משתמשים במחסנית ובטבלת עדיפויות כאשר לסוגריים ניתן העדיפות הכי גבוהה (זה יינתן בצורת מספר) , ולאחר מכן באמצעות הטבלה האופרטים נשמרים במחסנית לפי סדר העדיפויות שלהם. 

__אנקדוטה__ המחסנית באה לידי ביטוי גם כאשר אנחנו שומרים זכרון במחשב, בעיקר של משתנים מקומיים שבסוף קריאת הפונקצייה ירדו מהstack. למשל בקריאות ריקורסיביות הפרמטרים נשמרים בstack אחד על השני וכל חזרה אחורה המשתנים המקומיים יורדים מהstack עד שהריקורסיה מסתיימת.

#### תרגילים רשימות ליניאריות
![[Pasted image 20220623210018.png]]

נשתמש בשני פוינטרים שמתחילים בתחילת המערך אחד מהם נריץ בצורה רגילה ואת השני נריץ פי 3 יותר מהר. חשוב לציין שלא נקבל שגיאת overflow בגלל שאנחנו יודעים שהרשימה היא בגודל 3k. 
נריץ כך עד שהמצביע המהיר יותר יצביע על null .
__טענה__ המצביע האיטי יותר יהיה בידיוק באינדקס 1/3n.
__הוכחה__ המצביע המהיר יותר מגיע לסוף הרשימה שאורכה $n$ בקצב של $3$ צעדים כל איטרצייה כלומר סך הכל עשה $1/3n$ צעדים. בגלל שהמצביע האיטי יותר עושה צעד בודד כל איטרצייה הוא בהכרח יהיה באינדקס $1/3n$ .

כעת אנחנו דילגנו על השליש הראשון, נעביר את המצביע שהגיע לסוף הרשימה למיקום של המצביע השני באינדקס $1/3n$ . כעת יש לנו בעיה נוספת, יש לנו שני שליש נוספים לסריקה אנחנו צריכים לסרוק רק את השליש הראשונים. לכן נעשה באותו אופן הנ״ל רק שהפעם במקום להזיז פי 3 יותר מהר נזיז פי 2 באופן זה נסרוק את החצי הנוצר שהוא בעצם השליש האמצעי מהרשימה המקורית __כדרוש__. 

```ad-Code
```code

p=head q=head
while q.next not equal null :
	p = p.next()
	q = q.next().next().next()
	
q=p
while q.next() not equal null :
	print(p)
	p=p.next()
	q=q.next().next()

```

כפי שהוכחנו בתרגול יהיה מעגל אם ורק אם המצביעים הנ״ל ייפגשו מתישהו בחסם התלוי בגודל הרשימה (כלומר יהיה סיבוב אחד ועוד מספר קבוע של צעדים). לא אפרט פה את כל ההוכחה אבל ניתן לקרוא עוד ב [Floyd’s Cycle-Finding Algorithm](https://en.wikipedia.org/wiki/Cycle_detection).

![[Pasted image 20220623214315.png]]
הפתרון הוא לשמור את איברי המטריצה ברשימה מקושרת של רשימות מקושרות (או רשימה מקושרת דו מימדית) כאשר האיברים בשורה הראשונה במטריצה ששונים מ 0 יהיו ברשימה הראשונה וכן הלאה עד $n$ . כיוון שמחפשים רק את איברי ה $trace$, אנחנו יודעים שיתקיים 
$$a_{ii}=C_{i}(M)\cdot R_{i}(M)$$
וה$trace$ יהיה סכומם של כל איברים אלו, מהנתון שמספר האיברים בכל השורות והעמודות ששונות מ 0 חסום ב $O(n)$ והעובדה שאנחנו סך הכל סוכמים ומבצעים פעולות כפל על כל איברים אלו שאלה פעולות קבועות, אנחנו נמצא את ה $trace$ ב $O(n)$ 


![[Pasted image 20220624123912.png]]
* נוכל להשתמש בחיפוש בינארי פשוט נתחיל מאמצע המערך , אם האיבר שלילי והאיבר לפניו חיובי סיימנו, אחרת נלך לחצי של תת המערך השמאלי. אם האיבר חיובי והאיבר אחריו שלילי גם סיימנו , אחרת נלך לחציו של תת המערך הימני. 
סך הכל כפי שהוכחנו על אלגוריתם חיפוש בינארי זה ייקח $O(logn)$

* במקרה הזה נצטרך אקסטרה מקום עבור פוינטר נוסף , שאיתו נעשה חיפוש ליניארי ועם הפוינטר השני נעשה את החיפוש הבינארי הנ״ל . כלומר אחר סורק רגיל והשני סורק בחיפוש בינארי.

* נשתמש בטכניקה שראינו ב [skip list](https://www.geeksforgeeks.org/skip-list/) . נזוז בקפיצות של $2^i$ כלומר סדרה הנדסית. ברגע שמצאנו אינדקס שהחזקה הבאה אחריו היא שלילית ניקח את המערך $A[2^{i}...min(2^{i+1},n)]$ ועליו התת מערך הזה נעשה חיפוש בינארי.
* סך הכל אנחנו עושים $i$ פעולות כדי להגיע למצוא את תת המערך ואז עוד $log(min(2^{i+1},n)-2^{i})$ וסך הכל נקבל פעולה לוגריתמית שחסומה באינדקס הנתון כיוון ש $2^{i}$ זה מספר הצעדים שהיינו זזים בזמן ליניארי וכנל לגבי מה שבתוך הלוג השני. סך הכל האינדקס שיימצא בתוך הלוג השני ועוד $i$ פעולות יהיה בעצם $log(k)$ פעולות.


![[Pasted image 20220624123209.png]]

__סתירה__ , על פניו נראה שאפשר כי ראינו אלגוריתם ל[מיון מחסנית בעזרת מחסנית אחרת)](https://www.geeksforgeeks.org/sort-stack-using-temporary-stack/) שזה בידיוק מה שהתרגיל מבקש. עם זאת הקאץ׳ כאן הוא שאסור לנו להשתמש במשתנה עזר כדי לשמור ערך מסויים מחוץ למחסנית. חייב לעשות את זה אך ורק עם ראשי המחסנית. מצב זה כבר לא אפשרי למשל 

עבור הקלט $1,3,2$ לא נצליח לפתור את הבעיה נדגים זאת ויזואלית:

![[Pasted image 20220624134553.png]]

אומנם  1 נמצא בקדמת הכביש אך מכאן נכנס למחזוריות כזאת שלא נוכל לסדר את 2 ו 3 בסדר המתאים.

![[Pasted image 20220624135235.png]]
![[Pasted image 20220624135244.png]]

נתבונן במשחק לדוגמה עבור 5 ילדים ו ושהחסם העליון הוא 2 

![[Pasted image 20220624154022.png]]

בגלל שאנחנו יודעים שלא משנה מה ערכו של $k$ תמיד יושמט ילד , אז אין חשיבות בכלל לערכו של $k$ בשביל חישוב הריצה זה תמיד יהיה $O(k\cdot n)$. זאת כיוון שלכל מהלך שנבצע ומספר ההזות שנזיז תמיד מישהו יוצא מהמשחק. כל מהלך אנחנו מבצעים  $i\leq k$ פעולות ונבצע זאת $n$ פעמים. הסיבה שאנחנו משאירים את $k$ ולא חוסמים ב $n$ ישירות היא ש $k$ יכול להיות יותר גדול מ $n$ ואז זמן הריצה יהיה גדול בהרבה.
  
זה הקוד עבור $circularLinkedList$ : 

```ad-Code
```java

public int findTheWinner(int n, int k) {
 CircularLinkedList circularGame = new CircularLinkedList(n);         
   int count = k;
    CircularLinkedList.Node currentNode=circularGame.head();
    while (circularGame.hasNotRemainedOne()) {
	 CircularLinkedList.Node kNode = 
       circularGame.incrementWithSteps(currentNode, count);
       currentNode = kNode.next;
       circularGame.remove(kNode);
     }
     return circularGame.head().value;
    }

```

במקרה של מערך נתנהל באותו אופן רק שהפעם יהיה בעייתי להסיר איברים לכן נוסיף $flag$ בוליאני שיקבע האם הבן אדם במשחק או לא. סך הכל זמן הריצה יהיה זהה 

```ad-Code
```java

  public int findTheWinner(int n, int k) {
    // true if i-th friend is left
    boolean[] friends = new boolean[n];
    int friendCount = n;
    int fp = n; // friends' pointer
    while (friendCount > 1) {
      for (int i = 0; i < k; ++i, ++fp)
        while (friends[fp % n]) 
          ++fp;                 
      friends[(fp - 1) % n] = true;
      --friendCount;
    }
    for (fp = 0; friends[fp]; ++fp);
    return fp + 1;
  }

```

מבחינת זמן הריצה בין שני הפעולות אין שינוי עם זאת, חשוב לשים לב שבעבודה עם מערך אנחנו מעולם לא מקטינים אותו כמו ברשימה מעגלית. לכן בחסמים מאוד גדולים אנחנו נבצע יותר פעולות.




![[Pasted image 20220624163524.png]]
חשוב לשים לב שיש לנו sentinel element כלומר פוינטר התחלתי שיצביע לתחילת הרשימה תמיד.

__insert__ : 
 אם הרשימה ריקה פשוט הnode יצביע על עצמו משני הכיוונים וה start יצביע על node גם כן. במצב בוא הרשימה לא ריקה אנחנו נלך ל $prevNode$ של האיבר הראשון (ככה נגיע לאיבר האחרון ישר) ואחריו נשים את האיבר החדש שנכנס 

```ad-Code
```cpp

void insertEnd(struct Node** start, int value)
{
	if (*start == NULL)	{
		struct Node* new_node = new Node;
		new_node->data = value;
		new_node->next = new_node->prev = new_node;
		*start = new_node;
		return;
	}
	
	Node *last = (*start)->prev;
	struct Node* new_node = new Node;
	new_node->data = value;
	new_node->next = *start;
	(*start)->prev = new_node;
	new_node->prev = last;
	last->next = new_node;
}

```

ובאופן ויזואלי :

__אם ריק__ 
![[Pasted image 20220624164916.png]]

__אם לא ריק__ 

![[Pasted image 20220624164939.png]]

__deletion__ :
אם הרשימה ריקה כולל start , פשוט מחזירים null .
אחרת מחזיקים שני פוינטרים אחד לראש המעגל ואחד נוסף שבינתיים יהיה null.
נזוז על גבי הרשימה עד שנמצא את האיבר שאותו נרצה להסיר עם הפוינטר הראשון כאשר כל איטרציה נבצע השמה של הפוינטר הראשון לפוינטר השני .
אם מצאנו את האיבר שלנו נבדוק שהוא לא היחיד ברשימה (הוא היחיד אם הוא גם הקודם וההבא בתור של עצמו). במידה והוא האיבר היחיד נגדיר ש start=null וסיימנו.
כעת נבדוק מספר דברים
* האם האיבר שאנחנו עומדים עליו הוא האיבר הראשון - אם כן נזיז את המצביע השני לקודמו והוא יצביע לסוף . ונשנה בהתאם את ערכי המצביעים : 
start.next = start.next.next וגם נשנה את ההצבעות באיבר האחרון 

* אם הוא האיבר האחרון אז נזיז את המצביע השני להתחלה ונשנה כמו למעלה רק על המצביעים ההפוכים.

* בכל מקרה אחר המעגל לא מורגש ולכן ננהל את זה כמו רשימה מקושרת דו כיוונית רגילה.
* 
![[Pasted image 20220624171436.png]]
(a) : 
$$n^{2}-n\geq\frac{1}{2}n^{2}=n^{2}-\frac{1}{2}n^{2}$$
על מנת שהנ״ל יתקיים נצטרך ש 
$$n<\frac{1}{2}n^{2}=n\cdot\frac{1}{2}n$$
כיוון ש$n$ הוא מספר טבעי הנ״ל יתקיים לכל $n$ שגדול מ1 .ולכן 
$$\exists_{n_{0}=1,C=\frac{1}{2}}\forall_{n>n_{0}}:n^{2}-n>Cn^{2}$$
לכן אנחנו מקיימים את ההגדרה $n^{2}-n\in\Omega(n^{2})$ .

(b) : 
$$\displaylines{
\log(n)+\cos(n)\leq \log(n)+1=\log(n)+\log(2)<2\log(n)
}$$
המעבר האחרון נכון לכל $n>2$ . לכן חסום מלמעלה על ידי $logn$
 
באופן דומה נבצע על החסם התחתון של קוסינוס שהוא $-1$ ונקבל שהוא חסום למטה על ידי $logn$ . סך הכל פונקצייה זו מהווה חסם הדוק.


![[Pasted image 20220624182112.png]]
* נסמן $n=2^m$
$$T(2^{m})=T(2^\frac{m}{2})+1$$ כעת נגדיר $S(m)=T(2^{m})$ ונקבל :

$$S(m)=S(\frac{m}{2})+1$$
בעצם קיבלנו ש $T(n)=S(m)\in O(log(m))=O(\log(\log(n)))$

*  סעיף ב יהיה -  $f(n)=2^\sqrt{logn}$ 
(ג זה נושא שלא למדנו)


# עצים כלליים ובינארים
בפרק הקודם דיברנו על מבני הנתונים הליניאריים - יש להם יתרונות רבים, עם זאת , הבעיה הכי גדולה שלהם היא שתמיד נצטרך לבחור בין היכולת לחפש ביעילות, לבין היכולת לגשת למידע ולעדכן מידע במהירות. ברוב המקרים תהיה התנגשות בין השניים. המגבלה הזאת שלכל record יש רק איבר אחד הבא אחריו יכולה להיות יתרון ומגבלה גדולה. בשביל זה עצים נכנסים לתמונה והם יאפשרו לנו להגיד מבני נתונים שלא מגבילים אותנו מהבחינה הזו. 

__הגדרה__ : עץ במונחים של מבנה נתונים (בתורת הגרפים יכול להיות מוגדר אחרת) הוא אוסף של אלמנטים הנקראים $nodes$ שמקיימים -
* יש אלמנט הנקרא $root$ 
* כל מי שאינו ה $root$ בעץ יכול להיות ה $root$ בתת עץ משלו או חלק מתת עץ אחר. במילים אחרות אם ניקח תת קבוצה של הקבוצה שלנו בלי ה $root$ ואפשר גם בלי אלמנטים נוספים, נקבל עץ .

![[Pasted image 20220624190014.png]]
לדוגמא, 2 במקרה זה הוא שורש העץ אבל אם ניקח את הקבוצה ת 7,10,11,6 נקבל עץ גם כן. אחת הדוגמאות מוכרות של עצים היא ה [DOM](https://he.wikipedia.org/wiki/Document_Object_Model) שזה אובייקט שמתאר את תגיות ה$html$ שאיתם בונים אתרים. 

למעשה כמעט כל מבנה נתונים ליניארי יכול להחשב כעץ שלכל עץ יש ילד אחד.

__טרמינולוגיה חשובה בעצים__
* השורש - ה node העליון ביותר (ללא אבא)
* node/צומת - קודקוד בעץ - יכול להכיל data כלשהו ובנוסף מחזיק בתוכו מצביע לילדים שלו (לפי סוג העץ נקבע כמה ילדים יש לו אבל בעץ כללי אין מגבלה).
* ילד- קודקוד שיש לו אבא
* קשת- חיבור בין בני קודקודים 
* עלה- קודקוד שאין לו ילדים 
* גובה- המרחק הארוך ביותר בין שורש לעלה
* עומק / רמה - המרחק בין קודקוד כלשהו לשורש העץ. (נשים לב שעומק תלוי ב node שבוא אני נמצא)
* שכנים/קרובים - כל הקודקודים שיש להם אבא משותף.

__הגדרות בסיס__ 
* לעץ כללי יש לפחות קודקוד אחד 
* עץ עם קודקוד יחיד (שורש בלי ילדים) , גובהו $0$.

![[Pasted image 20220624193720.png]]
בעצים שיטת הסריקה המומלצת ביותר היא על ידי ריקורסיה כמו כן , עץ הוא [מבנה נתונים מופשט](https://en.wikipedia.org/wiki/Abstract_data_type) וניתן לממשו בשיטות רבות ומגוונות (אולי כאלו שגם לא דורשים סריקה ריקורסיבית). השיטה הקלאסית למימוש עץ היא על ידי אובייקט $node$ שמכיל מידע ומערך לילדים שלו.

באופו כללי ניתן להסתכל על עץ באופן הריקורסיבי הבא :
![[Pasted image 20220624193849.png]]

## עץ בינארי 
__הגדרה:__ עץ בינארי הוא אוסף המקיים את התכונות הבאות 
* או שהוא ריק 
* אם לא ריק , השורש מכיל שני תתי עצים שהם בעצמם עצים בינאריים . 
במילים אחרון לכל אב יש שני בנים לכל היותר. 

נשים לב שעץ בינארי הוא לא מקרה פרטי של עץ כיוון שהקבוצה הריקה היא יכולה להיות העץ הבינארי הריק בעוד שבעץ כללי חייב שיהיה לפחות שורש.
__העץ הריק הוא עץ ללא שורש וללא קודקודים וגובהו מסומן כ $-1$ .__


### מעצים כלליים לעצים בינאריים 
ניקח ״יער״ מסודר שזה בעצם אוסף של עצים כלליים.. ניתן להמיר יער סדור (אוסף של עצים כללים שמוגדר עליהם יחס סדר כלשהו) לעץ בינארי על ידי פונקצייה הפיכה כלומר מיפוי של 1:1 בין היער לעץ הבינארי.

הפונקצייה תעבוד באופן הבא : יהי $T$ עץ בינארי ו $F$ יער סדור.
* השורש של $T$  יהיה השורש של העץ השמאלי ביותר ביער $F$ . 
* הילד שמאלי של קודקוד $v$ ב $T$ יהיה הילד השמאלי __(אם יש ילד אחד אז הוא אוטומטי שמאלי, כי אין פה יחס סדר עדיין על האיברים בעץ)__ של אותו הקודקוד ביער. הילד הימני יהיה השכן המיידי מצד ימין של $v$ ב $F$ אם יש כזה (אם אין אז אין ילד ימני). השורשים של היער הם מקרה מיוחד והם נחשבים שכנים אחד של השני.

בצורה ויזואלית - 

![[Pasted image 20220624220444.png]]

__אנקדוטה__ דיברנו על כך ניתן לייצג יער כעץ בינארי עם שימוש בפונקצייה הפיכה, נוכל לקבוע משהו יותר חזק מזה, בהינתן $n+1$ קודקודים נוכל לדעת בידיוק כמה יערות וכמה עצים בינאריים ניתן לבנות מיער זה. לשם כך נגדיר שעץ $T$ עם שורש $R$ ו $k$ תתי עצים יסומן כך : 
$$(RT_{1}T_{2}\dots{T_{k}})$$
זאת הגדרה ריקורסיבית ולכן נפתח סוגריים על כל תת עץ של תת עץ וכן הלאה... למשל עבור העץ הבא 

![[Pasted image 20220624224434.png]]

הסידור יהיה
$$\bigg(\big( 3\ (2)\ (4)\big)\big(9\big)\big(10\ (8\ (7))\big)\bigg)$$
 למעשה נוכל להגדיר את זה גם בלי ערכים כלל , אם מעוניינים רק במבנה העץ.
 $$\bigg(\big( \ ()\ ()\big)\big(\big)\big(\ (\ ())\big)\bigg)$$
	לא נפרט את ההוכחה המלאה אבל ראינו משהו דומה , [מספר קטלן](https://he.wikipedia.org/wiki/%D7%9E%D7%A1%D7%A4%D7%A8_%D7%A7%D7%98%D7%9C%D7%9F) יכולים להגדיר לנו בידיוק כמה סוגריים כאלה ניתן לשים על $n$ ערכים שונים. לכן יש סך הכל : 
	$$\frac{1}{n+1}\binom{2n}{n}$$
	אפשרויות ליצור יערות מ $n$ קודקודים שונים.
	

### תכונות העצים הבינאריים
נדבר על שיטות הסריקה של עץ בינארי. מטרת הסריקה יכולה להיות שונה ולכן בחירת שיטת הסריקה תהיה קשורה למטרה שלשמה רוצים לסרוק : 

##### סריקות DFS (חיפוש עומק)
__pre-order__ - עבור כל צומת  נדפיס את ערכו , לאחר מכן נעבור לבנו השמאלי של העץ, לבסוף נלך לבנו הימני. 
__in-order__ - עבור כל צומת יש להדפיס תחילה את הבן השמאלי, לאחר מכן לעבור לערכו שלו ולבסוף לבן הימני. 
__post-order__ - עבור כל צומת יש להדפיס את הבן השמאלי, לאחר מכן את הבן הימני ולבסוף את ערך הצומת עצמו.

__נשים לב שזאת סריקה ריקורסיבית לכן, למשל, בסריקת in-order אנחנו נמשיך לרדת בצמתים כל עוד יש בן שמאלי ורק אז נעלה למעלה__ .

```ad-Code
```cpp
struct Node{
    int data;
    Node *left, *right;
};
void preOrderPrint(Node *root)
{
  print(root->name);                                  //record root
  if (root->left != NULL) preOrderPrint(root->left);  //traverse left if exists
  if (root->right != NULL) preOrderPrint(root->right);//traverse right if exists
}

void inOrderPrint(Node *root)
{
  if (root.left != NULL) inOrderPrint(root->left);   //traverse left if exists
  print(root->name);                                 //record root
  if (root.right != NULL) inOrderPrint(root->right); //traverse right if exists
}

void postOrderPrint(Node *root)
{
  if (root->left != NULL) postOrderPrint(root->left);  //traverse left if exists
  if (root->right != NULL) postOrderPrint(root->right);//traverse right if exists
  print(root->name);                                   //record root
}
```
__חשוב מאוד__ סריקת $pre order$ מאפשרת לנו לשחזר את העץ במדוייק אם העץ הוא עץ חיפוש בינארי (נפרט בהמשך). כמו כן בהינתן סריקת $inorder$ ו $postorder$ גם כן ניתן לשחזר את העץ ($in$ ייתן לנו את תתי העצים בעוד ש $post$ ייתן לנו את השורשים).

##### סריקות BFS (חיפוש רוחב)
נשתמש בתוך כדי לסרוק את האיברים בעץ , קומה קומה 
כל קומה נכניס איברים לתור ונדפיס אותם , מיד לאחר הדפסה נוציא אותם מהתור ונכניס את האיברים הבאים בקומה... נמשיך ככה עד שנגיע לעלים .

```ad-Code
```cpp
void printLevelOrder(Node* root)
{
	if (root == NULL)
		return;
	queue<Node*> q;
	q.push(root);

	while (q.empty() == false) {
		// Print front of queue and remove it from queue
		Node* node = q.front();
		cout << node->data << " ";
		q.pop();

		if (node->left != NULL)
			q.push(node->left);
		if (node->right != NULL)
			q.push(node->right);
	}
}

```

#### עץ בינרי שלם  complete binary tree
עץ המכיל איבר יחיד או מכיל שורש ושתי תתי עצים שהם בעצמם עץ בינארי שלם. במילים אחרות, זה עץ שלכל קודקוד יש או 0 בנים, או 2 בנים .
![[Pasted image 20220625105510.png]]

ההגדרה הריקורסיבית הזו מופשטת ומאפשרת לנו ״להפריט״ אותה למבנים אחרים , למשל נוכל להשתמש בה כדי לייצר ביטויים אריתמטיים המכילים אופרטים בינאריים. במבנה של עץ בינארי שלם נוכל להגדיר ביטוי אריתמטי כעץ כזה שלכל קודקוד יכול להיות משתנה (orpand) או אופרטור שלו יש שני ילדים או שני תתי עצים שהם בעצם ביטויים אריתמטיים . ויזואלית: 
![[Pasted image 20220625110051.png]]
זה בעצם הביטוי 
$$(a-b)\times(c\uparrow{d/e})$$
נזכיר ש $\uparrow$ זה העלאה בחזקה.

יותר מזה צורות הסריקה השונות יביאו לנו את הביטויים האלה בצורת $prefix$ $infix$ $postfix$ של הביטויים.
![[Pasted image 20220625110251.png]]


#### עץ בינארי מלא full binary tree
זה עץ שבוא לכל הצמתי מלבד העלים יש שני בנים בידיוק והעלים כולם נמצאים באותה רמה. (מקרה פרטי של עץ בינארי שלם).

![[Pasted image 20220625110721.png]]

__נשים לב ההגדרות המדוייקות יכולות להשתנות במקומות מסויימים שבוא אתם צורכים את הידע שלהם , עם זאת התכונות יישארו אותם תכונות__. 

#### הוכחות בעצים
בגלל המבנה הריקורסיבי של עץ בינארי , את רוב ההוכחות המתמטיות על עצים נוכל ונרצה להוכיח באינדוקציה, הרבה הוכחות נוכל לעשות באינדוקצייה שבסיסה הוא מספר הקודקודים , מספר העלים , העומק וכו... אלטרנטיבה תהיה לבצע אינדוקצייה על __מבנה העץ עצמו__ . כלומר על תתי העצים (כפי שהגדרנו עץ בינארי שילדיו הם עצים בינאריים בעצמם). באופן הזה, נוכל בעצם להתחמק מלהראות תכונות מסויימים כל קודקודים, קשתות, וכו. 

__משפטים__ 
* __בעץ בינארי שלם עם $n\geq{1}$ עלים, יש $n-1$ קודקודים פנימיים (קודקוד פנימי זה כל קודקוד שהוא לא עלה כולל השורש)__. 
הוכחה: 
הבסיס יהיה פשוט בכל מקרה, אם יש קודקוד אחד הוא שורש ועם 0 קודקודים פנימיים.
נוכל להוכיח באינדוקצייה על מספר העלים ובהנחת האינדוקצייה נתחיל להתסבך, לכן נעשה אינדוקציה על מבנה העץ. 

בצעד האינדוקציה , נרצה להניח שהטענה מתקיימת על עצים עם $k-1$ עלים ונוכיח על עץ עם $k$ עלים.
נסתכל על השורש ונסמן את תתי העצים כ $T_{L},T_{R}$ . כיוון שהעץ שלם אנחנו יודעים שיש שני תתי עצים כאלה (אם היה רק אחד זה היה בסתירה להגדרה והיינו נשארים רק עם השורש). כיוון שההגדרה היא שגם תתי העצים עצמם הם עצים בינארים שלמים, לכל אחד מהם יש לפחות עלה אחד. 
נסמן את מספר העלים של כל תת עץ כזה כ $k_L$ ו $k_{R}$ (אנחנו יודעים ששניהם גדולים או שווים ל1 ולכן כל אחד מהם בנפרד קטן ממש מ $k$) ואנחנו יודעים שמתקיים 
$$k=k_{R}+k_{L}$$
מספר הקודקודים הפנימיים בכל תת עץ כזה, לפי הנחת האינדוקצייה יהיה $k_{R,L}-1$ בהתאמה, סך הכל נקבל שמספר הקודקודים הפנימיים בעץ הגדול הוא 
$$k_{R}-1+k_{L}-1+1=k-1$$
(ההוספה של האחד היא בגלל שסופרים את השורש של העץ הגדול שלא שייך לתתי העצים בספירה). 


* עץ בינארי עם עומקי עלים $l_{i}:i\in[n]$ ($n$ עלים וכל עלה יש עומק שלו , לאו דווקא שונים) יהיה עץ שלם __אם ורק אם__ מתקיים $\sum\limits_{i=1}^{n}2^{-l_{i}}=1$ . (אם זה קטן מאחד נקבל עץ לא שלם, אם זה גדול מ1 נקבל שאנחנו לא עובדים עם עץ).

נוכיח באינדוקצייה על מבנה העץ : 
בבסיס אם $n=1$ אז כפי שהגדרנו הגובה של שורש הוא $0$ ונקבל $2^{0}=1$.
בצעד נסתכל על תתי העצים ונסמן שבתת העץ השמאלי יש $k$ עלים וניתן להם את האינדקסים $[k]$ . ובתת העץ הימני יש $k+1,....,n$ עלים. כמו כן נגדיר את הגובה של העלה ה$i$ בתת העץ המתאים לו כ $d_{i}=l_{i}-1$ סך הכל יתקיים מהנחת האינדוקצייה השלמה על מבנה העץ.

$$\displaylines{
\sum\limits_{i=1}^{n}2^{-l_{i}}=\sum\limits_{i=1}^{k}2^{-l_{i}}+\sum\limits_{i=k+1}^{n}2^{-l_{i}}=\\
\sum\limits_{i=1}^{k}2^{-d_{i}-1}+\sum\limits_{i=k+1}^{n}2^{-d_{i}-1}=\\
\frac{1}{2}\sum\limits_{i=1}^{k}2^{-d_{i}}+\frac{1}{2}\sum\limits_{i=k+1}^{n}2^{-d_{i}}=\frac{1}{2}+\frac{1}{2}=1
}$$
המעבר האחרון נובע כי זה בידיוק הנחת האינדוקצייה, על תתי העצים האלה.

__משפטים נוספים (בלי הוכחה)__ 
* בעץ בינארי מלא בכל רמה $i$ יש $2^i$ קודקודים.


## עץ חיפוש בינארי 
עד עכשיו דיברנו על עץ בינארי ברמה המופשטת שלו, אבל לא ממש הגדרנו איך אנחנו מסדרים את האיברים בתוך המבנה הזה. בשיטה זו אנחנו מכניסים את ה records לעץ בהתאם לערכיהם ויחס הסדר המוגדר על האיברים. וניתן לזהות את האיבר לפי ערכו. 

![[Pasted image 20220625131737.png]]

__הגדרה__ : בעץ חיפוש בינארי על כל node עם ערך $v$ הערכים בתת העץ השמאלי של קודקוד זה יהיו קטנים מ $v$ והערכים בתת העץ הימני יהיו גדולים יותר.

### חיפוש 
החיפוש מתחיל בשורש, אם האלמנט לא נמצא שם נבדוק האם הערך קטן יותר או גדול מהשורש או מהקודקוד עליו אנחנו נמצאים, לאחר מכן באופן ריקורסיבי נרד בתת העץ המתאים עד שנגיע לעלה (הילד הימני והשמאלי של עלה יהיה null ואם נגיע למצב הזה נדע שלא מצאנו את האיבר שאנחנו מחפשים בתת עץ זה). את מתודת החיפוש ניתן לבנות באופן כזה שאנחנו נותנים מצביע לתחילת העץ או תת העץ אותו נרצה לבדוק (לרוב זה יהיה השורש). 

בפסודו: 

![[Pasted image 20220625132420.png]]
נשים לב שאנחנו מחזירים שלישייה סדורה, שמגידרה האם מצאנו או לא מצאנו את האיבר , מצביע לאותו קודקוד ומיקום בעץ הכולל (האם זה עץ ימני או שמאלי).

קשה לדבר על זמני ריצה בעצי חיפוש בינאריים, זאת כיוון שבהתאם לסוג העץ זמני הריצה משתנים אבל כשאין מגבלות על העץ זה חסום במספר האיברים בעץ במקרה הגרוע. 

### הכנסה
כדי להכניס ערך מסויים יש לבדוק שהוא לא קיים בעץ קודם, אם לא מצאנו אנחנו נקבל מצביע לעלה בו נצטרך להכניס אותו ובאיזה צד הוא אמור להכנס. זה בידיוק המידע שאנחנו צריכים כדי לבצע הכנסה בזמן קבוע : 

![[Pasted image 20220625140127.png]]

במילים מה שקורה בקוד הוא ששאילת החיפוש תחזיר flag אם הערך נמצא או לא, במידה ולא אנחנו אמורים לקבל מצביע לעלה $R$ שמתחתיו נצטרך לשים את העלה, את הצד היה ניתן לבדוק בזמן קבוע גם כן אבל כבר קיבלנו אותו בשאילתת החיפוש אז נשתמש בו. לפיכך גם ההכנסה חסומה ב מספר הקודקודים.

## מחיקה 
השאילתה המעניינת היא שאילתת המחיקה , במבני הנתונים הליניאריים היחס בין הכנסה להוצאה היה די סימטרי (גם בקוד לא היה הרבה שוני). המצב שונה בעצי חיפוש בינאריים כיוון שיש מספר מקרים שצריך לקחת בחשבון .  נדגים ויזואלית על העץ הזה מהתמונה למעלה: 
![[Pasted image 20220625131737.png]]
* השלב הראשון, בדיקה שהאיבר נמצא במידה וכן נבדוק את המקרים הבאים.
* אם הוא עלה, צריך רק לשחרר אותו מהזכרון ולהחליף את ערכו ב null. (למשל נרצה למחוק את 52).
![[Pasted image 20220625141523.png]]
* אם לקודקוד שנרצה למחוק יש ילד אחד, המחיקה תתבצע בדומה לרשימה מקושרת, נקשר בין האבא לילד ונעיף את הקודקוד המחבר מהעץ. למשל נמחק את הקודקודים הפנימיים עם ילד אחד : 4,17
![[Pasted image 20220625141649.png]]

* אם לקודקוד שנרצה למחוק יש שני ילדים , זה המקרה המסובך יותר כיוון שלאותו קודקוד יש מצביע אחד לאבא ושני מצביעים מתחתיו , קישור שלהם ישירות לאבא יכול לשבש את העץ. הפתרון הוא פשוט , לא נמחק את הקודקוד עצמו אלא נחליף את ערכו בערך של האיבר השמאלי ביותר (הקטן ביותר) של תת העץ הימני של אותו קודקוד (כלומר, לצאת ימינה לתת העץ הימני , ומייד לאחר מכן ללכת הכי שמאלה שאפשר, אם אי אפשר פשוט לוקחים את השורש של תת העץ הימני) . __אם זה נשמע מוכר לכם, אז זה בידיוק ההדפסה של inorder שדיברנו עליה מקודם__ כלומר פשוט לקחת את האיבר הבא בהדפסת inorder ולשים את ערכו במקום האיבר שלנו. לבסוף מוחקים את הקודקוד שמייצג את האיבר הזה שהוא בוודאות שייך למקרה שיש לו ילד אחד או שהוא עלה (אחרת הוא לא היה השמאלי ביותר). 
![[Pasted image 20220625143149.png]]

__בדומה לרשימות מקושרות נוכל לטפל במקרה קצה שבוא מוחקים את השורש על ידי החזקת מצביע ללא ערך לשורש__ 


__אנדקודטה__ שחזור עצי חיפוש על ידי $inorder$ ו $postorder$ או על ידי $preorder$.
דיברנו על זה שבעצי חיפוש ההדפסות הללו יכולות לעזור לנו לשחזר את העץ, נראה איך : 

##### __post and in :__
בהינתן שתי התצוגות האלה נוכל לשחזר את העץ באופן הבא: 
* האיבר האחרון ב$post$ יהיה השורש
* נמצא את השורש ב $in$ וכעת אנחנו יודעים שכל האיברים ב $in$ מימין ל שורש הזה הם תת העץ הימני וכל מי שמשמאל יהיו האיברים בתת העץ השמאלי.
* ״משמיטים״ את האיבר שמצאנו משני ההדפסות, כעת מבצעים את אותו תהליך באופן ריקורסיבי על $in$ ו $post$ של תתי העצים. 

 __דוגמה__ 
 עבור ההדפסות 
```
in[]   = {4, 8, 2, 5, 1, 6, 3, 7}
post[] = {8, 4, 5, 2, 6, 7, 3, 1}
```
$1$ יהיה השורש. 
תת העץ השמאלי יהיה 
```
[5, 2, 8, 4]
```
ותת העץ הימני יהיה 
```
[6,3,7]
```
וההדפסות שלהם ב$post$ יהיו $6,7,3$  ו $8,4,5,2$ . 
__אני לא אדגים זאת בקוד אבל נוכל לאתר בקלות את ההדפסות post על ידי שימור באיבר הבא אחרי השורש ב. inorder. בדוגמה שלנו, ניקח את 6, נמצא אותו בpost וכל מי שמשמאלו חייב להיות בתת העץ השמאלי בצורת post.__ (הסברתי את זה כי אומנם ויזואלית קל לראות את זה אבל מבחינת קוד זה דורש קצת עבודה להפעיל את הקריאה הריקורסיבית על שתי ההדפסות האלו).

##### __pre :__ 
בהדפסת $preorder$ נוכל לשחזר את העץ גם כן באופן הבא: 
* האיבר הראשון הוא תמיד השורש
* כעת נמצא את האיבר הראשון בהדפסה שהוא יותר גדול מהשורש.
* כל האיברים מימינו כולל אותו הם תת העץ הימני, כל האיברים משמאלו הם תת העץ השמאלי.
* מפעילים את הפעולה באופו ריקורסיבי על שני תתי העצים

```ad-Code
```c
node* constructTreeUtil(int pre[], int* preIndex, int low,int high, int size) {

	if (*preIndex >= size || low > high)
		return NULL;
	node* root = newNode(pre[*preIndex]);
	*preIndex = *preIndex + 1;
	
	if (low == high)
		return root;
	int i;
	for (i = low; i <= high; ++i)
		if (pre[i] > root->data)
			break;


	root->left = constructTreeUtil
	(pre, preIndex, *preIndex,i - 1, size);
	root->right
		= constructTreeUtil(pre, preIndex, i, high, size);

	return root;
}
```


### תרגילים 
![[Pasted image 20220625151106.png]]
בהינתן 3 ערכים $x,y,z$ ללא יחס סדר, אנחנו יודעים שניתן להגדיר 5 יערות שונים עבור הערכים הללו (לפי מספרי קטלן וההוכחה למעלה ב[[#מעצים כלליים לעצים בינאריים]]) אנחנו גם יודעים שפונקציית המעבר מיער לעץ בינארי היא הפיכה ולכן יש סך הכל 5 עצים בינאריים מקבילים והם כלהלן : 
![[IMG_B8CCDA0FB534-1.jpeg|550]]

![[Pasted image 20220625153057.png]]
__יש פה טעות עם B__ אבל לפי התשובות הוא שורש העץ אז נשתמש בזה.

דיברנו כבר על האלגרותים ממש כדי לבצע את זה למעלה נעבור על זה בקצרה על הדוגמה הזאת: 

* השורש יהיה $B$ . וניתן לראות שאין לו תת עץ ימני ולכן נדלג ישר להבא בתור שהוא $H$. 
* תת העץ השמאלי של $H$ יהיה $G,L,F,I,K,A,C,N$ ב $in$ ותת העץ הימני יהיה $J,E,M,D$
*  נמצא את צורת $post$ של תתי העצים 
$L,F,G,K,C,N,A,I$  וגם $J,D,M,E$ 

* נבצע את התהליך הריקורסיבי שוב על שני תתי העצים ונקבל בסוף : 

![[Pasted image 20220625153835.png|450]]

__אם יש לי $pre$ ו $post$ אני לא בהכרח יכול למצוא את העץ במדוייק למשל:__
![[Pasted image 20220625154011.png]]
שתי העצים הללו יכילו את אותה הצורה של $pre$ ו $post$ כיוון שאין ילד שמאלי הולכים ישר לימני והפוך . הצורות יהיו $AB$ עבור pre ו $BA$ עבוד post .

![[Pasted image 20220625154143.png]]

נוכיח באינדוקצייה על מבנה העץ .
__בסיס__ : עץ שלם עם קודקוד 1 יהיה עם 0 ילדים שזה מקיים את המשוואה
__צעד__ : נניח נכונות עבור עץ בגובה של לכל היותר $k$ עלים ונוכיח עבור עץ עם $n+1$ 
יהיה $T$ עץ טרני שלם בגובה $k+1$.
מהגדרת העץ טרנרי שלם אנחנו יודעים בוודאות שיש לשורש של עץ זה שלושה תתי עצים טרניים בעצם, נסמנם $T_{1,2,3}$ בהתאמה. לכל תת עץ כזה יתקיים שיש לפחות קודקוד אחד. ונסמן את מספר העלים של כל אחד כ $n_{1,2,3}$ בהתאמה. יתקיים שמספר העלים של שלושתם שווה למספר העלים הכולל של העץ נסמנו $n$, וגם שכל אחד מהם בנפרד קטן ממספר העלים הכולל של העץ כי יש לפחות קודקוד אחד בכל תת עץ. כמו כן, שלושת העצים האלה הם בגובה הקטן מ $k$ לכן הנחת האינדוקצייה תקפה עליהם. נסמן את מספר הקודקודים הפנימיים של $T$ כ $s$ ויתקיים 
$$s=\frac{n_{1}-1+n_{2}-1+n_{3}-1}{2}+1=\frac{\sum\limits_{i=1}^{3}n_{i}-1}{2}=\frac{n-1}{2}$$
__כדרוש__ .


![[Pasted image 20220625162917.png]]

אפשר להסתכל על כל מספר כהדפסת $inorder$ של עץ בינארי (אני מניח שכל $A_{i}$ ממויין ואין כפילויות של ספרות). כעת אנחנו יכולים להתייחס לסדרה העצים הזאת כיער ואנחנו יודעים כבר ממספר קטלן שמספר האפשרויות לספר $n$ איברים ביער הוא מספר קטלן. 
$$\frac{1}{n+1}\binom{2n}{n}$$
נשים לב שמבחינת פתרון התרגיל, לעטוף $k\in[n]$ ס
זה מספר המיזוגים שאפשר לעשות לסדרת המספרים הנ״ל.  __(ביקשו 10 אני לא אחשב את זה אבל פשוט תציבו ותקבלו תשובה)__ .

